// START rdump/Cargo.toml

[package]
name = "rdump"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = { version = "4.5.4", features = ["derive"] }
anyhow = "1.0.86"
ignore = "0.4.22" # <--- NO FEATURES. THIS IS THE CORRECT LINE.
rayon = "1.10.0"
regex = "1.10.4"
serde = { version = "1.0.203", features = ["derive"] }
serde_json = "1.0.117"
pest = "2.7.10"
pest_derive = "2.7.10"
tempfile = "3.20.0"
glob = "0.3.1"



// END rdump/Cargo.toml

// START rdump/src/evaluator.rs

use anyhow::{Context, Result};
use regex;
use std::fs;
use std::path::{Path, PathBuf};
use std::time::{Duration, SystemTime};

use crate::parser::{AstNode, PredicateKey};

/// A context for a single file being evaluated.
/// It lazily loads metadata and content to avoid unnecessary I/O.
#[derive(Debug)]
pub struct FileContext {
    pub path: PathBuf,
    content: Option<String>,
}

// THE CORRECTED LINE:
impl FileContext {
    /// Creates a new context for a given path.
    pub fn new(path: PathBuf) -> Self {
        FileContext {
            path,
            content: None,
        }
    }

    /// Lazily gets the file content, reading it from disk only once.
    fn get_content(&mut self) -> Result<&str> {
        if self.content.is_none() {
            let content = fs::read_to_string(&self.path)
                .with_context(|| format!("Failed to read file content: {}", self.path.display()))?;
            self.content = Some(content);
        }
        Ok(self.content.as_ref().unwrap())
    }
}

/// The main evaluator struct. It holds the parsed query AST.
pub struct Evaluator<'a> {
    ast: &'a AstNode,
}

impl<'a> Evaluator<'a> {
    /// Creates a new evaluator with a reference to the AST.
    pub fn new(ast: &'a AstNode) -> Self {
        Self { ast }
    }

    /// Evaluates a single file path against the AST.
    pub fn evaluate(&self, path: &Path) -> Result<bool> {
        let mut context = FileContext::new(path.to_path_buf());
        self.evaluate_node(self.ast, &mut context)
    }

    /// The core recursive function that walks the AST.
    fn evaluate_node(&self, node: &AstNode, context: &mut FileContext) -> Result<bool> {
        match node {
            AstNode::And(left, right) => {
                Ok(self.evaluate_node(left, context)? && self.evaluate_node(right, context)?)
            }
            AstNode::Or(left, right) => {
                Ok(self.evaluate_node(left, context)? || self.evaluate_node(right, context)?)
            }
            AstNode::Not(node) => Ok(!self.evaluate_node(node, context)?),
            AstNode::Predicate { key, value } => self.evaluate_predicate(key, value, context),
        }
    }

    /// Dispatches to the correct logic for each predicate type.
    fn evaluate_predicate(
        &self,
        key: &PredicateKey,
        value: &str,
        context: &mut FileContext,
    ) -> Result<bool> {
        match key {
            PredicateKey::Ext => {
                let file_ext = context.path.extension().and_then(|s| s.to_str()).unwrap_or("");
                Ok(file_ext.eq_ignore_ascii_case(value))
            }
            PredicateKey::Path => {
                let path_str = context.path.to_string_lossy();
                Ok(path_str.contains(value))
            }
            PredicateKey::Name => {
                let file_name = context.path.file_name().and_then(|s| s.to_str()).unwrap_or("");
                let pattern = glob::Pattern::new(value)
                    .with_context(|| format!("Invalid glob pattern: '{}'", value))?;
                Ok(pattern.matches(file_name))
            }
            PredicateKey::Contains => {
                let content = context.get_content()?;
                Ok(content.contains(value))
            }
            PredicateKey::Matches => {
                let content = context.get_content()?;
                let re = regex::Regex::new(value)
                    .with_context(|| format!("Invalid regex pattern: '{}'", value))?;
                Ok(re.is_match(content))
            }
            
            // --- NEW IMPLEMENTATIONS ---
            PredicateKey::Size => {
                let metadata = context.path.metadata()?;
                let file_size = metadata.len();
                parse_and_compare_size(file_size, value)
            }
            PredicateKey::Modified => {
                let metadata = context.path.metadata()?;
                let modified_time = metadata.modified()?;
                parse_and_compare_time(modified_time, value)
            }
            // --- END NEW ---

            PredicateKey::Other(unknown_key) => {
                println!("Warning: unknown predicate key '{}'", unknown_key);
                Ok(false)
            }
        }
    }
}

fn parse_and_compare_size(file_size: u64, value: &str) -> Result<bool> {
    if value.len() < 2 {
        return Err(anyhow::anyhow!("Invalid size format. Expected <op><num>[unit], e.g., '>10kb'"));
    }

    let op = value.chars().next().unwrap();
    let rest = &value[1..];

    // Find the end of the numeric part
    let numeric_part_end = rest
        .find(|c: char| !c.is_ascii_digit() && c != '.')
        .unwrap_or(rest.len());

    let (num_str, unit_str) = rest.split_at(numeric_part_end);
    let num: f64 = num_str.parse()?;

    let multiplier = match unit_str.trim().to_lowercase().as_str() {
        "" | "b" => 1.0,
        "k" | "kb" => 1024.0,
        "m" | "mb" => 1024.0 * 1024.0,
        "g" | "gb" => 1024.0 * 1024.0 * 1024.0,
        _ => return Err(anyhow::anyhow!("Invalid size unit: '{}'. Supported units: k, kb, m, mb, g, gb.", unit_str)),
    };

    let target_size = (num * multiplier) as u64;

    match op {
        '>' => Ok(file_size > target_size),
        '<' => Ok(file_size < target_size),
        _ => Err(anyhow::anyhow!("Invalid size operator: '{}'. Must be '>' or '<'.", op)),
    }
}

fn parse_and_compare_time(modified_time: SystemTime, value: &str) -> Result<bool> {
    let (op, duration_str) = value.split_at(1);
    let now = SystemTime::now();

    let (num_str, unit) = duration_str.split_at(duration_str.len() - 1);
    let num: u64 = num_str.parse()?;

    let duration = match unit {
        "s" => Duration::from_secs(num),
        "m" => Duration::from_secs(num * 60),
        "h" => Duration::from_secs(num * 3600),
        "d" => Duration::from_secs(num * 3600 * 24),
        "w" => Duration::from_secs(num * 3600 * 24 * 7),
        _ => return Err(anyhow::anyhow!("Invalid time unit: '{}'. Must be s, m, h, d, w.", unit)),
    };
    
    let cutoff_time = now - duration;

    match op {
        ">" => Ok(modified_time > cutoff_time), // Modified more recently than the cutoff
        "<" => Ok(modified_time < cutoff_time), // Modified longer ago than the cutoff
        _ => Err(anyhow::anyhow!("Invalid time operator: '{}'. Must be '>' or '<'.", op)),
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser;
    use std::io::Write;
    use tempfile::{Builder, NamedTempFile};

    // Helper to create a temporary file with specific content for a test.
    fn create_temp_file(content: &str, extension: &str) -> NamedTempFile {
        let mut file = Builder::new()
            .prefix("rdump_test_")
            .suffix(&format!(".{}", extension))
            .tempfile()
            .unwrap();
        file.write_all(content.as_bytes()).unwrap();
        file
    }

    // Helper to run a query against a file and assert the result.
    fn assert_eval(query: &str, file_path: &Path, expected: bool) {
        let ast = parser::parse_query(query).unwrap();
        let evaluator = Evaluator::new(&ast);
        let result = evaluator.evaluate(file_path).unwrap();
        assert_eq!(
            result,
            expected,
            "Query: '{}' on file '{}'",
            query,
            file_path.display()
        );
    }

    #[test]
    fn test_predicate_ext() {
        let file = create_temp_file("hello world", "rs");
        assert_eval("ext:rs", file.path(), true);
        assert_eval("ext:toml", file.path(), false);
        assert_eval("ext:RS", file.path(), true);
    }

    #[test]
    fn test_predicate_path() {
        let file = create_temp_file(r#"some content"#, "txt");
        let path_str = file.path().to_string_lossy();

        let path_segment = path_str.split(std::path::MAIN_SEPARATOR).last().unwrap();

        assert_eval(&format!("path:{}", path_segment), file.path(), true);
        assert_eval("path:this_will_not_exist", file.path(), false);
    }

    #[test]
    fn test_predicate_contains() {
        let file = create_temp_file("hello rust world", "txt");
        assert_eval("contains:rust", file.path(), true);
        assert_eval("contains:'hello world'", file.path(), false);
        assert_eval("contains:goodbye", file.path(), false);
    }

    #[test]
    fn test_logical_and() {
        let file = create_temp_file("fn main() {}", "rs");
        assert_eval("ext:rs & contains:main", file.path(), true);
        assert_eval("ext:rs & contains:goodbye", file.path(), false);
        assert_eval("ext:toml & contains:main", file.path(), false);
    }

    #[test]
    fn test_logical_or() {
        let file = create_temp_file("some toml content", "toml");
        assert_eval("ext:rs | contains:toml", file.path(), true);
        assert_eval("ext:toml | contains:rust", file.path(), true);
        assert_eval("ext:rs | contains:rust", file.path(), false);
    }

    #[test]
    fn test_logical_not() {
        let file = create_temp_file("hello", "md");
        assert_eval("!ext:rs", file.path(), true);
        assert_eval("!ext:md", file.path(), false);
        assert_eval("!(ext:rs | ext:toml)", file.path(), true);
        assert_eval("!(ext:md | ext:toml)", file.path(), false);
    }

    #[test]
    fn test_complex_query() {
        let file = create_temp_file("public fn start()", "rs");
        let query = "ext:rs & !path:tests & contains:'fn'";
        assert_eval(query, file.path(), true);

        let query = "(ext:rs & contains:struct) | ext:toml";
        assert_eval(query, file.path(), false);
    }

    #[test]
    fn test_lazy_content_loading() {
        let file = create_temp_file("expensive content", "txt");
        let ast = parser::parse_query("ext:rs & contains:expensive").unwrap();
        let evaluator = Evaluator::new(&ast);
        let result = evaluator.evaluate(file.path()).unwrap();
        assert_eq!(
            result, false,
            "Should short-circuit and not evaluate contains"
        );
    }

    #[test]
    fn test_predicate_name_glob() {
        let file = create_temp_file("content", "rs");
        let file_name = file.path().file_name().unwrap().to_str().unwrap();

        // Exact match
        assert_eval(&format!("name:'{}'", file_name), file.path(), true);
        // Glob match
        assert_eval("name:'*_test_*.rs'", file.path(), true);
        assert_eval("name:'*.rs'", file.path(), true);
        assert_eval("name:'*.toml'", file.path(), false);
    }

    #[test]
    fn test_predicate_matches_regex() {
        let file = create_temp_file("hello 123 world", "txt");
        // Matches a digit
        assert_eval(r#"matches:'\d+'"#, file.path(), true);
        // Matches start of string
        assert_eval("matches:'^hello'", file.path(), true);
        // Does not match
        assert_eval("matches:'^world'", file.path(), false);
        // Invalid regex should not panic, but return an error (which assert_eval would unwrap)
        // A more robust test could check for the specific error.
        let ast = parser::parse_query("matches:'('").unwrap();
        let evaluator = Evaluator::new(&ast);
        let result = evaluator.evaluate(file.path());
        assert!(result.is_err(), "Invalid regex should produce an error");
    }

    #[test]
    fn test_unknown_predicate_is_false() {
        let file = create_temp_file("some content", "txt");
        // Our parser turns `foo:bar` into `PredicateKey::Other("foo")`
        // The evaluator should see this and return false.
        assert_eval("foo:bar", file.path(), false);
    }

    #[test]
    fn test_predicate_size_with_units() {
        // Create a file that is exactly 1.5 KB (1536 bytes)
        let content: Vec<u8> = vec![0; 1536];
        let mut file = create_temp_file("", "txt"); // file name/ext don't matter
        file.write_all(&content).unwrap();

        // Test kilobytes
        assert_eval("size:>1kb", file.path(), true);
        assert_eval("size:<2kb", file.path(), true);
        assert_eval("size:>1.6KB", file.path(), false); // Test uppercase and float
        assert_eval("size:<1.4k", file.path(), false); // Test single letter unit

        // Test bytes
        assert_eval("size:>1535", file.path(), true);
        assert_eval("size:<1537b", file.path(), true); // Test 'b' unit
        assert_eval("size:>1536", file.path(), false);

        // Test megabytes
        assert_eval("size:<1mb", file.path(), true);

        // Test invalid query
        let ast = parser::parse_query("size:>10xb").unwrap();
        let evaluator = Evaluator::new(&ast);
        let result = evaluator.evaluate(file.path());
        assert!(result.is_err(), "Invalid size unit should produce an error");
    }

    #[test]
    fn test_predicate_modified() {
        let file = create_temp_file("content", "txt");
        // The file was just created, so it was modified less than 1 hour ago.
        assert_eval("modified:>1h", file.path(), true);
        // It was not modified more than 1 hour ago.
        assert_eval("modified:<1h", file.path(), false);
    }
}


// END rdump/src/evaluator.rs

// START rdump/src/formatter.rs

use anyhow::{Result, Context};
use std::fs;
use std::io::Write;
use std::path::PathBuf;
use serde::{Deserialize, Serialize};

// We need to pass the format enum from main.rs
use crate::Format;

#[derive(Serialize, Deserialize, Debug, PartialEq)]
struct FileOutput {
    path: String,
    content: String,
}

/// Formats and prints the final output to a generic writer based on the chosen format.
pub fn print_output(
    writer: &mut impl Write,
    matching_files: &[PathBuf],
    format: &Format,
    with_line_numbers: bool,
) -> Result<()> {
    match format {
        Format::Paths => {
            for path in matching_files {
                writeln!(writer, "{}", path.display())?;
            }
        }
        Format::Cat => {
            for path in matching_files {
                let content = fs::read_to_string(path)
                    .with_context(|| format!("Failed to read file for final output: {}", path.display()))?;
                if with_line_numbers {
                    for (i, line) in content.lines().enumerate() {
                        writeln!(writer, "{:>5} | {}", i + 1, line)?;
                    }
                } else {
                    writeln!(writer, "{}", content)?;
                }
            }
        }
        Format::Json => {
            let mut outputs = Vec::new();
            for path in matching_files {
                let content = fs::read_to_string(path)
                    .with_context(|| format!("Failed to read file for final output: {}", path.display()))?;
                outputs.push(FileOutput {
                    path: path.to_string_lossy().to_string(),
                    content,
                });
            }
            // Use to_writer_pretty for readable JSON output
            serde_json::to_writer_pretty(writer, &outputs)?;
        }
        Format::Markdown => {
            for (i, path) in matching_files.iter().enumerate() {
                if i > 0 {
                    writeln!(writer, "\n---\n")?;
                }
                writeln!(writer, "File: {}", path.display())?;
                writeln!(writer, "---")?;
                let content = fs::read_to_string(path)
                    .with_context(|| format!("Failed to read file for final output: {}", path.display()))?;

                if with_line_numbers {
                    for (i, line) in content.lines().enumerate() {
                        writeln!(writer, "{:>5} | {}", i + 1, line)?;
                    }
                } else {
                    writeln!(writer, "{}", content)?;
                }
            }
        }
    }
    Ok(())
}


#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::Write;

    fn create_temp_file_with_content(content: &str) -> NamedTempFile {
        let mut file = tempfile::NamedTempFile::new().unwrap();
        file.write_all(content.as_bytes()).unwrap();
        file
    }

    // --- UPDATED AND NEW TESTS ---

    #[test]
    fn test_format_markdown() {
        let file = create_temp_file_with_content("line 1");
        let paths = vec![file.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Markdown, false).unwrap();
        let output = String::from_utf8(writer).unwrap();
        let expected = format!("File: {}\n---\nline 1\n", file.path().display());
        assert_eq!(output, expected);
    }

    #[test]
    fn test_format_cat_with_line_numbers() {
        let file = create_temp_file_with_content("a\nb");
        let paths = vec![file.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Cat, true).unwrap();
        let output = String::from_utf8(writer).unwrap();
        assert_eq!(output, "    1 | a\n    2 | b\n");
    }

    #[test]
    fn test_format_paths() {
        let file1 = create_temp_file_with_content("a");
        let file2 = create_temp_file_with_content("b");
        let paths = vec![file1.path().to_path_buf(), file2.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Paths, false).unwrap();
        let output = String::from_utf8(writer).unwrap();
        let expected = format!("{}\n{}\n", file1.path().display(), file2.path().display());
        assert_eq!(output, expected);
    }

    #[test]
    fn test_format_json() {
        let file1 = create_temp_file_with_content("{\"key\": \"value\"}");
        let file2 = create_temp_file_with_content("some text");
        let paths = vec![file1.path().to_path_buf(), file2.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Json, false).unwrap();

        // The output is pretty-printed, so we compare the parsed data, not the raw string.
        let output_data: Vec<FileOutput> = serde_json::from_slice(&writer).unwrap();

        assert_eq!(output_data.len(), 2);
        assert_eq!(output_data[0].path, file1.path().to_string_lossy());
        assert_eq!(output_data[0].content, "{\"key\": \"value\"}");
        assert_eq!(output_data[1].path, file2.path().to_string_lossy());
        assert_eq!(output_data[1].content, "some text");
    }
}


// END rdump/src/formatter.rs

// START rdump/src/main.rs

mod evaluator;
mod formatter;
mod parser;

use std::fs::File;
use std::io::{self, Write};

use anyhow::Result;
use clap::{Parser, ValueEnum};
use evaluator::Evaluator;
use ignore::overrides::OverrideBuilder;
use ignore::WalkBuilder;
use rayon::prelude::*;
use std::path::PathBuf;



// NEW: An enum to represent our output formats for clap
#[derive(Debug, Clone, ValueEnum)]
enum Format {
    Markdown,
    Json,
    Paths,
    Cat,
}

/// A fast, expressive tool to find and dump file contents for LLM context using a query language.
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Cli {
    /// The query string to search for files.
    #[arg(required = true)]
    query: String,

    /// The root directory to start the search from.
    #[arg(short, long, default_value = ".")]
    root: PathBuf,

    /// Output file path. If not provided, output is written to stdout.
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Add line numbers to the output.
    #[arg(short, long)]
    line_numbers: bool,

    /// A shorthand for '--format cat'.
    #[arg(long)]
    no_headers: bool,

    /// The output format for the results.
    #[arg(long, value_enum, default_value_t = Format::Markdown)]
    format: Format,

    // --- NEW FLAGS ---
    /// Do not respect .gitignore and other ignore files.
    #[arg(long)]
    no_ignore: bool,

    /// Search hidden files and directories.
    #[arg(long)]
    hidden: bool,

    /// Set the maximum search depth.
    #[arg(long)]
    max_depth: Option<usize>,
}



fn main() -> Result<()> {
    let mut cli = Cli::parse();

    // --- Handle `--no-headers` shorthand ---
    if cli.no_headers {
        cli.format = Format::Cat;
    }

    // --- 1. Find candidates ---
    // MODIFIED: Pass the new flags to the function.
    let candidate_files = get_candidate_files(
        &cli.root,
        cli.no_ignore,
        cli.hidden,
        cli.max_depth,
    )?;

    // --- 2. Parse query ---
    let ast = parser::parse_query(&cli.query)?;

    // --- 3. Evaluate files ---
    let evaluator = Evaluator::new(&ast);
    let mut matching_files: Vec<PathBuf> = candidate_files
        .par_iter()
        .filter_map(|path| match evaluator.evaluate(path) {
            Ok(true) => Some(path.clone()),
            Ok(false) => None,
            Err(e) => {
                eprintln!("Error evaluating file {}: {}", path.display(), e);
                None
            }
        })
        .collect();

    matching_files.sort();

    // --- 4. Format and print results ---
    // This `Box<dyn Write>` lets us decide at runtime whether to write
    // to stdout or a file, without changing the formatter's code.
    let mut writer: Box<dyn Write> = if let Some(output_path) = &cli.output {
        Box::new(File::create(output_path)?)
    } else {
        Box::new(io::stdout())
    };

    formatter::print_output(
        &mut writer,
        &matching_files,
        &cli.format,
        cli.line_numbers,
    )?;

    Ok(())
}

/// Walks the directory, respecting .gitignore, and applies our own smart defaults to return a list of files.
// MODIFIED: The function now takes the flags it needs from the Cli struct.
fn get_candidate_files(
    root: &PathBuf,
    no_ignore: bool,
    hidden: bool,
    max_depth: Option<usize>,
) -> Result<Vec<PathBuf>> {
    let mut files = Vec::new();

    let mut override_builder = OverrideBuilder::new(root);
    // Only apply our smart defaults if ignore files are being used.
    if !no_ignore {
        override_builder.add("!node_modules/")?;
        override_builder.add("!target/")?;
        override_builder.add("!.git/")?;
    }
    let overrides = override_builder.build()?;

    // --- MODIFIED: Configure WalkBuilder with our new flags ---
    let mut walker_builder = WalkBuilder::new(root);
    walker_builder
        .overrides(overrides)
        .ignore(!no_ignore) // The .ignore(bool) method defaults to true. We pass the opposite of our flag.
        .hidden(!hidden)    // The .hidden(bool) method defaults to true (hides files). We pass the opposite.
        .max_depth(max_depth);

    for result in walker_builder.build() {
        let entry = result?;
        if entry.file_type().map_or(false, |ft| ft.is_file()) {
            files.push(entry.into_path());
        }
    }
    Ok(files)
}


// END rdump/src/main.rs

// START rdump/src/parser.rs

use anyhow::{anyhow, Result};
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;

#[derive(Parser)]
#[grammar = "rql.pest"]
pub struct RqlParser;

#[derive(Debug, PartialEq, Eq)]
pub enum PredicateKey {
    Ext,
    Name,
    Path,
    Contains,
    Matches,
    // --- NEW PREDICATES ---
    Size,
    Modified,
    // A key for testing or unknown predicates
    Other(String),
}

impl PredicateKey {
    fn from_str(s: &str) -> Self {
        match s {
            "ext" => Self::Ext,
            "name" => Self::Name,
            "path" => Self::Path,
            "contains" | "c" => Self::Contains,
            "matches" | "m" => Self::Matches,
            // --- NEW PREDICATES ---
            "size" => Self::Size,
            "modified" => Self::Modified,
            // Any other key is captured here.
            other => Self::Other(other.to_string()),
        }
    }
}

#[derive(Debug)]
pub enum AstNode {
    And(Box<AstNode>, Box<AstNode>),
    Or(Box<AstNode>, Box<AstNode>),
    Not(Box<AstNode>),
    Predicate { key: PredicateKey, value: String },
}

pub fn parse_query(query: &str) -> Result<AstNode> {
    // Check for empty or whitespace-only queries BEFORE parsing.
    if query.trim().is_empty() {
        return Err(anyhow!("Empty query"));
    }

    // Map the pest error to a cleaner message if parsing fails.
    let mut pairs = RqlParser::parse(Rule::query, query)
        .map_err(|e| anyhow!("Syntax error in query: {}", e))?;

    let top_level_pair = pairs.next().unwrap(); // Should not fail after the check above
    build_ast_from_pair(top_level_pair)
}

fn build_ast_from_pair(pair: Pair<Rule>) -> Result<AstNode> {
    match pair.as_rule() {
        Rule::query | Rule::expression => build_ast_from_pair(pair.into_inner().next().unwrap()),
        Rule::logical_or => {
            let mut inner = pair.into_inner();
            let mut ast = build_ast_from_pair(inner.next().unwrap())?;
            while inner.next().is_some() {
                let rhs = build_ast_from_pair(inner.next().unwrap())?;
                ast = AstNode::Or(Box::new(ast), Box::new(rhs));
            }
            Ok(ast)
        }
        Rule::logical_and => {
            let mut inner = pair.into_inner();
            let mut ast = build_ast_from_pair(inner.next().unwrap())?;
            while inner.next().is_some() {
                let rhs = build_ast_from_pair(inner.next().unwrap())?;
                ast = AstNode::And(Box::new(ast), Box::new(rhs));
            }
            Ok(ast)
        }
        Rule::factor => {
            let mut inner = pair.into_inner();
            let first_node = inner.next().unwrap();
            if first_node.as_rule() == Rule::NOT {
                let expr = build_ast_from_pair(inner.next().unwrap())?;
                Ok(AstNode::Not(Box::new(expr)))
            } else {
                build_ast_from_pair(first_node)
            }
        }
        Rule::predicate => {
            let mut inner = pair.into_inner();
            let key_str = inner.next().unwrap().as_str();
            let key = PredicateKey::from_str(key_str);

            let value_pair = inner.next().unwrap();
            let inner_value_pair = value_pair.into_inner().next().unwrap();
            let final_value = match inner_value_pair.as_rule() {
                Rule::unquoted_value => inner_value_pair.as_str().to_string(),
                Rule::quoted_value => {
                    let s = inner_value_pair.as_str();
                    s[1..s.len() - 1].to_string()
                }
                _ => unreachable!(),
            };
            Ok(AstNode::Predicate {
                key,
                value: final_value,
            })
        }
        _ => unreachable!(
            "build_ast_from_pair called on unexpected rule: {:?}",
            pair.as_rule()
        ),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    impl PartialEq for AstNode {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (AstNode::And(l1, r1), AstNode::And(l2, r2)) => l1 == l2 && r1 == r2,
                (AstNode::Or(l1, r1), AstNode::Or(l2, r2)) => l1 == l2 && r1 == r2,
                (AstNode::Not(n1), AstNode::Not(n2)) => n1 == n2,
                (
                    AstNode::Predicate { key: k1, value: v1 },
                    AstNode::Predicate { key: k2, value: v2 },
                ) => k1 == k2 && v1 == v2,
                _ => false,
            }
        }
    }

    fn predicate(key: PredicateKey, value: &str) -> Box<AstNode> {
        Box::new(AstNode::Predicate {
            key,
            value: value.to_string(),
        })
    }

    #[test]
    fn test_parse_simple_predicate() {
        let ast = parse_query("ext:rs").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Ext, "rs"));
    }

    #[test]
    fn test_predicate_with_quoted_value() {
        let ast = parse_query("contains:'fn main'").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Contains, "fn main"));
    }

    #[test]
    fn test_predicate_alias() {
        let ast = parse_query("c:\"some value\"").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Contains, "some value"));
    }

    #[test]
    fn test_unknown_predicate_key() {
        let ast = parse_query("extension:rs").unwrap();
        assert_eq!(
            ast,
            *predicate(PredicateKey::Other("extension".to_string()), "rs")
        );
    }

    #[test]
    fn test_parse_and_operator() {
        let ast = parse_query("ext:rs & contains:'fn'").unwrap();
        let expected = AstNode::And(
            predicate(PredicateKey::Ext, "rs"),
            predicate(PredicateKey::Contains, "fn"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_parse_or_operator() {
        let ast = parse_query("ext:rs | ext:toml").unwrap();
        let expected = AstNode::Or(
            predicate(PredicateKey::Ext, "rs"),
            predicate(PredicateKey::Ext, "toml"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_parse_not_operator() {
        let ast = parse_query("!ext:md").unwrap();
        let expected = AstNode::Not(predicate(PredicateKey::Ext, "md"));
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_parse_precedence() {
        let ast = parse_query("ext:rs & name:main | ext:toml").unwrap();
        let expected = AstNode::Or(
            Box::new(AstNode::And(
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Name, "main"),
            )),
            predicate(PredicateKey::Ext, "toml"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_parse_parentheses() {
        let ast = parse_query("ext:rs & (name:main | ext:toml)").unwrap();
        let expected = AstNode::And(
            predicate(PredicateKey::Ext, "rs"),
            Box::new(AstNode::Or(
                predicate(PredicateKey::Name, "main"),
                predicate(PredicateKey::Ext, "toml"),
            )),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_parse_complex_nested_query() {
        let ast = parse_query("!(ext:rs | path:tests) & (contains:'foo' | c:'bar')").unwrap();
        let expected = AstNode::And(
            Box::new(AstNode::Not(Box::new(AstNode::Or(
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Path, "tests"),
            )))),
            Box::new(AstNode::Or(
                predicate(PredicateKey::Contains, "foo"),
                predicate(PredicateKey::Contains, "bar"),
            )),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_whitespace_insensitivity() {
        let ast = parse_query("  ext:rs   &   (  path:src   )  ").unwrap();
        let expected = AstNode::And(
            predicate(PredicateKey::Ext, "rs"),
            predicate(PredicateKey::Path, "src"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_no_whitespace() {
        let ast = parse_query("ext:rs&path:src").unwrap();
        let expected = AstNode::And(
            predicate(PredicateKey::Ext, "rs"),
            predicate(PredicateKey::Path, "src"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_deeply_nested_precedence() {
        let ast = parse_query("a:1 | b:2 & c:3 | d:4 & e:5").unwrap();
        let expected = AstNode::Or(
            Box::new(AstNode::Or(
                predicate(PredicateKey::Other("a".to_string()), "1"),
                Box::new(AstNode::And(
                    predicate(PredicateKey::Other("b".to_string()), "2"),
                    // THIS IS THE CORRECTED LINE:
                    predicate(PredicateKey::Contains, "3"),
                )),
            )),
            Box::new(AstNode::And(
                predicate(PredicateKey::Other("d".to_string()), "4"),
                predicate(PredicateKey::Other("e".to_string()), "5"),
            )),
        );
        assert_eq!(ast, expected);
    }

    // --- SYNTAX ERROR TESTS ---

    #[test]
    fn test_error_on_trailing_operator() {
        let result = parse_query("ext:rs &");
        assert!(result.is_err());
    }

    #[test]
    fn test_error_on_missing_value() {
        let result = parse_query("ext:");
        assert!(result.is_err());
    }

    #[test]
    fn test_error_on_unclosed_parenthesis() {
        let result = parse_query("(ext:rs | path:src");
        assert!(result.is_err());
    }

    #[test]
    fn test_error_on_empty_query() {
        let result = parse_query("");
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().to_string(), "Empty query");
    }

    #[test]
    fn test_error_on_whitespace_query() {
        let result = parse_query("   ");
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().to_string(), "Empty query");
    }

    #[test]
    fn test_not_precedence_with_and() {
        // `!` should have higher precedence than `&`.
        // Should parse as: (!ext:rs) & path:src
        let ast = parse_query("!ext:rs & path:src").unwrap();
        let expected = AstNode::And(
            Box::new(AstNode::Not(predicate(PredicateKey::Ext, "rs"))),
            predicate(PredicateKey::Path, "src"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_not_with_parentheses() {
        // `!` should apply to the entire parenthesized group.
        let ast = parse_query("!(ext:rs | path:src)").unwrap();
        let expected = AstNode::Not(Box::new(AstNode::Or(
            predicate(PredicateKey::Ext, "rs"),
            predicate(PredicateKey::Path, "src"),
        )));
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_long_or_chain_is_left_associative() {
        // Should parse as: ((a | b) | c) | d
        let ast = parse_query("ext:a | ext:b | ext:c | ext:d").unwrap();
        let expected = AstNode::Or(
            Box::new(AstNode::Or(
                Box::new(AstNode::Or(
                    predicate(PredicateKey::Ext, "a"),
                    predicate(PredicateKey::Ext, "b"),
                )),
                predicate(PredicateKey::Ext, "c"),
            )),
            predicate(PredicateKey::Ext, "d"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_long_and_chain_is_left_associative() {
        // Should parse as: ((a & b) & c) & d
        let ast = parse_query("ext:a & ext:b & ext:c & ext:d").unwrap();
        let expected = AstNode::And(
            Box::new(AstNode::And(
                Box::new(AstNode::And(
                    predicate(PredicateKey::Ext, "a"),
                    predicate(PredicateKey::Ext, "b"),
                )),
                predicate(PredicateKey::Ext, "c"),
            )),
            predicate(PredicateKey::Ext, "d"),
        );
        assert_eq!(ast, expected);
    }

    #[test]
    fn test_redundant_parentheses() {
        let ast = parse_query("((ext:rs))").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Ext, "rs"));
    }

    #[test]
    fn test_value_containing_special_char_must_be_quoted() {
        // An unquoted value cannot contain '&'
        let result = parse_query("name:foo&bar");
        assert!(result.is_err());

        // But a quoted one can
        let ast = parse_query("name:'foo&bar'").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Name, "foo&bar"));
    }
}


// END rdump/src/parser.rs

