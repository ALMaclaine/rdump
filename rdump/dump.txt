// START rdump/Cargo.toml

[package]
name = "rdump"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = { version = "4.5.4", features = ["derive"] }
anyhow = "1.0.86"
ignore = "0.4.22"
rayon = "1.10.0"
regex = "1.10.4"
serde = { version = "1.0.203", features = ["derive"] }
serde_json = "1.0.117"
pest = "2.7.10"
pest_derive = "2.7.10"
tempfile = "3.10.1" # Version from dev-dependencies was newer, consolidated here.
glob = "0.3.1"
dirs = "5.0.1"
toml = "0.8.12"
chrono = { version = "0.4", features = ["serde"] }
once_cell = "1.19.0" # Replaced lazy_static
tree-sitter = "0.22.6"
tree-sitter-rust = "0.21.0"
tree-sitter-python = "0.21.0"
tree-sitter-javascript = "0.21.0"
tree-sitter-typescript = "0.21.0"
tree-sitter-go = "0.21.0"
tree-sitter-java = "0.21.0"
syntect = "5.2.0"
atty = "0.2.14"

[dev-dependencies]
assert_cmd = "2.0.14"
predicates = "3.1.0"
tempfile = "3.10.1"


// END rdump/Cargo.toml

// START rdump/src/commands/lang.rs

use crate::predicates::code_aware::profiles::list_language_profiles;
use crate::LangAction;
use anyhow::{anyhow, Result};

pub fn run_lang(action: LangAction) -> Result<()> {
    match action {
        LangAction::List => {
            let profiles = list_language_profiles();
            println!("{:<12} {}", "NAME", "EXTENSIONS");
            println!("──────────────────────────");
            for profile in profiles {
                println!(
                    "{:<12} {}",
                    profile.name,
                    profile.extensions.join(", ")
                );
            }
        }
        LangAction::Describe { language } => {
            let lang_lower = language.to_lowercase();
            let profiles = list_language_profiles();
            let profile = profiles
                .into_iter()
                .find(|p| p.name.to_lowercase() == lang_lower || p.extensions.contains(&lang_lower.as_str()))
                .ok_or_else(|| anyhow!("Language '{}' not supported. Run `rdump lang list` to see available languages.", language))?;

            println!("Predicates for {} ({})", profile.name, profile.extensions.join(", "));

            let metadata_preds = vec!["ext", "name", "path", "size", "modified"];
            let content_preds = vec!["contains", "matches"];

            println!("\nMETADATA");
            println!("  {}", metadata_preds.join(", "));

            println!("\nCONTENT");
            println!("  {}", content_preds.join(", "));

            let semantic_preds: Vec<&str> = profile.queries.keys().map(|k| k.as_ref()).collect();
            if !semantic_preds.is_empty() {
                println!("\nSEMANTIC");
                println!("  {}", semantic_preds.join(", "));
            }
        }
    }
    Ok(())
}


// END rdump/src/commands/lang.rs

// START rdump/src/commands/mod.rs

// This makes the functions inside search.rs and preset.rs available
// to other parts of the program that use the `commands` module.
pub mod preset;
pub mod search;
pub mod lang;


// END rdump/src/commands/mod.rs

// START rdump/src/commands/preset.rs

use crate::config::{self, Config};
use crate::PresetAction;
use anyhow::{anyhow, Result};
use std::fs; // We'll need to make PresetAction public

/// The main entry point for the `preset` command.
pub fn run_preset(action: PresetAction) -> Result<()> {
    match action {
        PresetAction::List => {
            let config = config::load_config()?;
            if config.presets.is_empty() {
                println!("No presets found.");
            } else {
                println!("Available presets:");
                let max_len = config.presets.keys().map(|k| k.len()).max().unwrap_or(0);
                for (name, query) in config.presets {
                    println!("  {:<width$} : {}", name, query, width = max_len);
                }
            }
        }
        PresetAction::Add { name, query } => {
            let path = config::global_config_path()
                .ok_or_else(|| anyhow!("Could not determine global config path"))?;

            let mut config = if path.exists() {
                let config_str = fs::read_to_string(&path)?;
                toml::from_str(&config_str)?
            } else {
                Config::default()
            };

            println!("Adding/updating preset '{}'...", name);
            config.presets.insert(name, query);
            config::save_config(&config)?;
        }
        PresetAction::Remove { name } => {
            let path = config::global_config_path()
                .ok_or_else(|| anyhow!("Could not determine global config path"))?;

            if !path.exists() {
                return Err(anyhow!(
                    "Global config file does not exist. No presets to remove."
                ));
            }

            let mut config: Config = toml::from_str(&fs::read_to_string(&path)?)?;

            if config.presets.remove(&name).is_some() {
                println!("Removing preset '{}'...", name);
                config::save_config(&config)?;
            } else {
                return Err(anyhow!("Preset '{}' not found in global config.", name));
            }
        }
    }
    Ok(())
}


// END rdump/src/commands/preset.rs

// START rdump/src/commands/search.rs

use crate::{config, ColorChoice, SearchArgs};
use anyhow::anyhow;
use anyhow::Result;
use atty::Stream;
use ignore::WalkBuilder;
use rayon::prelude::*;
use std::fs::File;
use std::io::{self, Write};
use std::path::PathBuf;
use tempfile::NamedTempFile;
use tree_sitter::Range;

use crate::evaluator::{Evaluator, FileContext, MatchResult};
use crate::formatter;
use crate::parser;
use crate::predicates;

/// The main entry point for the `search` command.
pub fn run_search(mut args: SearchArgs) -> Result<()> {
    // --- Load Config and Build Query ---
    let config = config::load_config()?;
    let mut final_query = args.query.take().unwrap_or_default();

    for preset_name in args.preset.iter().rev() {
        let preset_query = config
            .presets
            .get(preset_name)
            .ok_or_else(|| anyhow!("Preset '{}' not found", preset_name))?;

        if final_query.is_empty() {
            final_query = format!("({})", preset_query);
        } else {
            final_query = format!("({}) & {}", preset_query, final_query);
        }
    }

    if final_query.is_empty() {
        return Err(anyhow!(
            "Empty query. Provide a query string or use a preset."
        ));
    }

    // --- 1. Find initial candidates ---
    let candidate_files =
        get_candidate_files(&args.root, args.no_ignore, args.hidden, args.max_depth)?;

    // --- 2. Parse query ---
    let ast = parser::parse_query(&final_query)?;

    // --- 3. Pre-filtering Pass (Metadata) ---
    // This pass uses a special evaluator with only fast metadata predicates.
    // It quickly reduces the number of files needing full evaluation.
    let metadata_registry = predicates::create_metadata_predicate_registry();
    let pre_filter_evaluator = Evaluator::new(ast.clone(), metadata_registry);

    let pre_filtered_files: Vec<PathBuf> = candidate_files
        .into_iter() // This pass is not parallel, it's fast enough.
        .filter(|path| {
            let mut context = FileContext::new(path.clone());
            match pre_filter_evaluator.evaluate(&mut context) {
                Ok(result) => result.is_match(),
                Err(e) => {
                    eprintln!("Error during pre-filter on {}: {}", path.display(), e);
                    false
                }
            }
        })
        .collect();

    // --- Determine if color should be used ---
    let use_color = match args.color {
        ColorChoice::Always => true,
        ColorChoice::Never => false,
        ColorChoice::Auto => atty::is(Stream::Stdout),
    };

    // --- 4. Main Evaluation Pass (Content + Semantic) ---
    // This pass uses the full evaluator on the smaller, pre-filtered set of files.
    let full_registry = predicates::create_predicate_registry();
    let evaluator = Evaluator::new(ast, full_registry);

    let mut matching_files: Vec<(PathBuf, Vec<Range>)> = pre_filtered_files
        .par_iter()
        .filter_map(|path| {
            let mut context = FileContext::new(path.clone());
            match evaluator.evaluate(&mut context) {
                Ok(MatchResult::Boolean(true)) => Some((path.clone(), Vec::new())),
                Ok(MatchResult::Boolean(false)) => None,
                Ok(MatchResult::Hunks(hunks)) => {
                    if hunks.is_empty() {
                        None
                    } else {
                        Some((path.clone(), hunks))
                    }
                }
                Err(e) => {
                    eprintln!("Error evaluating file {}: {}", path.display(), e);
                    None
                }
            }
        })
        .collect();

    matching_files.sort_by(|a, b| a.0.cmp(&b.0));

    // --- 5. Format and print results ---
    let mut writer: Box<dyn Write> = if let Some(output_path) = &args.output {
        Box::new(File::create(output_path)?)
    } else {
        Box::new(io::stdout())
    };

    formatter::print_output(
        &mut writer,
        &matching_files,
        &args.format,
        args.line_numbers,
        use_color,
        args.context.unwrap_or(0),
    )?;

    Ok(())
}

/// Walks the directory, respecting .gitignore, and applies our own smart defaults.
fn get_candidate_files(
    root: &PathBuf,
    no_ignore: bool,
    hidden: bool,
    max_depth: Option<usize>,
) -> Result<Vec<PathBuf>> {
    let mut files = Vec::new();
    let mut walker_builder = WalkBuilder::new(root);

    walker_builder.hidden(!hidden).max_depth(max_depth);

    if !no_ignore {
        // Layer 1: Our "sane defaults". These have the lowest precedence.
        let default_ignores = "
           # Default rdump ignores
           node_modules/
           target/
           dist/
           build/
           .git/
           .svn/
           .hg/
           *.pyc
           __pycache__/
       ";
        let mut temp_ignore = NamedTempFile::new()?;
        write!(temp_ignore, "{}", default_ignores)?;
        walker_builder.add_ignore(temp_ignore.path());

        // Layer 2: A user's custom global ignore file.
        if let Some(global_ignore_path) = dirs::config_dir().map(|p| p.join("rdump/ignore")) {
            if global_ignore_path.exists() {
                if let Some(err) = walker_builder.add_ignore(global_ignore_path) {
                    eprintln!("Warning: could not add global ignore file: {}", err);
                }
            }
        }

        // Layer 3: A user's custom project-local .rdumpignore file.
        walker_builder.add_custom_ignore_filename(".rdumpignore");

        // Layer 4: Standard .gitignore files.
        walker_builder.git_global(true);
        walker_builder.git_ignore(true);
    } else {
        // If --no-ignore is passed, disable everything.
        walker_builder.ignore(false);
    }

    for result in walker_builder.build() {
        let entry = result?;
        if entry.file_type().map_or(false, |ft| ft.is_file()) {
            files.push(entry.into_path());
        }
    }
    Ok(files)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::io::Write;
    use tempfile::tempdir;

    fn get_sorted_file_names(
        root: &PathBuf,
        no_ignore: bool,
        hidden: bool,
        max_depth: Option<usize>,
    ) -> Vec<String> {
        let mut paths = get_candidate_files(root, no_ignore, hidden, max_depth).unwrap();
        paths.sort();
        paths
            .into_iter()
            .map(|p| {
                p.strip_prefix(root)
                    .unwrap()
                    .to_string_lossy()
                    .replace('\\', "/")
            })
            .collect()
    }

    #[test]
    fn test_custom_rdumpignore_file() {
        let dir = tempdir().unwrap();
        let root = dir.path();
        let mut ignore_file = fs::File::create(root.join(".rdumpignore")).unwrap();
        writeln!(ignore_file, "*.log").unwrap();
        fs::File::create(root.join("app.js")).unwrap();
        fs::File::create(root.join("app.log")).unwrap();

        let files = get_sorted_file_names(&root.to_path_buf(), false, false, None);
        assert_eq!(files, vec!["app.js"]);
    }

    #[test]
    fn test_unignore_via_rdumpignore() {
        let dir = tempdir().unwrap();
        let root = dir.path();

        let node_modules = root.join("node_modules");
        fs::create_dir(&node_modules).unwrap();
        fs::File::create(node_modules.join("some_dep.js")).unwrap();
        fs::File::create(root.join("app.js")).unwrap();

        let mut ignore_file = fs::File::create(root.join(".rdumpignore")).unwrap();
        writeln!(ignore_file, "!node_modules/").unwrap();

        let files = get_sorted_file_names(&root.to_path_buf(), false, false, None);
        assert_eq!(files.len(), 2);
        assert!(files.contains(&"app.js".to_string()));
        assert!(files.contains(
            &"node_modules/some_dep.js"
                .to_string()
                .replace('/', &std::path::MAIN_SEPARATOR.to_string())
        ));
    }
}


// END rdump/src/commands/search.rs

// START rdump/src/config.rs

// rdump/src/config.rs - FINAL CORRECTED VERSION

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Deserialize, Serialize, Debug, Default)]
pub struct Config {
    #[serde(default)]
    pub presets: HashMap<String, String>,
}

/// Returns the path to the global configuration file.
/// It can be overridden by the RDUMP_TEST_CONFIG_DIR environment variable for testing.
pub fn global_config_path() -> Option<PathBuf> {
    // First, check for the override environment variable. This is active in ALL builds.
    if let Ok(path_str) = env::var("RDUMP_TEST_CONFIG_DIR") {
        return Some(PathBuf::from(path_str).join("rdump/config.toml"));
    }

    // If the override is not set, fall back to the default platform-specific directory.
    dirs::config_dir().map(|p| p.join("rdump/config.toml"))
}

/// Searches for a local `.rdump.toml` in the given directory and its parents.
fn find_local_config(start_dir: &Path) -> Option<PathBuf> {
    for ancestor in start_dir.ancestors() {
        let config_path = ancestor.join(".rdump.toml");
        if config_path.exists() {
            return Some(config_path);
        }
    }
    None
}

/// Finds and loads the configuration, merging global and local files.
pub fn load_config() -> Result<Config> {
    let mut final_config = Config::default();

    // 1. Load the global config file, if it exists.
    if let Some(global_config_path) = global_config_path() {
        if global_config_path.exists() {
            let global_config_str = fs::read_to_string(&global_config_path).with_context(|| {
                format!("Failed to read global config at {:?}", global_config_path)
            })?;
            let global_config: Config = toml::from_str(&global_config_str)?;
            final_config.presets.extend(global_config.presets);
        }
    }

    // 2. Find and load the local config file, if it exists.
    let current_dir = env::current_dir()?;
    if let Some(local_config_path) = find_local_config(&current_dir) {
        if local_config_path.exists() {
            let local_config_str = fs::read_to_string(&local_config_path).with_context(|| {
                format!("Failed to read local config at {:?}", local_config_path)
            })?;
            let local_config: Config = toml::from_str(&local_config_str)?;
            final_config.presets.extend(local_config.presets);
        }
    }

    Ok(final_config)
}

/// Saves the given config to the global configuration file.
pub fn save_config(config: &Config) -> Result<()> {
    let path = global_config_path()
        .ok_or_else(|| anyhow::anyhow!("Could not determine global config path"))?;

    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create config directory at {:?}", parent))?;
    }

    let toml_string = toml::to_string_pretty(config)?;
    fs::write(&path, toml_string)
        .with_context(|| format!("Failed to write global config to {:?}", path))?;

    println!("Successfully saved config to {:?}", path);
    Ok(())
}

// The unit tests for config.rs remain the same and will still pass.
#[cfg(test)]
mod tests {
    use super::*;
    use once_cell::sync::Lazy;
    use std::io::Write;
    use std::sync::Mutex;
    use tempfile::tempdir;

    static ENV_MUTEX: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));

    #[test]
    fn test_find_local_config_in_parent() {
        let _lock = ENV_MUTEX.lock().unwrap();
        let root = tempdir().unwrap();
        let sub = root.path().join("sub");
        fs::create_dir(&sub).unwrap();

        let config_path = root.path().join(".rdump.toml");
        fs::File::create(&config_path).unwrap();

        let found_path = find_local_config(&sub).unwrap();
        assert_eq!(found_path, config_path);
    }

    #[test]
    fn test_find_local_config_not_found() {
        let _lock = ENV_MUTEX.lock().unwrap();
        let root = tempdir().unwrap();
        assert!(find_local_config(root.path()).is_none());
    }

    #[test]
    fn test_load_config_merging_and_overriding() {
        let _lock = ENV_MUTEX.lock().unwrap();
        let test_dir = tempdir().unwrap();

        let fake_home_dir = test_dir.path().join("home");
        let global_config_dir = fake_home_dir.join("rdump");
        fs::create_dir_all(&global_config_dir).unwrap();
        let global_config_path = global_config_dir.join("config.toml");
        let mut global_file = fs::File::create(&global_config_path).unwrap();
        writeln!(
            global_file,
            r#"
            [presets]
            rust = "ext:rs"
            docs = "ext:md"
        "#
        )
        .unwrap();

        let project_dir = test_dir.path().join("project");
        fs::create_dir(&project_dir).unwrap();
        let local_config_path = project_dir.join(".rdump.toml");
        let mut local_file = fs::File::create(&local_config_path).unwrap();
        writeln!(
            local_file,
            r#"
            [presets]
            docs = "ext:md | ext:txt"
            scripts = "ext:sh"
        "#
        )
        .unwrap();

        env::set_var("RDUMP_TEST_CONFIG_DIR", fake_home_dir.to_str().unwrap());
        let original_dir = env::current_dir().unwrap();
        env::set_current_dir(&project_dir).unwrap();
        let config = load_config().unwrap();
        env::set_current_dir(&original_dir).unwrap();

        assert_eq!(config.presets.len(), 3);
        assert_eq!(config.presets.get("rust").unwrap(), "ext:rs");
        assert_eq!(config.presets.get("scripts").unwrap(), "ext:sh");
        assert_eq!(
            config.presets.get("docs").unwrap(),
            "ext:md | ext:txt"
        );

        env::remove_var("RDUMP_TEST_CONFIG_DIR");
    }
}

// END rdump/src/config.rs

// START rdump/src/evaluator.rs

use anyhow::{anyhow, Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use tree_sitter::{Parser as TreeSitterParser, Range, Tree};

use crate::parser::{AstNode, PredicateKey};
use crate::predicates::PredicateEvaluator;

/// The result of an evaluation for a single file.
#[derive(Debug, Clone)]
pub enum MatchResult {
    // For simple, non-hunkable predicates like `ext:rs` or `size:>10kb`
    Boolean(bool),
    // For code-aware predicates that can identify specific code blocks.
    Hunks(Vec<Range>),
}

/// Holds the context for a single file being evaluated.
/// It lazily loads content and caches the tree-sitter AST.
pub struct FileContext {
    pub path: PathBuf,
    content: Option<String>,
    // Cache for the parsed tree-sitter AST
    tree: Option<Tree>,
}

impl FileContext {
    pub fn new(path: PathBuf) -> Self {
        FileContext {
            path,
            content: None,
            tree: None,
        }
    }

    pub fn get_content(&mut self) -> Result<&str> {
        if self.content.is_none() {
            let content = fs::read_to_string(&self.path)
                .with_context(|| format!("Failed to read file {}", self.path.display()))?;
            self.content = Some(content);
        }
        Ok(self.content.as_ref().unwrap())
    }

    // Lazily parses the file with tree-sitter and caches the result.
    pub fn get_tree(&mut self, language: tree_sitter::Language) -> Result<&Tree> {
        if self.tree.is_none() {
            let path_display = self.path.display().to_string();
            let content = self.get_content()?;
            let mut parser = TreeSitterParser::new();
            parser.set_language(&language).with_context(|| {
                format!(
                    "Failed to set language for tree-sitter parser on {}",
                    path_display
                )
            })?;
            let tree = parser
                .parse(content, None)
                .ok_or_else(|| anyhow!("Tree-sitter failed to parse {}", path_display))?;
            self.tree = Some(tree);
        }
        Ok(self.tree.as_ref().unwrap())
    }
}

/// The main evaluator struct. It holds the AST and the predicate registry.
pub struct Evaluator {
    ast: AstNode,
    registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>>,
}

impl Evaluator {
    pub fn new(
        ast: AstNode,
        registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>>,
    ) -> Self {
        Evaluator { ast, registry }
    }

    /// Evaluates the query for a given file path.
    pub fn evaluate(&self, context: &mut FileContext) -> Result<MatchResult> {
        self.evaluate_node(&self.ast, context)
    }

    /// Recursively evaluates an AST node.
    fn evaluate_node(&self, node: &AstNode, context: &mut FileContext) -> Result<MatchResult> {
        match node {
            AstNode::Predicate(key, value) => self.evaluate_predicate(key, value, context),
            AstNode::LogicalOp(op, left, right) => {
                match op {
                    crate::parser::LogicalOperator::And => {
                        let left_res = self.evaluate_node(left, context)?;
                        if !left_res.is_match() {
                            return Ok(MatchResult::Boolean(false));
                        }
                        let right_res = self.evaluate_node(right, context)?;
                        if !right_res.is_match() {
                            return Ok(MatchResult::Boolean(false));
                        }
                        Ok(left_res.combine_with(right_res))
                    }
                    crate::parser::LogicalOperator::Or => {
                        let left_res = self.evaluate_node(left, context)?;
                        // Short-circuit if we have a non-hunkable, definitive match.
                        // This prevents expensive evaluation of the right side.
                        if let MatchResult::Boolean(true) = left_res {
                            return Ok(left_res);
                        }

                        let right_res = self.evaluate_node(right, context)?;

                        // Combine the results logically.
                        if left_res.is_match() && right_res.is_match() {
                            Ok(left_res.combine_with(right_res))
                        } else if left_res.is_match() {
                            Ok(left_res) // right side didn't match
                        } else {
                            Ok(right_res) // left side didn't match, so result is right
                        }
                    }
                }
            }
            AstNode::Not(inner_node) => {
                // For the pre-filtering pass, if the inner predicate of a NOT is not in the
                // registry, we cannot definitively say the file *doesn't* match.
                // For example, for `!contains:foo`, the pre-filter doesn't know the content.
                // So, we must assume it *could* match and let the full evaluator decide.
                if let AstNode::Predicate(key, _) = &**inner_node {
                    if !self.registry.contains_key(key) {
                        return Ok(MatchResult::Boolean(true)); // Pass to the next stage
                    }
                }
                // Otherwise, evaluate the inner node and negate the result.
                let result = self.evaluate_node(inner_node, context)?;
                Ok(MatchResult::Boolean(!result.is_match()))
            }
        }
    }

    /// Evaluates a single predicate.
    fn evaluate_predicate(
        &self,
        key: &PredicateKey,
        value: &str,
        context: &mut FileContext,
    ) -> Result<MatchResult> {
        if let Some(evaluator) = self.registry.get(key) {
            evaluator.evaluate(context, key, value)
        } else {
            // If a predicate is not in the current registry (e.g., a content predicate
            // during the metadata-only pass), it's considered a "pass" for this stage.
            // The full evaluator in the next stage will make the final decision.
            Ok(MatchResult::Boolean(true))
        }
    }
}

impl MatchResult {
    /// Returns true if the result is considered a match.
    pub fn is_match(&self) -> bool {
        match self {
            MatchResult::Boolean(b) => *b,
            MatchResult::Hunks(h) => !h.is_empty(),
        }
    }

    /// Combines two successful match results.
    pub fn combine_with(self, other: MatchResult) -> Self {
        match (self, other) {
            (MatchResult::Hunks(mut a), MatchResult::Hunks(b)) => {
                a.extend(b);
                a.sort_by_key(|r| r.start_byte);
                a.dedup();
                MatchResult::Hunks(a)
            }
            (MatchResult::Hunks(a), MatchResult::Boolean(_)) => MatchResult::Hunks(a),
            (MatchResult::Boolean(_), MatchResult::Hunks(b)) => MatchResult::Hunks(b),
            (MatchResult::Boolean(_), MatchResult::Boolean(_)) => MatchResult::Boolean(true),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_query;
    use crate::predicates;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_file(content: &str) -> NamedTempFile {
        let file = NamedTempFile::new().unwrap();
        write!(file.as_file(), "{}", content).unwrap();
        file
    }

    #[test]
    fn test_evaluate_simple_predicate() {
        let file = create_temp_file("hello world");
        let mut context = FileContext::new(file.path().to_path_buf());
        let ast = parse_query("contains:world").unwrap();
        let evaluator = Evaluator::new(ast, predicates::create_predicate_registry());
        assert!(evaluator.evaluate(&mut context).unwrap().is_match());
    }

    #[test]
    fn test_evaluate_logical_and() {
        let file = create_temp_file("hello world");
        let mut context = FileContext::new(file.path().to_path_buf());
        let ast = parse_query("contains:hello & contains:world").unwrap();
        let evaluator = Evaluator::new(ast, predicates::create_predicate_registry());
        assert!(evaluator.evaluate(&mut context).unwrap().is_match());

        let ast_fail = parse_query("contains:hello & contains:goodbye").unwrap();
        let evaluator_fail = Evaluator::new(ast_fail, predicates::create_predicate_registry());
        assert!(!evaluator_fail
            .evaluate(&mut context)
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_evaluate_logical_or() {
        let file = create_temp_file("hello world");
        let mut context = FileContext::new(file.path().to_path_buf());
        let ast = parse_query("contains:hello | contains:goodbye").unwrap();
        let evaluator = Evaluator::new(ast, predicates::create_predicate_registry());
        assert!(evaluator.evaluate(&mut context).unwrap().is_match());

        let ast_fail = parse_query("contains:goodbye | contains:farewell").unwrap();
        let evaluator_fail = Evaluator::new(ast_fail, predicates::create_predicate_registry());
        assert!(!evaluator_fail
            .evaluate(&mut context)
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_evaluate_negation() {
        let file = create_temp_file("hello world");
        let mut context = FileContext::new(file.path().to_path_buf());
        let ast = parse_query("!contains:goodbye").unwrap();
        let evaluator = Evaluator::new(ast, predicates::create_predicate_registry());
        assert!(evaluator.evaluate(&mut context).unwrap().is_match());

        let ast_fail = parse_query("!contains:hello").unwrap();
        let evaluator_fail = Evaluator::new(ast_fail, predicates::create_predicate_registry());
        assert!(!evaluator_fail
            .evaluate(&mut context)
            .unwrap()
            .is_match());
    }
}


// END rdump/src/evaluator.rs

// START rdump/src/formatter.rs

use anyhow::{Context, Result};
use chrono::{DateTime, Local}; // For formatting timestamps
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use std::fs;
use std::io::Write;
use std::ops::Range as StdRange;
#[cfg(unix)]
use std::os::unix::fs::PermissionsExt; // For Unix permissions
use std::path::PathBuf;
use syntect::easy::HighlightLines;
use syntect::highlighting::{Style, ThemeSet};
use syntect::parsing::SyntaxSet;
use syntect::util::{as_24_bit_terminal_escaped, LinesWithEndings};
use tree_sitter::Range;

// We need to pass the format enum from main.rs
use crate::Format;

// Lazily load syntax and theme sets once.
static SYNTAX_SET: Lazy<SyntaxSet> = Lazy::new(SyntaxSet::load_defaults_newlines);
static THEME_SET: Lazy<ThemeSet> = Lazy::new(ThemeSet::load_defaults);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
struct FileOutput {
    path: String,
    content: String,
}

/// Formats and prints the final output to a generic writer based on the chosen format.
pub fn print_output(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
    format: &Format,
    with_line_numbers: bool,
    use_color: bool,
    context_lines: usize,
) -> Result<()> {
    match format {
        Format::Find => {
            for (path, _) in matching_files {
                let metadata = fs::metadata(path)
                    .with_context(|| format!("Failed to read metadata for {}", path.display()))?;
                let size = metadata.len();
                let modified: DateTime<Local> = DateTime::from(metadata.modified()?);

                // Get permissions (basic implementation)
                let perms = metadata.permissions();
                #[cfg(unix)]
                let mode = perms.mode();
                #[cfg(not(unix))]
                let mode = 0; // Placeholder for non-unix
                let perms_str = format_mode(mode);

                // Format size into human-readable string
                let size_str = format_size(size);

                // Format time
                let time_str = modified.format("%b %d %H:%M").to_string();

                writeln!(
                    writer,
                    "{:<12} {:>8} {} {}",
                    perms_str,
                    size_str,
                    time_str,
                    path.display()
                )?;
            }
        }
        Format::Paths => {
            for (path, _) in matching_files {
                writeln!(writer, "{}", path.display())?;
            }
        }
        Format::Json => {
            let mut outputs = Vec::new();
            for (path, _) in matching_files {
                let content = fs::read_to_string(path).with_context(|| {
                    format!("Failed to read file for final output: {}", path.display())
                })?;
                outputs.push(FileOutput {
                    path: path.to_string_lossy().to_string(),
                    content,
                });
            }
            // Use to_writer_pretty for readable JSON output
            serde_json::to_writer_pretty(writer, &outputs)?;
        }
        Format::Cat => {
            for (path, _) in matching_files {
                let content = fs::read_to_string(path)?;
                if use_color {
                    // To terminal
                    print_highlighted_content(
                        writer,
                        &content,
                        &path.extension().and_then(|s| s.to_str()).unwrap_or(""),
                        with_line_numbers,
                    )?;
                } else {
                    print_plain_content(writer, &content, with_line_numbers)?; // To file/pipe
                }
            }
        }
        Format::Markdown => {
            for (i, (path, _)) in matching_files.iter().enumerate() {
                if i > 0 {
                    writeln!(writer, "\n---\n")?;
                }
                writeln!(writer, "File: {}", path.display())?;
                writeln!(writer, "---")?;
                let content = fs::read_to_string(path)?;
                let extension = path.extension().and_then(|s| s.to_str()).unwrap_or("");

                if use_color {
                    // To terminal: use ANSI codes for color
                    print_highlighted_content(writer, &content, extension, with_line_numbers)?;
                } else {
                    // To file/pipe: use Markdown fences for color
                    print_markdown_fenced_content(writer, &content, extension, with_line_numbers)?;
                }
            }
        }
        Format::Hunks => {
            for (i, (path, hunks)) in matching_files.iter().enumerate() {
                if i > 0 {
                    writeln!(writer, "\n---\n")?;
                }
                writeln!(writer, "File: {}", path.display())?;
                writeln!(writer, "---")?;
                let content = fs::read_to_string(path)?;
                let extension = path.extension().and_then(|s| s.to_str()).unwrap_or("");

                if hunks.is_empty() {
                    // Boolean match, print the whole file
                    print_content_with_style(writer, &content, extension, with_line_numbers, use_color)?;
                } else {
                    // Hunk match, print with context
                    let lines: Vec<&str> = content.lines().collect();
                    let line_ranges = get_contextual_line_ranges(hunks, &lines, context_lines);

                    for (i, range) in line_ranges.iter().enumerate() {
                        if i > 0 {
                            writeln!(writer, "...")?;
                        }
                        let hunk_content = lines[range.clone()].join("\n");
                        print_content_with_style(writer, &hunk_content, extension, with_line_numbers, use_color)?;
                    }
                }
            }
        }
    }
    Ok(())
}


/// Helper to choose the correct printing function based on color/style preference.
fn print_content_with_style(
    writer: &mut impl Write,
    content: &str,
    extension: &str,
    with_line_numbers: bool,
    use_color: bool,
) -> Result<()> {
    if use_color {
        print_highlighted_content(writer, content, extension, with_line_numbers)
    } else {
        print_markdown_fenced_content(writer, content, extension, with_line_numbers)
    }
}

/// Given a set of byte-offset ranges, calculate the line number ranges including context,
/// and merge any overlapping ranges.
fn get_contextual_line_ranges(
    hunks: &[Range],
    lines: &[&str],
    context_lines: usize,
) -> Vec<StdRange<usize>> {
    if hunks.is_empty() || lines.is_empty() {
        return vec![];
    }

    let mut line_ranges = Vec::new();
    for hunk in hunks {
        let start_line = hunk.start_point.row;
        let end_line = hunk.end_point.row;

        let context_start = start_line.saturating_sub(context_lines);
        let context_end = (end_line + context_lines).min(lines.len() - 1);

        if context_end >= context_start {
            line_ranges.push(context_start..context_end + 1);
        }
    }
    line_ranges.sort_by_key(|r| r.start);

    // Merge overlapping ranges
    let mut merged_ranges = Vec::new();
    let mut iter = line_ranges.into_iter();
    if let Some(mut current) = iter.next() {
        for next in iter {
            if next.start <= current.end {
                current.end = current.end.max(next.end);
            } else {
                merged_ranges.push(current);
                current = next;
            }
        }
        merged_ranges.push(current);
    }
    merged_ranges
}


/// Prints syntax-highlighted content to the writer.
fn print_highlighted_content(
    writer: &mut impl Write,
    content: &str,
    extension: &str,
    with_line_numbers: bool,
) -> Result<()> {
    let syntax = SYNTAX_SET
        .find_syntax_by_extension(extension)
        .unwrap_or_else(|| SYNTAX_SET.find_syntax_plain_text());

    let theme = &THEME_SET.themes["base16-ocean.dark"];
    let mut highlighter = HighlightLines::new(syntax, theme);

    for (i, line) in LinesWithEndings::from(content).enumerate() {
        if with_line_numbers {
            write!(writer, "{: >5} | ", i + 1)?;
        }
        let ranges: Vec<(Style, &str)> = highlighter.highlight_line(line, &SYNTAX_SET)?;
        let escaped = as_24_bit_terminal_escaped(&ranges[..], false);
        write!(writer, "{}", escaped)?;
    }
    // Reset color at the end
    write!(writer, "\x1b[0m")?;
    Ok(())
}

/// Prints plain content, optionally with line numbers.
fn print_plain_content(
    writer: &mut impl Write,
    content: &str,
    with_line_numbers: bool,
) -> Result<()> {
    for (i, line) in content.lines().enumerate() {
        if with_line_numbers {
            writeln!(writer, "{: >5} | {}", i + 1, line)?;
        } else {
            writeln!(writer, "{}", line)?;
        }
    }
    Ok(())
}

/// Prints content inside a Markdown code fence.
fn print_markdown_fenced_content(
    writer: &mut impl Write,
    content: &str,
    extension: &str,
    with_line_numbers: bool,
) -> Result<()> {
    writeln!(writer, "```{}", extension)?;
    // print_plain_content handles line numbers correctly
    print_plain_content(writer, content, with_line_numbers)?;
    writeln!(writer, "```")?;
    Ok(())
}

fn format_mode(mode: u32) -> String {
    #[cfg(unix)]
    {
        let user_r = if mode & 0o400 != 0 { 'r' } else { '-' };
        let user_w = if mode & 0o200 != 0 { 'w' } else { '-' };
        let user_x = if mode & 0o100 != 0 { 'x' } else { '-' };
        let group_r = if mode & 0o040 != 0 { 'r' } else { '-' };
        let group_w = if mode & 0o020 != 0 { 'w' } else { '-' };
        let group_x = if mode & 0o010 != 0 { 'x' } else { '-' };
        let other_r = if mode & 0o004 != 0 { 'r' } else { '-' };
        let other_w = if mode & 0o002 != 0 { 'w' } else { '-' };
        let other_x = if mode & 0o001 != 0 { 'x' } else { '-' };
        format!(
            "-{}{}{}{}{}{}{}{}{}",
            user_r, user_w, user_x, group_r, group_w, group_x, other_r, other_w, other_x
        )
    }
    #[cfg(not(unix))]
    {
        // Basic fallback for non-Unix platforms
        if mode & 0o200 != 0 {
            "-rw-------"
        } else {
            "-r--------"
        }
        .to_string()
    }
}

fn format_size(bytes: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    if bytes >= GB {
        format!("{:.1}G", bytes as f64 / GB as f64)
    } else if bytes >= MB {
        format!("{:.1}M", bytes as f64 / MB as f64)
    } else if bytes >= KB {
        format!("{:.1}K", bytes as f64 / KB as f64)
    } else {
        format!("{}B", bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    // Helper to create a temp file with some content.
    fn create_temp_file_with_content(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(content.as_bytes()).unwrap();
        file
    }

    #[test]
    fn test_format_plain_cat_with_line_numbers() {
        let file = create_temp_file_with_content("a\nb");
        let paths = vec![(file.path().to_path_buf(), vec![])];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Cat, true, false, 0).unwrap();
        let output = String::from_utf8(writer).unwrap();
        assert_eq!(output, "    1 | a\n    2 | b\n");
    }

    #[test]
    fn test_format_paths() {
        let file1 = create_temp_file_with_content("a");
        let file2 = create_temp_file_with_content("b");
        let paths = vec![
            (file1.path().to_path_buf(), vec![]),
            (file2.path().to_path_buf(), vec![]),
        ];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Paths, false, false, 0).unwrap();
        let output = String::from_utf8(writer).unwrap();
        let expected = format!("{}\n{}\n", file1.path().display(), file2.path().display());
        assert_eq!(output, expected);
    }

    #[test]
    fn test_format_markdown_with_fences() {
        let file = create_temp_file_with_content("line 1");
        let paths = vec![(file.path().to_path_buf(), vec![])];
        let mut writer = Vec::new();

        // Test with use_color = false to get markdown fences
        print_output(&mut writer, &paths, &Format::Markdown, false, false, 0).unwrap();

        let output = String::from_utf8(writer).unwrap();

        let expected_header = format!("File: {}\n---\n", file.path().display());
        assert!(output.starts_with(&expected_header));
        // The extension of a tempfile is random, so we check for an empty language hint
        assert!(output.contains("```\nline 1\n```"));
    }

    #[test]
    fn test_format_markdown_with_ansi_color() {
        let file = create_temp_file_with_content("fn main() {}");
        // Give it a .rs extension so syntect can find the grammar
        let rs_path = file.path().with_extension("rs");
        std::fs::rename(file.path(), &rs_path).unwrap();

        let paths = vec![(rs_path, vec![])];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Cat, false, true, 0).unwrap();
        let output = String::from_utf8(writer).unwrap();

        // Check for evidence of ANSI color, not the exact codes which can be brittle.
        assert!(
            output.contains("\x1b["),
            "Should contain ANSI escape codes"
        );
        assert!(!output.contains("```"), "Should not contain markdown fences");
    }
}


// END rdump/src/formatter.rs

// START rdump/src/main.rs

// Declare all our modules
mod commands;
mod config;
mod evaluator;
mod formatter;
mod parser;
mod predicates;

use anyhow::Result;
use clap::{Parser, Subcommand, ValueEnum};
use std::path::PathBuf;

// Bring our command functions into scope
use commands::{lang::run_lang, preset::run_preset, search::run_search};

// These structs and enums define the public API of our CLI.
// They need to be public so the `commands` modules can use them.
#[derive(Parser, Debug)]
#[command(
    version,
    about = "A fast, expressive, code-aware tool to find and dump file contents."
)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand, Debug)]
pub enum Commands {
    /// Search for files using a query (default command).
    #[command(visible_alias = "s")]
    Search(SearchArgs),
    /// List supported languages and their available predicates.
    #[command(visible_alias = "l")]
    Lang(LangArgs),
    /// Manage saved presets.
    #[command(visible_alias = "p")]
    Preset(PresetArgs),
}

#[derive(Debug, Clone, ValueEnum, Default)]
pub enum ColorChoice {
    #[default]
    Auto,
    Always,
    Never,
}

#[derive(Parser, Debug)]
pub struct SearchArgs {
    /// The query string to search for, using rdump Query Language (RQL).
    ///
    /// RQL supports logical operators (&, |, !), parentheses, and key:value predicates.
    /// Values with spaces must be quoted (e.g., contains:'fn main').
    ///
    /// METADATA PREDICATES:
    ///   ext:<str>          - File extension (e.g., "rs", "toml")
    ///   name:<glob>        - File name glob pattern (e.g., "test_*.rs")
    ///   path:<str>         - Substring in the full file path
    ///   size:[>|<]<num>[kb|mb] - File size (e.g., ">10kb")
    ///   modified:[>|<]<num>[h|d|w] - Modified time (e.g., "<2d")
    ///
    /// CONTENT PREDICATES:
    ///   contains:<str>     - Literal string a file contains
    ///   matches:<regex>    - Regular expression a file's content matches
    ///
    #[doc = "CODE-AWARE PREDICATES for supported languages:"]
    ///   def:<str>          - A generic definition (class, struct, enum, etc.)
    ///   func:<str>         - A function or method
    ///   import:<str>       - An import or use statement
    ///   call:<str>         - A function or method call site
    ///
    /// GRANULAR DEFINITIONS:
    ///   class:<str>        - A class definition
    ///   struct:<str>       - A struct definition
    ///   enum:<str>         - An enum definition
    ///   interface:<str>    - An interface definition
    ///   trait:<str>        - A trait definition
    ///   type:<str>         - A type alias
    ///
    /// SYNTACTIC CONTENT:
    ///   comment:<str>      - Text inside a comment (e.g., "TODO", "FIXME")
    ///   str:<str>          - Text inside a string literal
    #[arg(verbatim_doc_comment)]
    pub query: Option<String>,
    #[arg(long, short)]
    pub preset: Vec<String>,
    #[arg(short, long, default_value = ".")]
    pub root: PathBuf,
    #[arg(short, long)]
    pub output: Option<PathBuf>,
    #[arg(short, long)]
    pub line_numbers: bool,
    #[arg(long)]
    pub no_headers: bool,
    #[arg(long, value_enum, default_value_t = Format::Hunks)]
    pub format: Format,
    #[arg(long)]
    pub no_ignore: bool,
    #[arg(long)]
    pub hidden: bool,
    #[arg(long, value_enum, default_value_t = ColorChoice::Auto, help = "When to use syntax highlighting")]
    pub color: ColorChoice,
    #[arg(long)]
    pub max_depth: Option<usize>,
    #[arg(long, short = 'C', value_name = "LINES", help = "Show LINES of context around matches for --format=hunks")]
    pub context: Option<usize>,


    /// List files with metadata instead of dumping content.
    #[arg(long)]
    pub find: bool,
}

#[derive(Parser, Debug)]
pub struct LangArgs {
    #[command(subcommand)]
    pub action: Option<LangAction>,
}

#[derive(Subcommand, Debug, Clone)]
pub enum LangAction {
    /// List all supported languages.
    List,
    /// Describe the predicates available for a specific language.
    Describe { language: String },
}

#[derive(Parser, Debug)]
pub struct PresetArgs {
    #[command(subcommand)]
    pub action: PresetAction,
}

#[derive(Subcommand, Debug, Clone)]
pub enum PresetAction {
    /// List all available presets.
    List,
    /// Add or update a preset in the global config file.
    Add {
        #[arg(required = true)]
        name: String,
        #[arg(required = true)]
        query: String,
    },
    /// Remove a preset from the global config file.
    Remove {
        #[arg(required = true)]
        name: String,
    },
}

#[derive(Debug, Clone, ValueEnum)]
pub enum Format {
    /// Show only the specific code blocks ("hunks") that match a semantic query
    Hunks,
    /// Human-readable markdown with file headers
    Markdown,
    /// Machine-readable JSON
    Json,
    /// A simple list of matching file paths
    Paths,
    /// Raw concatenated file content, for piping
    Cat,
    /// `ls`-like output with file metadata
    Find,
}

/// The main entry point.
/// Its only job is to parse the CLI and delegate to the correct command module.
fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Search(mut args) => {
            // --- Handle Shorthand Flags ---
            if args.no_headers {
                args.format = Format::Cat;
            }
            if args.find {
                args.format = Format::Find;
            }
            run_search(args)
        }
        Commands::Lang(args) => {
            // Default to `list` if no subcommand is given for `lang`
            let action = args.action.unwrap_or(LangAction::List);
            run_lang(action)
        }
        Commands::Preset(args) => run_preset(args.action),
    }
}

// END rdump/src/main.rs

// START rdump/src/parser.rs

use anyhow::{anyhow, Result};
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;

#[derive(Parser)]
#[grammar = "rql.pest"]
pub struct RqlParser;

#[derive(Debug, PartialEq, Eq, Hash, Clone)]
pub enum PredicateKey {
    Ext,
    Name,
    Path,
    Contains,
    Matches,
    Size,
    Modified,
    // --- SEMANTIC PREDICATES ---
    // Generic
    Def,
    Func,
    Import,
    // Granular Definitions
    Class,
    Struct,
    Enum,
    Interface,
    Trait,
    Type,
    // Syntactic Content
    Comment,
    Str,
   // Usage
   Call,
    // A key for testing or unknown predicates
    Other(String),
}

impl AsRef<str> for PredicateKey {
   fn as_ref(&self) -> &str {
       match self {
           PredicateKey::Ext => "ext",
           PredicateKey::Name => "name",
           PredicateKey::Path => "path",
           PredicateKey::Contains => "contains",
           PredicateKey::Matches => "matches",
           PredicateKey::Size => "size",
           PredicateKey::Modified => "modified",
           PredicateKey::Def => "def",
           PredicateKey::Func => "func",
           PredicateKey::Import => "import",
           PredicateKey::Class => "class",
           PredicateKey::Struct => "struct",
           PredicateKey::Enum => "enum",
           PredicateKey::Interface => "interface",
           PredicateKey::Trait => "trait",
           PredicateKey::Type => "type",
           PredicateKey::Comment => "comment",
           PredicateKey::Str => "str",
           PredicateKey::Call => "call",
           PredicateKey::Other(s) => s.as_str(),
       }
   }
}

impl From<&str> for PredicateKey {
    fn from(s: &str) -> Self {
        match s {
            "ext" => Self::Ext,
            "name" => Self::Name,
            "path" => Self::Path,
            "contains" => Self::Contains,
            "matches" => Self::Matches,
            "size" => Self::Size,
            "modified" => Self::Modified,
            // --- SEMANTIC ---
            "def" => Self::Def,
            "func" => Self::Func,
            "import" => Self::Import,
            "class" => Self::Class,
            "struct" => Self::Struct,
            "enum" => Self::Enum,
            "interface" => Self::Interface,
            "trait" => Self::Trait,
            "type" => Self::Type,
            "comment" => Self::Comment,
            "str" => Self::Str,
           "call" => Self::Call,
            // Any other key is captured here.
            other => Self::Other(other.to_string()),
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AstNode {
    Predicate(PredicateKey, String),
    LogicalOp(LogicalOperator, Box<AstNode>, Box<AstNode>),
    Not(Box<AstNode>),
}

#[derive(Debug, PartialEq, Clone)]
pub enum LogicalOperator {
    And,
    Or,
}

pub fn parse_query(query: &str) -> Result<AstNode> {
   // Check for empty or whitespace-only queries BEFORE parsing.
   if query.trim().is_empty() {
       return Err(anyhow!("Query cannot be empty."));
   }

   match RqlParser::parse(Rule::query, query) {
       Ok(pairs) => build_ast_from_pairs(pairs.peek().unwrap()),
       Err(e) => {
           // Re-format the pest error to be more user-friendly.
           Err(anyhow!("Invalid query syntax:\n{}", e))
       }
   }
}

fn build_ast_from_pairs(pair: Pair<Rule>) -> Result<AstNode> {
    match pair.as_rule() {
        Rule::query => build_ast_from_pairs(pair.into_inner().next().unwrap()),
        Rule::expression | Rule::logical_or | Rule::logical_and => build_ast_from_logical_op(pair),
        Rule::term => {
            let mut inner = pair.into_inner();
            let first = inner.next().unwrap();
            if first.as_rule() == Rule::NOT {
                let factor = inner.next().unwrap();
                let ast = build_ast_from_pairs(factor)?;
                Ok(AstNode::Not(Box::new(ast)))
            } else {
                build_ast_from_pairs(first)
            }
        }
        Rule::factor => build_ast_from_pairs(pair.into_inner().next().unwrap()),
        Rule::predicate => {
            let mut predicate_parts = pair.into_inner();
            let key_pair = predicate_parts.next().unwrap();
            let value_pair = predicate_parts.next().unwrap();
            let key = PredicateKey::from(key_pair.as_str());
            let value = unescape_value(value_pair.as_str());
            Ok(AstNode::Predicate(key, value))
        }
        _ => Err(anyhow!("Unknown rule: {:?}", pair.as_rule())),
    }
}

fn build_ast_from_logical_op(pair: Pair<Rule>) -> Result<AstNode> {
    let mut inner_pairs = pair.into_inner();
    let mut ast = build_ast_from_pairs(inner_pairs.next().unwrap())?;

    while let Some(op_pair) = inner_pairs.next() {
        let op = match op_pair.as_str() {
            "&" => LogicalOperator::And,
            "|" => LogicalOperator::Or,
            _ => unreachable!(),
        };
        let right_pair = inner_pairs.next().unwrap();
        let right_ast = build_ast_from_pairs(right_pair)?;
        ast = AstNode::LogicalOp(op, Box::new(ast), Box::new(right_ast));
    }
    Ok(ast)
}

fn unescape_value(value: &str) -> String {
    let quote_char = value.chars().next();
    if quote_char == Some('"') || quote_char == Some('\'') {
        let inner = &value[1..value.len() - 1];
        let mut unescaped = String::with_capacity(inner.len());
        let mut chars = inner.chars();
        while let Some(c) = chars.next() {
            if c == '\\' {
                if let Some(next_c) = chars.next() {
                    unescaped.push(next_c);
                }
            } else {
                unescaped.push(c);
            }
        }
        return unescaped;
    }
    value.to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    // Helper to create a predicate node for cleaner tests.
    fn predicate(key: PredicateKey, value: &str) -> Box<AstNode> {
        Box::new(AstNode::Predicate(key, value.to_string()))
    }

    #[test]
    fn test_parse_simple_predicate() {
        let ast = parse_query("ext:rs").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Ext, "rs"));
    }

    #[test]
    fn test_parse_predicate_with_quoted_value() {
        let ast = parse_query("name:\"foo bar\"").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Name, "foo bar"));
    }

    #[test]
    fn test_parse_logical_and() {
        let ast = parse_query("ext:rs & name:\"foo\"").unwrap();
        assert_eq!(
            ast,
            AstNode::LogicalOp(
                LogicalOperator::And,
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Name, "foo")
            )
        );
    }

    #[test]
    fn test_parse_logical_or() {
        let ast = parse_query("ext:rs | ext:toml").unwrap();
        assert_eq!(
            ast,
            AstNode::LogicalOp(
                LogicalOperator::Or,
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Ext, "toml")
            )
        );
    }

    #[test]
    fn test_parse_negation() {
        let ast = parse_query("!ext:rs").unwrap();
        assert_eq!(ast, AstNode::Not(predicate(PredicateKey::Ext, "rs")));
    }

    #[test]
    fn test_parse_complex_query() {
        let ast = parse_query("ext:rs & (name:\"foo\" | name:\"bar\") & !path:tests").unwrap();
        let inner_or = AstNode::LogicalOp(
            LogicalOperator::Or,
            predicate(PredicateKey::Name, "foo"),
            predicate(PredicateKey::Name, "bar"),
        );
        let and_with_or = AstNode::LogicalOp(
            LogicalOperator::And,
            predicate(PredicateKey::Ext, "rs"),
            Box::new(inner_or),
        );
        let final_ast = AstNode::LogicalOp(
            LogicalOperator::And,
            Box::new(and_with_or),
            Box::new(AstNode::Not(predicate(PredicateKey::Path, "tests"))),
        );
        assert_eq!(ast, final_ast);
    }

    #[test]
    fn test_unescape_value() {
        assert_eq!(unescape_value(r#""hello \"world\"""#), "hello \"world\"");
        assert_eq!(unescape_value(r#"'hello \'world\''"#), "hello 'world'");
        assert_eq!(unescape_value(r#""a \\ b""#), "a \\ b");
        assert_eq!(unescape_value("no_quotes"), "no_quotes");
    }

    #[test]
    fn test_parse_predicate_with_special_chars_in_value() {
        let ast = parse_query(r#"name:"foo&bar""#).unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Name, "foo&bar"));
    }

    #[test]
    fn test_parse_semantic_predicates() {
        let ast_def = parse_query("def:User").unwrap();
        assert_eq!(ast_def, *predicate(PredicateKey::Def, "User"));

        let ast_func = parse_query("func:get_user").unwrap();
        assert_eq!(ast_func, *predicate(PredicateKey::Func, "get_user"));

        let ast_import = parse_query("import:serde").unwrap();
        assert_eq!(ast_import, *predicate(PredicateKey::Import, "serde"));
    }

   #[test]
   fn test_parse_granular_and_syntactic_predicates() {
       assert_eq!(parse_query("class:Foo").unwrap(), *predicate(PredicateKey::Class, "Foo"));
       assert_eq!(parse_query("struct:Bar").unwrap(), *predicate(PredicateKey::Struct, "Bar"));
       assert_eq!(parse_query("comment:TODO").unwrap(), *predicate(PredicateKey::Comment, "TODO"));
       assert_eq!(parse_query("str:'api_key'").unwrap(), *predicate(PredicateKey::Str, "api_key"));
       assert_eq!(parse_query("call:my_func").unwrap(), *predicate(PredicateKey::Call, "my_func"));
   }

   #[test]
   fn test_error_on_trailing_operator() {
       let result = parse_query("ext:rs &");
       let err = result.unwrap_err();
       assert!(err.to_string().contains("Invalid query syntax:"));
       assert!(err.to_string().contains("expected")); // Pest's pointer is still useful
   }

   #[test]
   fn test_error_on_missing_value() {
       let result = parse_query("ext:");
       let err = result.unwrap_err();
       assert!(err.to_string().contains("Invalid query syntax:"));
   }

   #[test]
   fn test_error_on_unclosed_parenthesis() {
       let result = parse_query("(ext:rs | path:src");
       let err = result.unwrap_err();
       assert!(err.to_string().contains("Invalid query syntax:"));
   }

   #[test]
   fn test_error_on_empty_query() {
       let result = parse_query("");
       assert_eq!(result.unwrap_err().to_string(), "Query cannot be empty.");
   }

   #[test]
   fn test_error_on_whitespace_query() {
       let result = parse_query("   ");
       assert_eq!(result.unwrap_err().to_string(), "Query cannot be empty.");
   }
}

// END rdump/src/parser.rs

// START rdump/src/predicates/code_aware/mod.rs

use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use crate::predicates::PredicateEvaluator;
use anyhow::{Context, Result};
use tree_sitter::{Query, QueryCursor};

pub mod profiles;

/// The evaluator that uses tree-sitter to perform code-aware queries.
#[derive(Debug, Clone)]
pub struct CodeAwareEvaluator;

impl PredicateEvaluator for CodeAwareEvaluator {
    fn evaluate(&self, context: &mut FileContext, key: &PredicateKey, value: &str) -> Result<MatchResult> {
        // 1. Determine the language from the file extension.
        let extension = context
            .path
            .extension()
            .and_then(|s| s.to_str())
            .unwrap_or("");
        let binding = profiles::list_language_profiles();
        let profile = match binding.iter().find(|p| p.extensions.contains(&extension)) {
            Some(p) => p,
            None => return Ok(MatchResult::Boolean(false)), // Not a supported language for this predicate.
        };

        // 2. Get the tree-sitter query string for the specific predicate.
        let ts_query_str = match profile.queries.get(key) {
            Some(q) if !q.is_empty() => q,
            _ => return Ok(MatchResult::Boolean(false)), // This predicate is not implemented for this language yet.
        };

        // 3. Get content and lazily get the parsed tree from the file context.
        // We get content first to avoid mutable/immutable borrow issues with context.
        let content = context.get_content()?.to_string(); // Clone to avoid borrow issues
        let tree = context.get_tree(profile.language.clone())?;

        // 4. Compile the tree-sitter query.
        let query = Query::new(&profile.language, ts_query_str)
            .with_context(|| format!("Failed to compile tree-sitter query for key {:?}", key))?;
        let mut cursor = QueryCursor::new();
        let mut ranges = Vec::new();

        // 5. Execute the query and check for a match.
        let captures = cursor.matches(&query, tree.root_node(), content.as_bytes());

        for m in captures {
            for capture in m.captures {
                // We only care about nodes captured with the name `@match`.
                let capture_name = &query.capture_names()[capture.index as usize];
                if *capture_name == "match" {
                    let captured_node = capture.node;
                    let captured_text = captured_node.utf8_text(content.as_bytes())?;

                    // Use the correct matching strategy based on the predicate type.
                   let is_match = match key {
                       // Content-based predicates check for substrings.
                       PredicateKey::Import | PredicateKey::Comment | PredicateKey::Str => {
                           captured_text.contains(value)
                       }
                       // Definition-based predicates require an exact match on the identifier.
                       _ => captured_text == value,
                   };

                    if is_match {
                       ranges.push(captured_node.range());
                    }
                }
            }
        }

        Ok(MatchResult::Hunks(ranges))
    }
}


// END rdump/src/predicates/code_aware/mod.rs

// START rdump/src/predicates/code_aware/profiles/go.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Go language.
pub(super) fn create_go_profile() -> LanguageProfile {
    let language = tree_sitter_go::language();
    let mut queries = HashMap::new();

    let type_query = "(type_declaration (type_spec name: (type_identifier) @match))";
    let func_query = "[ (function_declaration name: (identifier) @match) (method_declaration name: (field_identifier) @match) ]";

    // --- Definitions ---
    let struct_query = "(type_declaration (type_spec name: (type_identifier) @match type: (struct_type)))";
    let interface_query = "(type_declaration (type_spec name: (type_identifier) @match type: (interface_type)))";

    queries.insert(PredicateKey::Def, [type_query, func_query].join("\n"));
    queries.insert(PredicateKey::Struct, struct_query.to_string());
    queries.insert(PredicateKey::Interface, interface_query.to_string());
    queries.insert(PredicateKey::Type, type_query.to_string());

    // --- Functions & Calls ---
    queries.insert(PredicateKey::Func, func_query.to_string());
    queries.insert(PredicateKey::Call, "(call_expression function: [ (identifier) @match (selector_expression field: (field_identifier) @match) ])".to_string());

    // --- Other ---
    queries.insert(PredicateKey::Import, "(import_declaration) @match".to_string());
    queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
    queries.insert(PredicateKey::Str, "[ (interpreted_string_literal) @match (raw_string_literal) @match ]".to_string());

    LanguageProfile {
        name: "Go",
        extensions: vec!["go"],
        language,
        queries,
    }
}

// END rdump/src/predicates/code_aware/profiles/go.rs

// START rdump/src/predicates/code_aware/profiles/java.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Java language.
pub(super) fn create_java_profile() -> LanguageProfile {
    let language = tree_sitter_java::language();
    let mut queries = HashMap::new();

    // --- Definitions ---
    let class_query = "(class_declaration name: (identifier) @match)";
    let interface_query = "(interface_declaration name: (identifier) @match)";
    let enum_query = "(enum_declaration name: (identifier) @match)";

    queries.insert(PredicateKey::Def, format!("[ {} {} {} ]", class_query, interface_query, enum_query));
    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Interface, interface_query.to_string());
    queries.insert(PredicateKey::Enum, enum_query.to_string());

    // --- Functions & Calls ---
    queries.insert(PredicateKey::Func, "[ (method_declaration name: (identifier) @match) (constructor_declaration name: (identifier) @match) ]".to_string());
    queries.insert(PredicateKey::Call, "[ (method_invocation name: (identifier) @match) (object_creation_expression type: (type_identifier) @match) ]".to_string());

    // --- Other ---
    queries.insert(PredicateKey::Import, "(import_declaration) @match".to_string());
    queries.insert(PredicateKey::Comment, "[(line_comment) @match (block_comment) @match]".to_string());
    queries.insert(PredicateKey::Str, "(string_literal) @match".to_string());

    LanguageProfile {
        name: "Java",
        extensions: vec!["java"],
        language,
        queries,
    }
}


// END rdump/src/predicates/code_aware/profiles/java.rs

// START rdump/src/predicates/code_aware/profiles/javascript.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the JavaScript language.
pub(super) fn create_javascript_profile() -> LanguageProfile {
    let language = tree_sitter_javascript::language();
    let mut queries = HashMap::new();

    let class_query = "(class_declaration name: (identifier) @match)";
    let func_query = "[ (function_declaration name: (identifier) @match) (method_definition name: (property_identifier) @match) ]";

    queries.insert(PredicateKey::Def, [class_query, func_query].join("\n"));
    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Func, func_query.to_string());

    queries.insert(
        PredicateKey::Import,
        "(import_statement) @match".to_string(),
    );
   queries.insert(
       PredicateKey::Call,
       "[ (call_expression function: [ (identifier) @match (member_expression property: (property_identifier) @match) ]) (new_expression constructor: (identifier) @match) ]".to_string()
   );

   queries.insert(PredicateKey::Comment, "[(comment) @match (regex) @match]".to_string()); // JS Regexes are basically comments
   queries.insert(PredicateKey::Str, "[(string) @match (template_string) @match]".to_string());

    LanguageProfile {
        name: "JavaScript",
        extensions: vec!["js", "jsx"],
        language,
        queries,
    }
}

// END rdump/src/predicates/code_aware/profiles/javascript.rs

// START rdump/src/predicates/code_aware/profiles/mod.rs

use crate::parser::PredicateKey;
use once_cell::sync::Lazy;
use std::collections::HashMap;

mod go;
mod java;
mod javascript;
mod python;
mod rust;
mod typescript;

/// Defines the tree-sitter queries and metadata for a specific language.
pub struct LanguageProfile {
    pub name: &'static str,
    pub extensions: Vec<&'static str>,
    pub(super) language: tree_sitter::Language,
    pub queries: HashMap<PredicateKey, String>,
}

pub(super) static LANGUAGE_PROFILES: Lazy<HashMap<&'static str, LanguageProfile>> =
    Lazy::new(|| {
        let mut m = HashMap::new();
        m.insert("rs", rust::create_rust_profile());
        m.insert("py", python::create_python_profile());
        m.insert("go", go::create_go_profile());
        m.insert("java", java::create_java_profile());
        m.insert("ts", typescript::create_typescript_profile());
        m.insert("js", javascript::create_javascript_profile());
        m
    });

/// Returns a list of all configured language profiles.
pub fn list_language_profiles() -> Vec<&'static LanguageProfile> {
    LANGUAGE_PROFILES.values().collect()
}


// END rdump/src/predicates/code_aware/profiles/mod.rs

// START rdump/src/predicates/code_aware/profiles/python.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Python language.
pub(super) fn create_python_profile() -> LanguageProfile {
    let language = tree_sitter_python::language();
    let mut queries = HashMap::new();

    let class_query = "(class_definition name: (identifier) @match)";
    let func_query = "(function_definition name: (identifier) @match)";

    queries.insert(PredicateKey::Def, [class_query, func_query].join("\n"));
    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Func, func_query.to_string());

    // Query for `import` and `from ... import` statements.
    queries.insert(
        PredicateKey::Import,
        "
        [
            (import_statement) @match
            (import_from_statement) @match
        ]
        "
        .to_string(),
    );

   // Query for function and method call sites.
   queries.insert(
       PredicateKey::Call,
       "
       (call
           function: [
               (identifier) @match
               (attribute attribute: (identifier) @match)
           ]
       )
       "
       .to_string(),
   );

    queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
    queries.insert(PredicateKey::Str, "(string) @match".to_string());

    LanguageProfile {
        name: "Python",
        extensions: vec!["py"],
        language,
        queries,
    }
}

// END rdump/src/predicates/code_aware/profiles/python.rs

// START rdump/src/predicates/code_aware/profiles/rust.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Rust language.
pub(super) fn create_rust_profile() -> LanguageProfile {
    let language = tree_sitter_rust::language();
    let mut queries = HashMap::new();

    let struct_query = "(struct_item name: (_) @match)";
    let enum_query = "(enum_item name: (_) @match)";
    let trait_query = "(trait_item name: (_) @match)";
    let type_query = "(type_item name: (type_identifier) @match)";

    let def_query = [struct_query, enum_query, trait_query, type_query].join("\n");

    queries.insert(PredicateKey::Def, def_query);
    queries.insert(PredicateKey::Struct, struct_query.to_string());
    queries.insert(PredicateKey::Enum, enum_query.to_string());
    queries.insert(PredicateKey::Trait, trait_query.to_string());
    queries.insert(PredicateKey::Type, type_query.to_string());

    // Query for standalone functions and methods in traits or impls.
    queries.insert(
        PredicateKey::Func,
        "
        [
            (function_item name: (identifier) @match)
            (function_signature_item name: (identifier) @match)
        ]"
        .to_string(),
    );
    // Query for the entire `use` declaration. We will match against its text content.
    queries.insert(
        PredicateKey::Import,
        "
        (use_declaration) @match
        "
        .to_string(),
    );

   // Query for function and method call sites.
   queries.insert(
       PredicateKey::Call,
       "
       (call_expression
           function: [
               (identifier) @match
               (field_expression field: (field_identifier) @match)
           ]
       )
       (macro_invocation macro: (identifier) @match)
       "
       .to_string(),
   );

    queries.insert(PredicateKey::Comment, "[(line_comment) @match (block_comment) @match]".to_string());
    queries.insert(PredicateKey::Str, "[(string_literal) @match (raw_string_literal) @match]".to_string());

    LanguageProfile {
        name: "Rust",
        extensions: vec!["rs"],
        language,
        queries,
    }
}

// END rdump/src/predicates/code_aware/profiles/rust.rs

// START rdump/src/predicates/code_aware/profiles/typescript.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the TypeScript language.
pub(super) fn create_typescript_profile() -> LanguageProfile {
    let language = tree_sitter_typescript::language_typescript();
    let mut queries = HashMap::new();

    let class_query = "(class_declaration name: (type_identifier) @match)";
    let interface_query = "(interface_declaration name: (type_identifier) @match)";
    let type_query = "(type_alias_declaration name: (type_identifier) @match)";
    let enum_query = "(enum_declaration name: (identifier) @match)";

    let def_query = [class_query, interface_query, type_query, enum_query].join("\n");
    queries.insert(PredicateKey::Def, def_query);

    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Interface, interface_query.to_string());
    queries.insert(PredicateKey::Type, type_query.to_string());
    queries.insert(PredicateKey::Enum, enum_query.to_string());

    queries.insert(PredicateKey::Func, "[ (function_declaration name: (identifier) @match) (method_definition name: (property_identifier) @match) ]".to_string());
    queries.insert(
        PredicateKey::Import,
        "(import_statement) @match".to_string(),
    );
   queries.insert(
       PredicateKey::Call,
       "[ (call_expression function: [ (identifier) @match (member_expression property: (property_identifier) @match) ]) (new_expression constructor: [ (identifier) @match (type_identifier) @match ]) ]".to_string()
   );

   queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
   queries.insert(PredicateKey::Str, "[(string) @match (template_string) @match]".to_string());

    LanguageProfile {
        name: "TypeScript",
        extensions: vec!["ts", "tsx"],
        language,
        queries,
    }
}

// END rdump/src/predicates/code_aware/profiles/typescript.rs

// START rdump/src/predicates/contains.rs

use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct ContainsEvaluator;

impl PredicateEvaluator for ContainsEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let content = context.get_content()?;
        Ok(MatchResult::Boolean(content.contains(value)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;
    fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }
    #[test]
    fn test_contains_evaluator() {
        let file = create_temp_file("Hello world\nThis is a test.");
        let mut context = FileContext::new(file.path().to_path_buf());
        let evaluator = ContainsEvaluator;
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Contains, "world")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Contains, "is a test")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Contains, "goodbye")
            .unwrap()
            .is_match());
    }
}


// END rdump/src/predicates/contains.rs

// START rdump/src/predicates/ext.rs

use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct ExtEvaluator;
impl PredicateEvaluator for ExtEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let file_ext = context
            .path
            .extension()
            .and_then(|s| s.to_str())
            .unwrap_or("");
        Ok(MatchResult::Boolean(file_ext.eq_ignore_ascii_case(value)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_ext_evaluator() {
        let mut context_rs = FileContext::new(PathBuf::from("main.rs"));
        let mut context_toml = FileContext::new(PathBuf::from("Cargo.TOML"));
        let mut context_no_ext = FileContext::new(PathBuf::from("README"));
        let mut context_dotfile = FileContext::new(PathBuf::from(".bashrc"));

        let evaluator = ExtEvaluator;
        assert!(evaluator
            .evaluate(&mut context_rs, &PredicateKey::Ext, "rs")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context_rs, &PredicateKey::Ext, "toml")
            .unwrap()
            .is_match());
        assert!(
            evaluator
                .evaluate(&mut context_toml, &PredicateKey::Ext, "toml")
                .unwrap()
                .is_match(),
            "Should be case-insensitive"
        );
        assert!(!evaluator
            .evaluate(&mut context_no_ext, &PredicateKey::Ext, "rs")
            .unwrap()
            .is_match());
        assert!(
            !evaluator
                .evaluate(&mut context_dotfile, &PredicateKey::Ext, "bashrc")
                .unwrap()
                .is_match(),
            "Dotfiles should have no extension"
        );
    }
}


// END rdump/src/predicates/ext.rs

// START rdump/src/predicates/helpers.rs

use anyhow::{anyhow, Result};
use std::time::{Duration, SystemTime};

pub(super) fn parse_and_compare_size(file_size: u64, query: &str) -> Result<bool> {
    let (op, size_str) = query.split_at(1);
    let target_size = size_str
        .trim()
        .to_lowercase()
        .replace("kb", " * 1024")
        .replace("mb", " * 1024 * 1024")
        .replace("gb", " * 1024 * 1024 * 1024");

    // A simple expression evaluator for "N * N * N..."
    let target_size_bytes = target_size
        .split('*')
        .map(|s| s.trim().parse::<f64>())
        .collect::<Result<Vec<f64>, _>>()?
        .into_iter()
        .product::<f64>() as u64;

    match op {
        ">" => Ok(file_size > target_size_bytes),
        "<" => Ok(file_size < target_size_bytes),
        "=" => Ok(file_size == target_size_bytes),
        _ => Err(anyhow!("Invalid size operator: {}", op)),
    }
}

pub(super) fn parse_and_compare_time(modified_time: SystemTime, query: &str) -> Result<bool> {
    let now = SystemTime::now();
    let (op, duration_str) = query.split_at(1);
    let duration_str = duration_str.trim();

    let duration_secs = if let Some(num_str) = duration_str.strip_suffix('s') {
        num_str.parse::<u64>()?
    } else if let Some(num_str) = duration_str.strip_suffix('m') {
        num_str.parse::<u64>()? * 60
    } else if let Some(num_str) = duration_str.strip_suffix('h') {
        num_str.parse::<u64>()? * 3600
    } else if let Some(num_str) = duration_str.strip_suffix('d') {
        num_str.parse::<u64>()? * 86400
    } else {
        return Err(anyhow!("Invalid time unit in '{}'", query));
    };

    let duration = Duration::from_secs(duration_secs);
    let threshold_time = now
        .checked_sub(duration)
        .ok_or(anyhow!("Time calculation underflow"))?;

    match op {
        ">" => Ok(modified_time > threshold_time), // Modified more recently than
        "<" => Ok(modified_time < threshold_time), // Modified longer ago than
        _ => Err(anyhow!("Invalid time operator: {}", op)),
    }
}


// END rdump/src/predicates/helpers.rs

// START rdump/src/predicates/matches.rs

use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct MatchesEvaluator;
impl PredicateEvaluator for MatchesEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let content = context.get_content()?;
        let re = regex::Regex::new(value)?;
        Ok(MatchResult::Boolean(re.is_match(content)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_matches_evaluator() {
        let file = create_temp_file("version = \"0.1.0\"\nauthor = \"test\"");
        let mut context = FileContext::new(file.path().to_path_buf());
        let evaluator = MatchesEvaluator;
        // Simple regex
        assert!(evaluator
            .evaluate(
                &mut context,
                &PredicateKey::Matches,
                r#"version = "[0-9]+\.[0-9]+\.[0-9]+""#
            )
            .unwrap()
            .is_match());
        // Test regex that spans lines
        assert!(evaluator
            .evaluate(
                &mut context,
                &PredicateKey::Matches,
                r#"(?s)version.*author"#
            )
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(
                &mut context,
                &PredicateKey::Matches,
                r#"^version = "1.0.0"$"#
            )
            .unwrap()
            .is_match());
    }
}


// END rdump/src/predicates/matches.rs

// START rdump/src/predicates/mod.rs

pub mod code_aware;
pub mod contains;
pub mod ext;
mod helpers;
pub mod matches;
pub mod modified;
pub mod name;
pub mod path;
pub mod size;

use self::code_aware::CodeAwareEvaluator;
use self::contains::ContainsEvaluator;
use self::ext::ExtEvaluator;
use self::matches::MatchesEvaluator;
use self::modified::ModifiedEvaluator;
use self::name::NameEvaluator;
use self::path::PathEvaluator;
use self::size::SizeEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;
use std::collections::HashMap;

// The core trait that all predicate evaluators must implement.
pub trait PredicateEvaluator {
    // The key is now passed to allow one evaluator to handle multiple predicate types.
    fn evaluate(&self, context: &mut FileContext, key: &PredicateKey, value: &str) -> Result<MatchResult>;
}

/// Creates a predicate registry with only the fast, metadata-based predicates.
/// This is used for the pre-filtering pass.
pub fn create_metadata_predicate_registry() -> HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> {
    let mut registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> =
        HashMap::new();

    registry.insert(PredicateKey::Ext, Box::new(ExtEvaluator));
    registry.insert(PredicateKey::Name, Box::new(NameEvaluator));
    registry.insert(PredicateKey::Path, Box::new(PathEvaluator));
    registry.insert(PredicateKey::Size, Box::new(SizeEvaluator));
    registry.insert(PredicateKey::Modified, Box::new(ModifiedEvaluator));

    registry
}

/// Creates and populates the complete predicate registry.
pub fn create_predicate_registry() -> HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> {
    // Start with the metadata predicates
    let mut registry = create_metadata_predicate_registry();

    // Add content-based predicates
    registry.insert(PredicateKey::Contains, Box::new(ContainsEvaluator));
    registry.insert(PredicateKey::Matches, Box::new(MatchesEvaluator));

    // Register the single CodeAwareEvaluator for all semantic predicate keys.
    let code_evaluator = Box::new(CodeAwareEvaluator);
    registry.insert(PredicateKey::Def, code_evaluator.clone());
    registry.insert(PredicateKey::Func, code_evaluator.clone());
    registry.insert(PredicateKey::Import, code_evaluator.clone());
    registry.insert(PredicateKey::Class, code_evaluator.clone());
    registry.insert(PredicateKey::Struct, code_evaluator.clone());
    registry.insert(PredicateKey::Enum, code_evaluator.clone());
    registry.insert(PredicateKey::Interface, code_evaluator.clone());
    registry.insert(PredicateKey::Trait, code_evaluator.clone());
    registry.insert(PredicateKey::Type, code_evaluator.clone());
    registry.insert(PredicateKey::Comment, code_evaluator.clone());
    registry.insert(PredicateKey::Str, code_evaluator.clone());
    registry.insert(PredicateKey::Call, code_evaluator);

    registry
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;

    // The `code_aware` suite remains here as it tests the interaction
    // of multiple profiles, which is a responsibility of this parent module.
    #[test]
    fn test_code_aware_evaluator_full_rust_suite() {
        let rust_code = r#"
            // TODO: refactor this module
            use std::collections::HashMap;

            type ConfigMap = HashMap<String, String>;

            pub struct AppConfig {}
            pub trait Runnable {
                fn run(&self);
            }
            fn launch_app() {
                let msg = "Launching...";
                println!("{}", msg);
            }
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("complex.rs");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(rust_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        // --- Granular Defs ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Struct, "AppConfig")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Trait, "Runnable")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Type, "ConfigMap")
            .unwrap()
            .is_match());

        // --- Functions ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "run")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "launch_app")
            .unwrap()
            .is_match());

        // --- Calls ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "println")
                .unwrap()
                .is_match(),
            "Should find function call"
        );
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            !evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "launch_app")
                .unwrap()
                .is_match(),
            "Should not find the definition as a call"
        );

        // --- Syntactic Content ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "TODO")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "Launching...")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_python_suite() {
        let python_code = r#"
# FIXME: use a real database
import os

class DataProcessor:
    def __init__(self):
        self.api_key = "secret_key"
        self.connect()

    def connect(self):
        print("Connecting...")

def process_data():
    proc = DataProcessor()
    print("Processing")
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("script.py");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(python_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        // --- Granular Defs ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Class, "DataProcessor")
            .unwrap()
            .is_match());

        // --- Functions ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "process_data")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "connect")
            .unwrap()
            .is_match());

        // --- Calls ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "print")
                .unwrap()
                .is_match(),
            "Should find multiple calls to print"
        );
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "DataProcessor")
                .unwrap()
                .is_match(),
            "Should find constructor call"
        );
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "connect")
                .unwrap()
                .is_match(),
            "Should find method call"
        );

        // --- Syntactic Content ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "FIXME")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "secret_key")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_javascript_suite() {
        let js_code = r#"
            import { open } from 'fs/promises';

            class Logger {
                log(message) { console.log(message); }
            }

            function a() {
                const l = new Logger();
                l.log("hello");
            }
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("script.js");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(js_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Def, "Logger")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "log")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "fs/promises")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "Logger")
                .unwrap()
                .is_match(),
            "Should find constructor call"
        );
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "log")
                .unwrap()
                .is_match(),
            "Should find method call"
        );
    }

    #[test]
    fn test_code_aware_evaluator_typescript_suite() {
        let ts_code = r#"
            import React from 'react';

            interface User { id: number; }
            type ID = string | number;

            class ApiClient {
                // The URL for the API
                private url = "https://api.example.com";
                fetchUser(): User | null { return null; }
            }

            const client = new ApiClient();
            client.fetchUser();
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("api.ts");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(ts_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        // --- Granular Defs ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Def, "ApiClient")
                .unwrap()
                .is_match(),
            "Should find class"
        );
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "fetchUser")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "React")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "ApiClient")
                .unwrap()
                .is_match(),
            "Should find TS constructor call"
        );
        let mut ctx = FileContext::new(file_path.clone());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "fetchUser")
                .unwrap()
                .is_match(),
            "Should find TS method call"
        );

        // --- Syntactic Content ---
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "The URL")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "https://api.example.com")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_go_suite() {
        let go_code = r#"
           package main

           import "fmt"

           // User represents a user
           type User struct {
               ID int
           }

           func (u *User) Greet() {
               fmt.Println("Hello")
           }

           func main() {
               user := User{ID: 1}
               user.Greet()
           }
       "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("main.go");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(go_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Struct, "User")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "Greet")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Call, "Println")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "fmt")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "represents a user")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_java_suite() {
        let java_code = r#"
           package com.example;

           import java.util.List;

           // Represents a user
           public class User {
               public User() {
                   System.out.println("User created");
               }

               public void greet() {}
           }
       "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("User.java");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(java_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Class, "User")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "greet")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Call, "println")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "java.util.List")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "Represents a user")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "User created")
            .unwrap()
            .is_match());
    }
}

// END rdump/src/predicates/mod.rs

// START rdump/src/predicates/modified.rs

use super::{helpers, PredicateEvaluator};
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct ModifiedEvaluator;
impl PredicateEvaluator for ModifiedEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let metadata = context.path.metadata()?;
        let modified_time = metadata.modified()?;
        Ok(MatchResult::Boolean(helpers::parse_and_compare_time(
            modified_time,
            value,
        )?))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_modified_evaluator() {
        let file = create_temp_file("content");
        let mut context = FileContext::new(file.path().to_path_buf());

        let evaluator = ModifiedEvaluator;
        // File was just created
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Modified, ">1m")
            .unwrap()
            .is_match()); // Modified more recently than 1 min ago
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Modified, "<1m")
            .unwrap()
            .is_match()); // Not modified longer than 1 min ago
    }
}


// END rdump/src/predicates/modified.rs

// START rdump/src/predicates/name.rs

use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct NameEvaluator;
impl PredicateEvaluator for NameEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let file_name = context
            .path
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or("");
        let pattern = glob::Pattern::new(value)?;
        Ok(MatchResult::Boolean(pattern.matches(file_name)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_name_evaluator() {
        let mut context1 = FileContext::new(PathBuf::from("/home/user/Cargo.toml"));
        let mut context2 = FileContext::new(PathBuf::from("/home/user/main.rs"));

        let evaluator = NameEvaluator;
        assert!(evaluator
            .evaluate(&mut context1, &PredicateKey::Name, "Cargo.toml")
            .unwrap()
            .is_match());
        assert!(
            evaluator
                .evaluate(&mut context1, &PredicateKey::Name, "C*.toml")
                .unwrap()
                .is_match(),
            "Glob pattern should match"
        );
        assert!(
            evaluator
                .evaluate(&mut context2, &PredicateKey::Name, "*.rs")
                .unwrap()
                .is_match(),
            "Glob pattern should match"
        );
        assert!(!evaluator
            .evaluate(&mut context1, &PredicateKey::Name, "*.rs")
            .unwrap()
            .is_match());
    }
}


// END rdump/src/predicates/name.rs

// START rdump/src/predicates/path.rs

use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct PathEvaluator;
impl PredicateEvaluator for PathEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let path_str = context.path.to_string_lossy();
        Ok(MatchResult::Boolean(path_str.contains(value)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_path_evaluator() {
        let mut context = FileContext::new(PathBuf::from("/home/user/project/src/main.rs"));
        let evaluator = PathEvaluator;
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "project/src")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "/home/user")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Path, "project/lib")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "main.rs")
            .unwrap()
            .is_match());
    }
}


// END rdump/src/predicates/path.rs

// START rdump/src/predicates/size.rs

use super::{helpers, PredicateEvaluator};
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct SizeEvaluator;
impl PredicateEvaluator for SizeEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let metadata = context.path.metadata()?;
        let file_size = metadata.len();
        Ok(MatchResult::Boolean(helpers::parse_and_compare_size(
            file_size, value,
        )?))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_size_evaluator() {
        let file = create_temp_file("a".repeat(2000).as_str());
        let mut context = FileContext::new(file.path().to_path_buf());

        let evaluator = SizeEvaluator;
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">1000")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Size, "<1kb")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">0.9kb")
            .unwrap()
            .is_match());
    }
}


// END rdump/src/predicates/size.rs

