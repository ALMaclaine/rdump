File: ./evaluator.rs
---
use anyhow::{anyhow, Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use tree_sitter::{Parser, Range, Tree};

use crate::parser::{AstNode, LogicalOperator, PredicateKey};
use crate::predicates::PredicateEvaluator;

/// The result of an evaluation for a single file.
#[derive(Debug, Clone)]
pub enum MatchResult {
    // For simple, non-hunkable predicates like `ext:rs` or `size:>10kb`
    Boolean(bool),
    // For code-aware predicates that can identify specific code blocks.
    Hunks(Vec<Range>),
}

/// Holds the context for a single file being evaluated.
/// It lazily loads content and caches the tree-sitter AST.
pub struct FileContext {
    pub path: PathBuf,
    pub root: PathBuf,
    content: Option<String>,
    // Cache for the parsed tree-sitter AST
    tree: Option<Tree>,
}

impl FileContext {
    pub fn new(path: PathBuf, root: PathBuf) -> Self {
        FileContext {
            path,
            root,
            content: None,
            tree: None,
        }
    }

    pub fn get_content(&mut self) -> Result<&str> {
        if self.content.is_none() {
            let content = fs::read_to_string(&self.path)
                .with_context(|| format!("Failed to read file {}", self.path.display()))?;
            self.content = Some(content);
        }
        Ok(self.content.as_ref().unwrap())
    }

    // Lazily parses the file with tree-sitter and caches the result.
    pub fn get_tree(&mut self, language: tree_sitter::Language) -> Result<&Tree> {
        if self.tree.is_none() {
            let path_display = self.path.display().to_string();
            let content = self.get_content()?;
            let mut parser = Parser::new();
            parser.set_language(&language).with_context(|| {
                format!("Failed to set language for tree-sitter parser on {path_display}")
            })?;
            let tree = parser
                .parse(content, None)
                .ok_or_else(|| anyhow!("Tree-sitter failed to parse {}", path_display))?;
            self.tree = Some(tree);
        }
        Ok(self.tree.as_ref().unwrap())
    }
}

/// The main evaluator struct. It holds the AST and the predicate registry.
pub struct Evaluator {
    ast: AstNode,
    registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>>,
}

impl Evaluator {
    pub fn new(
        ast: AstNode,
        registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>>,
    ) -> Self {
        Evaluator { ast, registry }
    }

    /// Evaluates the query for a given file path.
    pub fn evaluate(&self, context: &mut FileContext) -> Result<MatchResult> {
        self.evaluate_node(&self.ast, context)
    }

    /// Recursively evaluates an AST node.
    fn evaluate_node(&self, node: &AstNode, context: &mut FileContext) -> Result<MatchResult> {
        match node {
            AstNode::Predicate(key, value) => self.evaluate_predicate(key, value, context),
            AstNode::LogicalOp(op, left, right) => {
                let left_res = self.evaluate_node(left, context)?;

                // Short-circuit AND if left is false
                if *op == LogicalOperator::And && !left_res.is_match() {
                    return Ok(MatchResult::Boolean(false));
                }

                // Short-circuit OR if left is a full-file match
                if *op == LogicalOperator::Or {
                    if let MatchResult::Boolean(true) = left_res {
                        return Ok(left_res);
                    }
                }

                let right_res = self.evaluate_node(right, context)?;
                Ok(left_res.combine_with(right_res, op))
            }
            AstNode::Not(inner_node) => {
                // If the inner predicate of a NOT is not in the registry (e.g., a content
                // predicate during the metadata-only pass), we cannot definitively say the file
                // *doesn't* match. We must assume it *could* match and let the full evaluator decide.
                if let AstNode::Predicate(key, _) = &**inner_node {
                    if !self.registry.contains_key(key) {
                        return Ok(MatchResult::Boolean(true));
                    }
                }
                let result = self.evaluate_node(inner_node, context)?;
                Ok(MatchResult::Boolean(!result.is_match()))
            }
        }
    }

    /// Evaluates a single predicate.
    fn evaluate_predicate(
        &self,
        key: &PredicateKey,
        value: &str,
        context: &mut FileContext,
    ) -> Result<MatchResult> {
        if let Some(evaluator) = self.registry.get(key) {
            evaluator.evaluate(context, key, value)
        } else {
            // If a predicate is not in the current registry (e.g., a content predicate
            // during the metadata-only pass), it's considered a "pass" for this stage.
            Ok(MatchResult::Boolean(true))
        }
    }
}

impl MatchResult {
    /// Returns true if the result is considered a match.
    pub fn is_match(&self) -> bool {
        match self {
            MatchResult::Boolean(b) => *b,
            MatchResult::Hunks(h) => !h.is_empty(),
        }
    }

    /// Combines two match results based on a logical operator.
    pub fn combine_with(self, other: MatchResult, op: &LogicalOperator) -> Self {
        match op {
            LogicalOperator::And => {
                if !self.is_match() || !other.is_match() {
                    return MatchResult::Boolean(false);
                }
                match (self, other) {
                    (MatchResult::Hunks(mut a), MatchResult::Hunks(b)) => {
                        a.extend(b);
                        a.sort_by_key(|r| r.start_byte);
                        a.dedup();
                        MatchResult::Hunks(a)
                    }
                    (h @ MatchResult::Hunks(_), MatchResult::Boolean(true)) => h,
                    (MatchResult::Boolean(true), h @ MatchResult::Hunks(_)) => h,
                    (MatchResult::Boolean(true), MatchResult::Boolean(true)) => MatchResult::Boolean(true),
                    _ => MatchResult::Boolean(false),
                }
            }
            LogicalOperator::Or => {
                match (self, other) {
                    (MatchResult::Boolean(true), _) | (_, MatchResult::Boolean(true)) => MatchResult::Boolean(true),
                    (MatchResult::Hunks(mut a), MatchResult::Hunks(b)) => {
                        a.extend(b);
                        a.sort_by_key(|r| r.start_byte);
                        a.dedup();
                        MatchResult::Hunks(a)
                    }
                    (h @ MatchResult::Hunks(_), MatchResult::Boolean(false)) => h,
                    (MatchResult::Boolean(false), h @ MatchResult::Hunks(_)) => h,
                    (MatchResult::Boolean(false), MatchResult::Boolean(false)) => MatchResult::Boolean(false),
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_query;
    use crate::predicates;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_file(content: &str) -> NamedTempFile {
        let file = NamedTempFile::new().unwrap();
        write!(file.as_file(), "{}", content).unwrap();
        file
    }

    #[test]
    fn test_evaluate_logical_and() {
        let file = create_temp_file("hello world");
        let mut context = FileContext::new(file.path().to_path_buf(), PathBuf::from("/"));
        let ast = parse_query("contains:hello & contains:world").unwrap();
        let evaluator = Evaluator::new(ast, predicates::create_predicate_registry());
        assert!(evaluator.evaluate(&mut context).unwrap().is_match());

        let ast_fail = parse_query("contains:hello & contains:goodbye").unwrap();
        let evaluator_fail = Evaluator::new(ast_fail, predicates::create_predicate_registry());
        assert!(!evaluator_fail.evaluate(&mut context).unwrap().is_match());
    }
}

---

File: ./src/commands/lang.rs
---
use crate::predicates::code_aware::profiles::list_language_profiles;
use crate::LangAction;
use anyhow::{anyhow, Result};

pub fn run_lang(action: LangAction) -> Result<()> {
    match action {
        LangAction::List => {
            let profiles = list_language_profiles();
            println!("{:<12} EXTENSIONS", "NAME");
            println!("──────────────────────────");
            for profile in profiles {
                println!("{:<12} {}", profile.name, profile.extensions.join(", "));
            }
        }
        LangAction::Describe { language } => {
            let lang_lower = language.to_lowercase();
            let profiles = list_language_profiles();
            let profile = profiles
                .into_iter()
                .find(|p| p.name.to_lowercase() == lang_lower || p.extensions.contains(&lang_lower.as_str()))
                .ok_or_else(|| anyhow!("Language '{}' not supported. Run `rdump lang list` to see available languages.", language))?;

            println!(
                "Predicates for {} ({})",
                profile.name,
                profile.extensions.join(", ")
            );

            let metadata_preds = ["ext", "name", "path", "size", "modified"];
            let content_preds = ["contains", "matches"];

            println!("\nMETADATA");
            println!("  {}", metadata_preds.join(", "));

            println!("\nCONTENT");
            println!("  {}", content_preds.join(", "));

            let semantic_preds: Vec<&str> = profile.queries.keys().map(|k| k.as_ref()).collect();
            if !semantic_preds.is_empty() {
                println!("\nSEMANTIC");
                println!("  {}", semantic_preds.join(", "));
            }
        }
    }
    Ok(())
}

---

File: ./src/commands/mod.rs
---
// This makes the functions inside search.rs and preset.rs available
// to other parts of the program that use the `commands` module.
pub mod lang;
pub mod preset;
pub mod search;

---

File: ./src/commands/preset.rs
---
use crate::config::{self, Config};
use crate::PresetAction;
use anyhow::{anyhow, Result};
use std::fs; // We'll need to make PresetAction public

/// The main entry point for the `preset` command.
pub fn run_preset(action: PresetAction) -> Result<()> {
    match action {
        PresetAction::List => {
            let config = config::load_config()?;
            if config.presets.is_empty() {
                println!("No presets found.");
            } else {
                println!("Available presets:");
                let max_len = config.presets.keys().map(|k| k.len()).max().unwrap_or(0);
                for (name, query) in config.presets {
                    println!("  {name:<max_len$} : {query}");
                }
            }
        }
        PresetAction::Add { name, query } => {
            let path = config::global_config_path()
                .ok_or_else(|| anyhow!("Could not determine global config path"))?;

            let mut config = if path.exists() {
                let config_str = fs::read_to_string(&path)?;
                toml::from_str(&config_str)?
            } else {
                Config::default()
            };

            println!("Adding/updating preset '{name}'...");
            config.presets.insert(name, query);
            config::save_config(&config)?;
        }
        PresetAction::Remove { name } => {
            let path = config::global_config_path()
                .ok_or_else(|| anyhow!("Could not determine global config path"))?;

            if !path.exists() {
                return Err(anyhow!(
                    "Global config file does not exist. No presets to remove."
                ));
            }

            let mut config: Config = toml::from_str(&fs::read_to_string(&path)?)?;

            if config.presets.remove(&name).is_some() {
                println!("Removing preset '{name}'...");
                config::save_config(&config)?;
            } else {
                return Err(anyhow!("Preset '{}' not found in global config.", name));
            }
        }
    }
    Ok(())
}

---

File: ./src/commands/search.rs
---
use crate::{config, ColorChoice, SearchArgs};
use anyhow::anyhow;
use anyhow::Result;
use atty::Stream;
use ignore::WalkBuilder;
use rayon::prelude::*;
use std::fs::File;
use std::io::{self, Write};
use std::path::PathBuf;
use std::sync::Mutex;
use tempfile::NamedTempFile;
use tree_sitter::Range;

use crate::evaluator::{Evaluator, FileContext, MatchResult};
use crate::formatter;
use crate::parser;
use crate::predicates;

/// The main entry point for the `search` command.
pub fn run_search(mut args: SearchArgs) -> Result<()> {
    // --- Handle Shorthand Flags ---
    if args.no_headers {
        args.format = crate::Format::Cat;
    }
    if args.find {
        args.format = crate::Format::Find;
    }

    // --- Perform the actual search ---
    let matching_files = perform_search(&args)?;

    // --- Determine if color should be used ---
    let mut use_color = match args.color {
        ColorChoice::Always => true,
        ColorChoice::Never => false,
        ColorChoice::Auto => atty::is(Stream::Stdout),
    };

    // If outputting to a file, disable color unless explicitly forced.
    if args.output.is_some() && args.color != ColorChoice::Always {
        use_color = false;
    }

    // If the output format is `Cat` (likely for piping), we should not use color
    // unless the user has explicitly forced it with `Always`.
    if let crate::Format::Cat = args.format {
        if args.color != ColorChoice::Always {
            use_color = false;
        }
    }

    // --- 5. Format and print results ---
    let mut writer: Box<dyn Write> = if let Some(output_path) = &args.output {
        Box::new(File::create(output_path)?)
    } else {
        Box::new(io::stdout())
    };

    formatter::print_output(
        &mut writer,
        &matching_files,
        &args.format,
        args.line_numbers,
        args.no_headers,
        use_color,
        args.context.unwrap_or(0),
    )?;

    Ok(())
}

/// Performs the search logic and returns the matching files and their hunks.
/// This function is separated from `run_search` to be testable.
pub fn perform_search(args: &SearchArgs) -> Result<Vec<(PathBuf, Vec<Range>)>> {
    // --- Load Config and Build Query ---
    let config = config::load_config()?;
    let mut final_query = args.query.clone();

    for preset_name in args.preset.iter().rev() {
        let preset_query = config
            .presets
            .get(preset_name)
            .ok_or_else(|| anyhow!("Preset '{}' not found", preset_name))?;

        if final_query.is_empty() {
            final_query = format!("({preset_query})");
        } else {
            final_query = format!("({preset_query}) & ({final_query})");
        }
    }

    if final_query.is_empty() {
        return Err(anyhow!(
            "Empty query. Provide a query string or use a preset."
        ));
    }

    // --- 1. Find initial candidates ---
    let candidate_files = get_candidate_files(
        &args.root,
        args.no_ignore,
        args.hidden,
        args.max_depth,
    )?;

    // --- 2. Parse query ---
    let ast = parser::parse_query(&final_query)?;

    // --- 3. Pre-filtering Pass (Metadata) ---
    // This pass uses an evaluator with only fast metadata predicates.
    // It quickly reduces the number of files needing full evaluation.
    let metadata_registry = predicates::create_metadata_predicate_registry();
    let pre_filter_evaluator = Evaluator::new(ast.clone(), metadata_registry);

    let first_error = Mutex::new(None);
    let pre_filtered_files: Vec<PathBuf> = candidate_files
        .into_iter() // This pass is not parallel, it's fast enough.
        .filter(|path| {
            if first_error.lock().unwrap().is_some() {
                return false;
            }
            let mut context = FileContext::new(path.clone(), args.root.clone());
            match pre_filter_evaluator.evaluate(&mut context) {
                Ok(result) => result.is_match(),
                Err(e) => {
                    let mut error_guard = first_error.lock().unwrap();
                    if error_guard.is_none() {
                        *error_guard =
                            Some(anyhow!("Error during pre-filter on {}: {}", path.display(), e));
                    }
                    false
                }
            }
        })
        .collect();

    if let Some(e) = first_error.into_inner().unwrap() {
        return Err(e);
    }

    // --- 4. Main Evaluation Pass (Content + Semantic) ---
    // This pass uses the full evaluator on the smaller, pre-filtered set of files.
    let full_registry = predicates::create_predicate_registry();
    let evaluator = Evaluator::new(ast, full_registry);

    let first_error = Mutex::new(None);
    let mut matching_files: Vec<(PathBuf, Vec<Range>)> = pre_filtered_files
        .par_iter()
        .filter_map(|path| {
            if first_error.lock().unwrap().is_some() {
                return None;
            }
            let mut context = FileContext::new(path.clone(), args.root.clone());
            match evaluator.evaluate(&mut context) {
                Ok(MatchResult::Boolean(true)) => Some((path.clone(), Vec::new())),
                Ok(MatchResult::Boolean(false)) => None,
                Ok(MatchResult::Hunks(hunks)) => {
                    if hunks.is_empty() {
                        None
                    } else {
                        Some((path.clone(), hunks))
                    }
                }
                Err(e) => {
                    let mut error_guard = first_error.lock().unwrap();
                    if error_guard.is_none() {
                        *error_guard =
                            Some(anyhow!("Error evaluating file {}: {}", path.display(), e));
                    }
                    None
                }
            }
        })
        .collect();

    if let Some(e) = first_error.into_inner().unwrap() {
        return Err(e);
    }

    matching_files.sort_by(|a, b| a.0.cmp(&b.0));

    Ok(matching_files)
}


/// Walks the directory, respecting .gitignore, and applies our own smart defaults.
fn get_candidate_files(
    root: &PathBuf,
    no_ignore: bool,
    hidden: bool,
    max_depth: Option<usize>,
) -> Result<Vec<PathBuf>> {
    let mut files = Vec::new();
    let mut walker_builder = WalkBuilder::new(root);

    walker_builder.hidden(!hidden).max_depth(max_depth);

    if no_ignore {
        // If --no-ignore is passed, disable everything.
        walker_builder
            .ignore(false)
            .git_ignore(false)
            .git_global(false)
            .git_exclude(false);
    } else {
        // Layer 1: Our "sane defaults". These have the lowest precedence.
        let default_ignores = "
           # Default rdump ignores
           node_modules/
           target/
           dist/
           build/
           .git/
           .svn/
           .hg/
           *.pyc
           __pycache__/
       ";
        let mut temp_ignore = NamedTempFile::new()?;
        write!(temp_ignore, "{default_ignores}")?;
        walker_builder.add_ignore(temp_ignore.path());

        // Layer 2: A user's custom global ignore file.
        if let Some(global_ignore_path) = dirs::config_dir().map(|p| p.join("rdump/ignore")) {
            if global_ignore_path.exists() {
                if let Some(err) = walker_builder.add_ignore(global_ignore_path) {
                    eprintln!("Warning: could not add global ignore file: {err}");
                }
            }
        }

        // Layer 3: A user's custom project-local .rdumpignore file.
        walker_builder.add_custom_ignore_filename(".rdumpignore");

        // Layer 4: Standard .gitignore files are enabled by default.
        // walker_builder.git_global(true);
        // walker_builder.git_ignore(true);
    }

    for result in walker_builder.build() {
        // Handle potential errors from the directory walk itself
        match result {
            Ok(entry) => {
                if entry.file_type().is_some_and(|ft| ft.is_file()) {
                    files.push(entry.into_path());
                }
            }
            Err(e) => {
                // If a path doesn't exist (e.g., bad root), this is a hard error.
                if e.is_io() {
                    if let Some(inner) = e.clone().into_io_error() {
                        if inner.kind() == std::io::ErrorKind::NotFound {
                            return Err(anyhow!("root path '{}' does not exist or is not accessible.", root.display()));
                        }
                    }
                }
                // For other errors (e.g. permission denied on a sub-dir), just print a warning.
                eprintln!("Warning: could not access entry: {}", e);
            }
        }
    }
    Ok(files)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::io::Write;
    use std::path::PathBuf;
    use tempfile::tempdir;

    fn get_sorted_file_names(
        root: &PathBuf,
        no_ignore: bool,
        hidden: bool,
        max_depth: Option<usize>,
    ) -> Vec<String> {
        let mut paths = get_candidate_files(root, no_ignore, hidden, max_depth).unwrap();
        paths.sort();
        paths
            .into_iter()
            .map(|p| {
                p.strip_prefix(root)
                    .unwrap()
                    .to_string_lossy()
                    .replace('\\', "/")
            })
            .collect()
    }

    #[test]
    fn test_custom_rdumpignore_file() {
        let dir = tempdir().unwrap();
        let root = dir.path();
        let mut ignore_file = fs::File::create(root.join(".rdumpignore")).unwrap();
        writeln!(ignore_file, "*.log").unwrap();
        fs::File::create(root.join("app.js")).unwrap();
        fs::File::create(root.join("app.log")).unwrap();

        let files = get_sorted_file_names(&root.to_path_buf(), false, false, None);
        assert_eq!(files, vec!["app.js"]);
    }

    #[test]
    fn test_unignore_via_rdumpignore() {
        let dir = tempdir().unwrap();
        let root = dir.path();

        let node_modules = root.join("node_modules");
        fs::create_dir(&node_modules).unwrap();
        fs::File::create(node_modules.join("some_dep.js")).unwrap();
        fs::File::create(root.join("app.js")).unwrap();

        let mut ignore_file = fs::File::create(root.join(".rdumpignore")).unwrap();
        writeln!(ignore_file, "!node_modules/").unwrap();

        let files = get_sorted_file_names(&root.to_path_buf(), false, false, None);
        assert_eq!(files.len(), 2);
        assert!(files.contains(&"app.js".to_string()));
        let expected_path = PathBuf::from("node_modules").join("some_dep.js");
        assert!(files.contains(&expected_path.to_string_lossy().to_string()));
    }
}

---

File: ./src/config.rs
---
// rdump/src/config.rs - FINAL CORRECTED VERSION

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Deserialize, Serialize, Debug, Default)]
pub struct Config {
    #[serde(default)]
    pub presets: HashMap<String, String>,
}

/// Returns the path to the global configuration file.
/// It can be overridden by the RDUMP_TEST_CONFIG_DIR environment variable for testing.
pub fn global_config_path() -> Option<PathBuf> {
    // First, check for the override environment variable. This is active in ALL builds.
    if let Ok(path_str) = env::var("RDUMP_TEST_CONFIG_DIR") {
        return Some(PathBuf::from(path_str).join("rdump/config.toml"));
    }

    // If the override is not set, fall back to the default platform-specific directory.
    dirs::config_dir().map(|p| p.join("rdump/config.toml"))
}

/// Searches for a local `.rdump.toml` in the given directory and its parents.
fn find_local_config(start_dir: &Path) -> Option<PathBuf> {
    for ancestor in start_dir.ancestors() {
        let config_path = ancestor.join(".rdump.toml");
        if config_path.exists() {
            return Some(config_path);
        }
    }
    None
}

/// Finds and loads the configuration, merging global and local files.
pub fn load_config() -> Result<Config> {
    let mut final_config = Config::default();

    // 1. Load the global config file, if it exists.
    if let Some(global_config_path) = global_config_path() {
        if global_config_path.exists() {
            let global_config_str = fs::read_to_string(&global_config_path).with_context(|| {
                format!("Failed to read global config at {global_config_path:?}")
            })?;
            let global_config: Config = toml::from_str(&global_config_str)?;
            final_config.presets.extend(global_config.presets);
        }
    }

    // 2. Find and load the local config file, if it exists.
    let current_dir = env::current_dir()?;
    if let Some(local_config_path) = find_local_config(&current_dir) {
        if local_config_path.exists() {
            let local_config_str = fs::read_to_string(&local_config_path)
                .with_context(|| format!("Failed to read local config at {local_config_path:?}"))?;
            let local_config: Config = toml::from_str(&local_config_str)?;
            final_config.presets.extend(local_config.presets);
        }
    }

    Ok(final_config)
}

/// Saves the given config to the global configuration file.
pub fn save_config(config: &Config) -> Result<()> {
    let path = global_config_path()
        .ok_or_else(|| anyhow::anyhow!("Could not determine global config path"))?;

    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create config directory at {parent:?}"))?;
    }

    let toml_string = toml::to_string_pretty(config)?;
    fs::write(&path, toml_string)
        .with_context(|| format!("Failed to write global config to {path:?}"))?;

    println!("Successfully saved config to {path:?}");
    Ok(())
}

// The unit tests for config.rs remain the same and will still pass.
#[cfg(test)]
mod tests {
    use super::*;
    use once_cell::sync::Lazy;
    use std::io::Write;
    use std::sync::Mutex;
    use tempfile::tempdir;

    static ENV_MUTEX: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));

    #[test]
    fn test_find_local_config_in_parent() {
        let _lock = ENV_MUTEX.lock().unwrap();
        let root = tempdir().unwrap();
        let sub = root.path().join("sub");
        fs::create_dir(&sub).unwrap();

        let config_path = root.path().join(".rdump.toml");
        fs::File::create(&config_path).unwrap();

        let found_path = find_local_config(&sub).unwrap();
        assert_eq!(found_path, config_path);
    }

    #[test]
    fn test_find_local_config_not_found() {
        let _lock = ENV_MUTEX.lock().unwrap();
        let root = tempdir().unwrap();
        assert!(find_local_config(root.path()).is_none());
    }

    #[test]
    fn test_load_config_merging_and_overriding() {
        let _lock = ENV_MUTEX.lock().unwrap();
        let test_dir = tempdir().unwrap();

        let fake_home_dir = test_dir.path().join("home");
        let global_config_dir = fake_home_dir.join("rdump");
        fs::create_dir_all(&global_config_dir).unwrap();
        let global_config_path = global_config_dir.join("config.toml");
        let mut global_file = fs::File::create(&global_config_path).unwrap();
        writeln!(
            global_file,
            r#"
            [presets]
            rust = "ext:rs"
            docs = "ext:md"
        "#
        )
        .unwrap();

        let project_dir = test_dir.path().join("project");
        fs::create_dir(&project_dir).unwrap();
        let local_config_path = project_dir.join(".rdump.toml");
        let mut local_file = fs::File::create(&local_config_path).unwrap();
        writeln!(
            local_file,
            r#"
            [presets]
            docs = "ext:md | ext:txt"
            scripts = "ext:sh"
        "#
        )
        .unwrap();

        env::set_var("RDUMP_TEST_CONFIG_DIR", fake_home_dir.to_str().unwrap());
        let original_dir = env::current_dir().unwrap();
        env::set_current_dir(&project_dir).unwrap();
        let config = load_config().unwrap();
        env::set_current_dir(&original_dir).unwrap();

        assert_eq!(config.presets.len(), 3);
        assert_eq!(config.presets.get("rust").unwrap(), "ext:rs");
        assert_eq!(config.presets.get("scripts").unwrap(), "ext:sh");
        assert_eq!(config.presets.get("docs").unwrap(), "ext:md | ext:txt");

        env::remove_var("RDUMP_TEST_CONFIG_DIR");
    }
}

---

File: ./src/evaluator.rs
---
use anyhow::{anyhow, Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use tree_sitter::{Parser, Range, Tree};

use crate::parser::{AstNode, LogicalOperator, PredicateKey};
use crate::predicates::PredicateEvaluator;

/// The result of an evaluation for a single file.
#[derive(Debug, Clone)]
pub enum MatchResult {
    // For simple, non-hunkable predicates like `ext:rs` or `size:>10kb`
    Boolean(bool),
    // For code-aware predicates that can identify specific code blocks.
    Hunks(Vec<Range>),
}

/// Holds the context for a single file being evaluated.
/// It lazily loads content and caches the tree-sitter AST.
pub struct FileContext {
    pub path: PathBuf,
    pub root: PathBuf,
    content: Option<String>,
    // Cache for the parsed tree-sitter AST
    tree: Option<Tree>,
}

impl FileContext {
    pub fn new(path: PathBuf, root: PathBuf) -> Self {
        FileContext {
            path,
            root,
            content: None,
            tree: None,
        }
    }

    pub fn get_content(&mut self) -> Result<&str> {
        if self.content.is_none() {
            let content = fs::read_to_string(&self.path)
                .with_context(|| format!("Failed to read file {}", self.path.display()))?;
            self.content = Some(content);
        }
        Ok(self.content.as_ref().unwrap())
    }

    // Lazily parses the file with tree-sitter and caches the result.
    pub fn get_tree(&mut self, language: tree_sitter::Language) -> Result<&Tree> {
        if self.tree.is_none() {
            let path_display = self.path.display().to_string();
            let content = self.get_content()?;
            let mut parser = Parser::new();
            parser.set_language(&language).with_context(|| {
                format!("Failed to set language for tree-sitter parser on {path_display}")
            })?;
            let tree = parser
                .parse(content, None)
                .ok_or_else(|| anyhow!("Tree-sitter failed to parse {}", path_display))?;
            self.tree = Some(tree);
        }
        Ok(self.tree.as_ref().unwrap())
    }
}

/// The main evaluator struct. It holds the AST and the predicate registry.
pub struct Evaluator {
    ast: AstNode,
    registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>>,
}

impl Evaluator {
    pub fn new(
        ast: AstNode,
        registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>>,
    ) -> Self {
        Evaluator { ast, registry }
    }

    /// Evaluates the query for a given file path.
    pub fn evaluate(&self, context: &mut FileContext) -> Result<MatchResult> {
        self.evaluate_node(&self.ast, context)
    }

    /// Recursively evaluates an AST node.
    fn evaluate_node(&self, node: &AstNode, context: &mut FileContext) -> Result<MatchResult> {
        match node {
            AstNode::Predicate(key, value) => self.evaluate_predicate(key, value, context),
            AstNode::LogicalOp(op, left, right) => {
                let left_res = self.evaluate_node(left, context)?;

                // Short-circuit AND if left is false
                if *op == LogicalOperator::And && !left_res.is_match() {
                    return Ok(MatchResult::Boolean(false));
                }

                // Short-circuit OR if left is a full-file match
                if *op == LogicalOperator::Or {
                    if let MatchResult::Boolean(true) = left_res {
                        return Ok(left_res);
                    }
                }

                let right_res = self.evaluate_node(right, context)?;
                Ok(left_res.combine_with(right_res, op))
            }
            AstNode::Not(inner_node) => {
                // If the inner predicate of a NOT is not in the registry (e.g., a content
                // predicate during the metadata-only pass), we cannot definitively say the file
                // *doesn't* match. We must assume it *could* match and let the full evaluator decide.
                if let AstNode::Predicate(key, _) = &**inner_node {
                    if !self.registry.contains_key(key) {
                        return Ok(MatchResult::Boolean(true));
                    }
                }
                let result = self.evaluate_node(inner_node, context)?;
                Ok(MatchResult::Boolean(!result.is_match()))
            }
        }
    }

    /// Evaluates a single predicate.
    fn evaluate_predicate(
        &self,
        key: &PredicateKey,
        value: &str,
        context: &mut FileContext,
    ) -> Result<MatchResult> {
        if let Some(evaluator) = self.registry.get(key) {
            evaluator.evaluate(context, key, value)
        } else {
            // If a predicate is not in the current registry (e.g., a content predicate
            // during the metadata-only pass), it's considered a "pass" for this stage.
            Ok(MatchResult::Boolean(true))
        }
    }
}

impl MatchResult {
    /// Returns true if the result is considered a match.
    pub fn is_match(&self) -> bool {
        match self {
            MatchResult::Boolean(b) => *b,
            MatchResult::Hunks(h) => !h.is_empty(),
        }
    }

    /// Combines two match results based on a logical operator.
    pub fn combine_with(self, other: MatchResult, op: &LogicalOperator) -> Self {
        match op {
            LogicalOperator::And => self.combine_and(other),
            LogicalOperator::Or => self.combine_or(other),
        }
    }

    // Helper for AND logic
    fn combine_and(self, other: MatchResult) -> Self {
        if !self.is_match() || !other.is_match() {
            return MatchResult::Boolean(false);
        }
        match (self, other) {
            // Both are hunks: combine them, sort, and deduplicate.
            (MatchResult::Hunks(mut a), MatchResult::Hunks(b)) => {
                a.extend(b);
                a.sort_by_key(|r| r.start_byte);
                a.dedup();
                MatchResult::Hunks(a)
            }
            // One is a hunk, the other is a full-file match (true). Keep the hunks.
            (h @ MatchResult::Hunks(_), MatchResult::Boolean(true)) => h,
            (MatchResult::Boolean(true), h @ MatchResult::Hunks(_)) => h,
            // Both are full-file matches.
            (MatchResult::Boolean(true), MatchResult::Boolean(true)) => MatchResult::Boolean(true),
            // Should be unreachable due to the initial `is_match` check.
            _ => MatchResult::Boolean(false),
        }
    }

    // Helper for OR logic
    fn combine_or(self, other: MatchResult) -> Self {
        match (self, other) {
            // If either is a full-file match, the result is a full-file match.
            (MatchResult::Boolean(true), _) | (_, MatchResult::Boolean(true)) => {
                MatchResult::Boolean(true)
            }
            // Both are hunks: combine them, sort, and deduplicate.
            (MatchResult::Hunks(mut a), MatchResult::Hunks(b)) => {
                a.extend(b);
                a.sort_by_key(|r| r.start_byte);
                a.dedup();
                MatchResult::Hunks(a)
            }
            // One is a hunk, the other is a non-match. Keep the hunks.
            (h @ MatchResult::Hunks(_), MatchResult::Boolean(false)) => h,
            (MatchResult::Boolean(false), h @ MatchResult::Hunks(_)) => h,
            // Both are non-matches.
            (MatchResult::Boolean(false), MatchResult::Boolean(false)) => {
                MatchResult::Boolean(false)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::LogicalOperator;
    use std::fs;
    use tempfile::tempdir;
    use tree_sitter::Point;
    use tree_sitter_rust::language;

    #[test]
    fn test_combine_with_hunks_and() {
        let hunks1 = vec![Range {
            start_byte: 10,
            end_byte: 20,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 0 },
        }];
        let hunks2 = vec![Range {
            start_byte: 30,
            end_byte: 40,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 0 },
        }];
        let result1 = MatchResult::Hunks(hunks1);
        let result2 = MatchResult::Hunks(hunks2);

        let combined = result1.combine_with(result2, &LogicalOperator::And);

        if let MatchResult::Hunks(h) = combined {
            assert_eq!(h.len(), 2);
            assert_eq!(h[0].start_byte, 10);
            assert_eq!(h[1].start_byte, 30);
        } else {
            panic!("Expected Hunks result");
        }
    }

    #[test]
    fn test_combine_with_hunks_or() {
        let hunks1 = vec![Range {
            start_byte: 10,
            end_byte: 20,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 0 },
        }];
        let hunks2 = vec![Range {
            start_byte: 30,
            end_byte: 40,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 0 },
        }];
        let result1 = MatchResult::Hunks(hunks1);
        let result2 = MatchResult::Hunks(hunks2);

        let combined = result1.combine_with(result2, &LogicalOperator::Or);

        if let MatchResult::Hunks(h) = combined {
            assert_eq!(h.len(), 2);
        } else {
            panic!("Expected Hunks result");
        }
    }

    #[test]
    fn test_file_context_content_caching() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("test.txt");
        fs::write(&file_path, "hello").unwrap();

        let mut context = FileContext::new(file_path.clone(), dir.path().to_path_buf());

        // First access should read from file
        assert_eq!(context.get_content().unwrap(), "hello");
        assert!(context.content.is_some());

        // Modify the file content
        fs::write(&file_path, "world").unwrap();

        // Second access should return cached content
        assert_eq!(context.get_content().unwrap(), "hello");
    }

    #[test]
    fn test_file_context_tree_caching() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("test.rs");
        fs::write(&file_path, "fn main() {}").unwrap();

        let mut context = FileContext::new(file_path, dir.path().to_path_buf());
        let language = language();

        // First access should parse and cache the tree
        let tree1_sexp = context.get_tree(language.clone()).unwrap().root_node().to_sexp();
        assert!(context.tree.is_some());

        // Second access should return the cached tree
        let tree2_sexp = context.get_tree(language).unwrap().root_node().to_sexp();

        assert_eq!(tree1_sexp, tree2_sexp);
    }
}

---

File: ./src/formatter.rs
---
use anyhow::{Context, Result};
use chrono::{DateTime, Local}; // For formatting timestamps
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use std::fs;
use std::io::Write;
use std::ops::Range as StdRange;
#[cfg(unix)]
use std::os::unix::fs::PermissionsExt; // For Unix permissions
use std::path::PathBuf;
use syntect::easy::HighlightLines;
use syntect::highlighting::{Style, ThemeSet};
use syntect::parsing::SyntaxSet;
use syntect::util::{as_24_bit_terminal_escaped, LinesWithEndings};
use tree_sitter::Range;

// We need to pass the format enum from main.rs
use crate::Format;

// Lazily load syntax and theme sets once.
static SYNTAX_SET: Lazy<SyntaxSet> = Lazy::new(SyntaxSet::load_defaults_newlines);
static THEME_SET: Lazy<ThemeSet> = Lazy::new(ThemeSet::load_defaults);

#[derive(Serialize, Deserialize, Debug, PartialEq)]
struct FileOutput {
    path: String,
    content: String,
}

fn print_markdown_format(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
    with_line_numbers: bool,
    with_headers: bool,
) -> Result<()> {
    for (i, (path, _)) in matching_files.iter().enumerate() {
        if with_headers {
            if i > 0 {
                writeln!(writer, "
---
")?;
            }
            writeln!(writer, "File: {}", path.display())?;
            writeln!(writer, "---")?;
        }
        let content = fs::read_to_string(path)?;
        let extension = path.extension().and_then(|s| s.to_str()).unwrap_or("");

        // Markdown format should always use fenced content, not ANSI colors.
        print_markdown_fenced_content(writer, &content, extension, with_line_numbers, 0)?;
    }
    Ok(())
}

fn print_cat_format(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
    with_line_numbers: bool,
    use_color: bool,
) -> Result<()> {
    for (path, _) in matching_files {
        let content = fs::read_to_string(path)?;
        if use_color {
            // To terminal
            print_highlighted_content(
                writer,
                &content,
                path.extension().and_then(|s| s.to_str()).unwrap_or(""),
                with_line_numbers,
                0,
            )?;
        } else {
            print_plain_content(writer, &content, with_line_numbers, 0)?; // To file/pipe
        }
    }
    Ok(())
}

fn print_json_format(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
) -> Result<()> {
    let mut outputs = Vec::new();
    for (path, _) in matching_files {
        let content = fs::read_to_string(path)
            .with_context(|| format!("Failed to read file for final output: {}", path.display()))?;
        outputs.push(FileOutput {
            path: path.to_string_lossy().to_string(),
            content,
        });
    }
    // Use to_writer_pretty for readable JSON output
    serde_json::to_writer_pretty(writer, &outputs)?;
    Ok(())
}

fn print_paths_format(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
) -> Result<()> {
    for (path, _) in matching_files {
        writeln!(writer, "{}", path.display())?;
    }
    Ok(())
}

fn print_find_format(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
) -> Result<()> {
    for (path, _) in matching_files {
        let metadata = fs::metadata(path)
            .with_context(|| format!("Failed to read metadata for {}", path.display()))?;
        let size = metadata.len();
        let modified: DateTime<Local> = DateTime::from(metadata.modified()?);

        // Get permissions (basic implementation)
        let perms = metadata.permissions();
        #[cfg(unix)]
        let mode = perms.mode();
        #[cfg(not(unix))]
        let mode = 0; // Placeholder for non-unix
        let perms_str = format_mode(mode);

        // Format size into human-readable string
        let size_str = format_size(size);

        // Format time
        let time_str = modified.format("%b %d %H:%M").to_string();

        writeln!(
            writer,
            "{:<12} {:>8} {} {}",
            perms_str,
            size_str,
            time_str,
            path.display()
        )?;
    }
    Ok(())
}

fn print_hunks_format(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
    with_line_numbers: bool,
    with_headers: bool,
    use_color: bool,
    context_lines: usize,
) -> Result<()> {
    for (i, (path, hunks)) in matching_files.iter().enumerate() {
        if with_headers {
            if i > 0 {
                writeln!(writer, "\n---\n")?;
            }
            writeln!(writer, "File: {}", path.display())?;
            writeln!(writer, "---")?;
        }
        let content = fs::read_to_string(path)?;
        let extension = path.extension().and_then(|s| s.to_str()).unwrap_or("");

        if hunks.is_empty() {
            // Boolean match, print the whole file
            print_content_with_style(writer, &content, extension, with_line_numbers, use_color, 0)?;
        } else {
            // Hunk match, print with context
            let lines: Vec<&str> = LinesWithEndings::from(&content).collect();
            let line_ranges = get_contextual_line_ranges(hunks, &lines, context_lines);

            for (i, range) in line_ranges.iter().enumerate() {
                if i > 0 {
                    writeln!(writer, "...")?;
                }
                let hunk_content = lines[range.clone()].join("");
                print_content_with_style(
                    writer,
                    &hunk_content,
                    extension,
                    with_line_numbers,
                    use_color,
                    range.start,
                )?;
            }
        }
    }
    Ok(())
}

/// Formats and prints the final output to a generic writer based on the chosen format.
pub fn print_output(
    writer: &mut impl Write,
    matching_files: &[(PathBuf, Vec<Range>)],
    format: &Format,
    with_line_numbers: bool,
    no_headers: bool,
    use_color: bool,
    context_lines: usize,
) -> Result<()> {
    match format {
        Format::Find => print_find_format(writer, matching_files)?,
        Format::Paths => print_paths_format(writer, matching_files)?,
        Format::Json => print_json_format(writer, matching_files)?,
        Format::Cat => print_cat_format(writer, matching_files, with_line_numbers, use_color)?,
        Format::Markdown => {
            print_markdown_format(writer, matching_files, with_line_numbers, !no_headers)?
        }
        Format::Hunks => print_hunks_format(
            writer,
            matching_files,
            with_line_numbers,
            !no_headers,
            use_color,
            context_lines,
        )?,
    }
    Ok(())
}

/// Helper to choose the correct printing function based on color/style preference.
fn print_content_with_style(
    writer: &mut impl Write,
    content: &str,
    extension: &str,
    with_line_numbers: bool,
    use_color: bool,
    start_line_number: usize,
) -> Result<()> {
    if use_color {
        print_highlighted_content(
            writer,
            content,
            extension,
            with_line_numbers,
            start_line_number,
        )
    } else {
        print_plain_content(writer, content, with_line_numbers, start_line_number)
    }
}

/// Given a set of byte-offset ranges, calculate the line number ranges including context,
/// and merge any overlapping ranges.
fn get_contextual_line_ranges(
    hunks: &[Range],
    lines: &[&str],
    context_lines: usize,
) -> Vec<StdRange<usize>> {
    if hunks.is_empty() || lines.is_empty() {
        return vec![];
    }

    let mut line_ranges = Vec::new();
    for hunk in hunks {
        let start_line = hunk.start_point.row;
        let end_line = hunk.end_point.row;

        let context_start = start_line.saturating_sub(context_lines);
        let context_end = (end_line + context_lines).min(lines.len() - 1);

        if context_end >= context_start {
            line_ranges.push(context_start..context_end + 1);
        }
    }
    line_ranges.sort_by_key(|r| r.start);

    // Merge overlapping ranges
    let mut merged_ranges = Vec::new();
    let mut iter = line_ranges.into_iter();
    if let Some(mut current) = iter.next() {
        for next in iter {
            if next.start <= current.end {
                current.end = current.end.max(next.end);
            } else {
                merged_ranges.push(current);
                current = next;
            }
        }
        merged_ranges.push(current);
    }
    merged_ranges
}

/// Prints syntax-highlighted content to the writer.
fn print_highlighted_content(
    writer: &mut impl Write,
    content: &str,
    extension: &str,
    with_line_numbers: bool,
    start_line_number: usize,
) -> Result<()> {
    let syntax = SYNTAX_SET
        .find_syntax_by_extension(extension)
        .unwrap_or_else(|| SYNTAX_SET.find_syntax_plain_text());

    let theme = &THEME_SET.themes["base16-ocean.dark"];
    let mut highlighter = HighlightLines::new(syntax, theme);

    for (i, line) in LinesWithEndings::from(content).enumerate() {
        if with_line_numbers {
            write!(writer, "{: >5} | ", start_line_number + i + 1)?;
        }
        let ranges: Vec<(Style, &str)> = highlighter.highlight_line(line, &SYNTAX_SET)?;
        let escaped = as_24_bit_terminal_escaped(&ranges[..], false);
        write!(writer, "{escaped}")?;
    }
    // Reset color at the end
    write!(writer, "\x1b[0m")?;
    Ok(())
}

/// Prints plain content, optionally with line numbers.
fn print_plain_content(
    writer: &mut impl Write,
    content: &str,
    with_line_numbers: bool,
    start_line_number: usize,
) -> Result<()> {
    for (i, line) in content.lines().enumerate() {
        if with_line_numbers {
            writeln!(writer, "{: >5} | {}", start_line_number + i + 1, line)?;
        } else {
            writeln!(writer, "{line}")?;
        }
    }
    Ok(())
}

/// Prints content inside a Markdown code fence.
fn print_markdown_fenced_content(
    writer: &mut impl Write,
    content: &str,
    extension: &str,
    with_line_numbers: bool,
    start_line_number: usize,
) -> Result<()> {
    writeln!(writer, "```{extension}")?;
    // print_plain_content handles line numbers correctly
    print_plain_content(writer, content, with_line_numbers, start_line_number)?;
    writeln!(writer, "```")?;
    Ok(())
}

fn format_mode(mode: u32) -> String {
    #[cfg(unix)]
    {
        let user_r = if mode & 0o400 != 0 { 'r' } else { '-' };
        let user_w = if mode & 0o200 != 0 { 'w' } else { '-' };
        let user_x = if mode & 0o100 != 0 { 'x' } else { '-' };
        let group_r = if mode & 0o040 != 0 { 'r' } else { '-' };
        let group_w = if mode & 0o020 != 0 { 'w' } else { '-' };
        let group_x = if mode & 0o010 != 0 { 'x' } else { '-' };
        let other_r = if mode & 0o004 != 0 { 'r' } else { '-' };
        let other_w = if mode & 0o002 != 0 { 'w' } else { '-' };
        let other_x = if mode & 0o001 != 0 { 'x' } else { '-' };
        format!("-{user_r}{user_w}{user_x}{group_r}{group_w}{group_x}{other_r}{other_w}{other_x}")
    }
    #[cfg(not(unix))]
    {
        // Basic fallback for non-Unix platforms
        if mode & 0o200 != 0 {
            "-rw-------"
        } else {
            "-r--------"
        }
        .to_string()
    }
}

fn format_size(bytes: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    if bytes >= GB {
        format!("{:.1}G", bytes as f64 / GB as f64)
    } else if bytes >= MB {
        format!("{:.1}M", bytes as f64 / MB as f64)
    } else if bytes >= KB {
        format!("{:.1}K", bytes as f64 / KB as f64)
    } else {
        format!("{bytes}B")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    // Helper to create a temp file with some content.
    fn create_temp_file_with_content(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(content.as_bytes()).unwrap();
        file
    }

    #[test]
    fn test_format_plain_cat_with_line_numbers() {
        let file = create_temp_file_with_content("a\nb");
        let paths = vec![(file.path().to_path_buf(), vec![])];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Cat, true, false, false, 0).unwrap();
        let output = String::from_utf8(writer).unwrap();
        assert_eq!(output, "    1 | a\n    2 | b\n");
    }

    #[test]
    fn test_format_paths() {
        let file1 = create_temp_file_with_content("a");
        let file2 = create_temp_file_with_content("b");
        let paths = vec![
            (file1.path().to_path_buf(), vec![]),
            (file2.path().to_path_buf(), vec![]),
        ];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Paths, false, false, false, 0).unwrap();
        let output = String::from_utf8(writer).unwrap();
        let expected = format!("{}\n{}\n", file1.path().display(), file2.path().display());
        assert_eq!(output, expected);
    }

    #[test]
    fn test_format_markdown_with_fences() {
        let file = create_temp_file_with_content("line 1");
        let paths = vec![(file.path().to_path_buf(), vec![])];
        let mut writer = Vec::new();

        // Test with use_color = false to get markdown fences
        print_output(
            &mut writer,
            &paths,
            &Format::Markdown,
            false,
            false,
            false,
            0,
        )
        .unwrap();

        let output = String::from_utf8(writer).unwrap();

        let expected_header = format!("File: {}\n---\n", file.path().display());
        assert!(output.starts_with(&expected_header));
        // The extension of a tempfile is random, so we check for an empty language hint
        assert!(output.contains("```\nline 1\n```\n"));
    }

    #[test]
    fn test_format_markdown_with_ansi_color() {
        let file = create_temp_file_with_content("fn main() {}");
        // Give it a .rs extension so syntect can find the grammar
        let rs_path = file.path().with_extension("rs");
        std::fs::rename(file.path(), &rs_path).unwrap();

        let paths = vec![(rs_path, vec![])];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Cat, false, false, true, 0).unwrap();
        let output = String::from_utf8(writer).unwrap();

        // Check for evidence of ANSI color, not the exact codes which can be brittle.
        assert!(output.contains("\x1b["), "Should contain ANSI escape codes");
        assert!(
            !output.contains("```"),
            "Should not contain markdown fences"
        );
    }

    #[test]
    fn test_format_markdown_ignores_color_flag() {
        let file = create_temp_file_with_content("fn main() {}");
        let paths = vec![(file.path().to_path_buf(), vec![])];
        let mut writer = Vec::new();

        // Test with use_color = true, which should be ignored for the Markdown format.
        print_output(&mut writer, &paths, &Format::Markdown, false, false, true, 0).unwrap();

        let output = String::from_utf8(writer).unwrap();

        // Check that the output is standard markdown and does not contain color codes.
        assert!(
            output.contains("```"),
            "Markdown format should use code fences"
        );
        assert!(
            !output.contains("\x1b["),
            "Markdown format should not contain ANSI escape codes"
        );
    }

    #[test]
    fn test_format_find() {
        let file = create_temp_file_with_content("hello");
        let paths = vec![(file.path().to_path_buf(), vec![])];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Find, false, false, false, 0).unwrap();
        let output = String::from_utf8(writer).unwrap();
        assert!(output.contains("B")); // Size
        assert!(output.contains(&file.path().display().to_string()));
    }
}

---

File: ./src/lib.rs
---
// Declare all our modules
pub mod commands;
pub mod config;
pub mod evaluator;
pub mod formatter;
pub mod parser;
pub mod predicates;

use anyhow::Result;
use clap::{Parser, Subcommand, ValueEnum};
use std::path::PathBuf;

// Bring our command functions into scope
use commands::{lang::run_lang, preset::run_preset, search::run_search};

// These structs and enums define the public API of our CLI.
// They need to be public so the `commands` modules can use them.
#[derive(Parser, Debug)]
#[command(
    version,
    about = "A fast, expressive, code-aware tool to find and dump file contents."
)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand, Debug)]
pub enum Commands {
    /// Search for files using a query (default command).
    #[command(visible_alias = "s")]
    Search(SearchArgs),
    /// List supported languages and their available predicates.
    #[command(visible_alias = "l")]
    Lang(LangArgs),
    /// Manage saved presets.
    #[command(visible_alias = "p")]
    Preset(PresetArgs),
}

#[derive(Debug, Clone, ValueEnum, Default, PartialEq)]
pub enum ColorChoice {
    #[default]
    Auto,
    Always,
    Never,
}

#[derive(Parser, Debug)]
pub struct SearchArgs {
    /// The query string to search for, using rdump Query Language (RQL).
    ///
    /// RQL supports logical operators (&, |, !), parentheses, and key:value predicates.
    /// Values with spaces must be quoted (e.g., contains:'fn main').
    ///
    /// METADATA PREDICATES:
    ///   ext:<str>          - File extension (e.g., "rs", "toml")
    ///   name:<glob>        - File name glob pattern (e.g., "test_*.rs")
    ///   path:<str>         - Substring in the full file path
    ///   in:<path>          - Directory path to search within
    ///   size:[>|<]<num>[kb|mb] - File size (e.g., ">10kb")
    ///   modified:[>|<]<num>[h|d|w] - Modified time (e.g., "<2d")
    ///
    /// CONTENT PREDICATES:
    ///   contains:<str>     - Literal string a file contains
    ///   matches:<regex>    - Regular expression a file's content matches
    ///
    #[doc = "CODE-AWARE PREDICATES for supported languages:"]
    ///   def:<str>          - A generic definition (class, struct, enum, etc.)
    ///   func:<str>         - A function or method
    ///   import:<str>       - An import or use statement
    ///   call:<str>         - A function or method call site
    ///
    /// GRANULAR DEFINITIONS:
    ///   class:<str>        - A class definition
    ///   struct:<str>       - A struct definition
    ///   enum:<str>         - An enum definition
    ///   interface:<str>    - An interface definition
    ///   trait:<str>        - A trait definition
    ///   type:<str>         - A type alias
    ///   impl:<str>         - An implementation block (e.g., `impl User`)
    ///   macro:<str>        - A macro definition
    ///
    /// SYNTACTIC CONTENT:
    ///   comment:<str>      - Text inside a comment (e.g., "TODO", "FIXME")
    ///   str:<str>          - Text inside a string literal
    ///
    #[doc = "REACT-SPECIFIC PREDICATES (.jsx, .tsx):"]
    ///   component:<str>    - A React component definition
    ///   element:<str>      - A JSX element/tag (e.g., `div`, `MyComponent`)
    ///   hook:<str>         - A React hook call (e.g., `useState`, `useEffect`)
    ///   customhook:<str>   - A custom hook definition (e.g., `useAuth`)
    ///   prop:<str>         - A prop being passed to a JSX element
    #[arg(verbatim_doc_comment, name = "QUERY")]
    pub query: String,
    #[arg(long, short)]
    pub preset: Vec<String>,
    #[arg(short, long, default_value = ".")]
    pub root: PathBuf,
    #[arg(short, long)]
    pub output: Option<PathBuf>,
    #[arg(short, long)]
    pub line_numbers: bool,
    #[arg(long, help = "Alias for --format=cat, useful for piping")]
    pub no_headers: bool,
    #[arg(long, value_enum, default_value_t = Format::Hunks)]
    pub format: Format,
    #[arg(long)]
    pub no_ignore: bool,
    #[arg(long)]
    pub hidden: bool,
    #[arg(long, value_enum, default_value_t = ColorChoice::Auto, help = "When to use syntax highlighting")]
    pub color: ColorChoice,
    #[arg(long)]
    pub max_depth: Option<usize>,
    #[arg(
        long,
        short = 'C',
        value_name = "LINES",
        help = "Show LINES of context around matches for --format=hunks"
    )]
    pub context: Option<usize>,

    /// List files with metadata instead of dumping content. Alias for --format=find
    #[arg(long)]
    pub find: bool,
}

#[derive(Parser, Debug)]
pub struct LangArgs {
    #[command(subcommand)]
    pub action: Option<LangAction>,
}

#[derive(Subcommand, Debug, Clone)]
pub enum LangAction {
    /// List all supported languages.
    List,
    /// Describe the predicates available for a specific language.
    Describe { language: String },
}

#[derive(Parser, Debug)]
pub struct PresetArgs {
    #[command(subcommand)]
    pub action: PresetAction,
}

#[derive(Subcommand, Debug, Clone)]
pub enum PresetAction {
    /// List all available presets.
    List,
    /// Add or update a preset in the global config file.
    Add {
        #[arg(required = true)]
        name: String,
        #[arg(required = true)]
        query: String,
    },
    /// Remove a preset from the global config file.
    Remove {
        #[arg(required = true)]
        name: String,
    },
}

#[derive(Debug, Clone, ValueEnum)]
pub enum Format {
    /// Show only the specific code blocks ("hunks") that match a semantic query
    Hunks,
    /// Human-readable markdown with file headers
    Markdown,
    /// Machine-readable JSON
    Json,
    /// A simple list of matching file paths
    Paths,
    /// Raw concatenated file content, for piping
    Cat,
    /// `ls`-like output with file metadata
    Find,
}

// This is the function that will be called from main.rs
pub fn run() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Search(args) => run_search(args),
        Commands::Lang(args) => {
            // Default to `list` if no subcommand is given for `lang`
            let action = args.action.unwrap_or(LangAction::List);
            run_lang(action)
        }
        Commands::Preset(args) => run_preset(args.action),
    }
}

---

File: ./src/main.rs
---
use anyhow::Result;
use rdump::run;

fn main() -> Result<()> {
    run()
}

---

File: ./src/parser.rs
---
use anyhow::{anyhow, Result};
use pest::iterators::{Pair, Pairs};
pub use pest::Parser;
use pest::pratt_parser::{Assoc, Op, PrattParser};
use pest_derive::Parser;

#[derive(Parser)]
#[grammar = "rql.pest"]
pub struct RqlParser;

lazy_static::lazy_static! {
    static ref PRATT_PARSER: PrattParser<Rule> = {
        use Assoc::*;
        use Rule::*;

        PrattParser::new()
            .op(Op::infix(OR, Left))
            .op(Op::infix(AND, Left))
    };
}

#[derive(Debug, PartialEq, Eq, Hash, Clone)]
pub enum PredicateKey {
    Ext,
    Name,
    Path,
    Contains,
    Matches,
    Size,
    Modified,
    In,
    // --- SEMANTIC PREDICATES ---
    // Generic
    Def,
    Func,
    Import,
    // Granular Definitions
    Class,
    Struct,
    Enum,
    Interface,
    Trait,
    Type,
    Impl,
    Macro,
    // Syntactic Content
    Comment,
    Str,
    // Usage
    Call,
    // --- React-specific Predicates ---
    Component,
    Element,
    Hook,
    CustomHook,
    Prop,
    // A key for testing or unknown predicates
    Other(String),
}

impl AsRef<str> for PredicateKey {
    fn as_ref(&self) -> &str {
        match self {
            PredicateKey::Ext => "ext",
            PredicateKey::Name => "name",
            PredicateKey::Path => "path",
            PredicateKey::Contains => "contains",
            PredicateKey::Matches => "matches",
            PredicateKey::Size => "size",
            PredicateKey::Modified => "modified",
            PredicateKey::In => "in",
            PredicateKey::Def => "def",
            PredicateKey::Func => "func",
            PredicateKey::Import => "import",
            PredicateKey::Class => "class",
            PredicateKey::Struct => "struct",
            PredicateKey::Enum => "enum",
            PredicateKey::Interface => "interface",
            PredicateKey::Trait => "trait",
            PredicateKey::Type => "type",
            PredicateKey::Impl => "impl",
            PredicateKey::Macro => "macro",
            PredicateKey::Comment => "comment",
            PredicateKey::Str => "str",
            PredicateKey::Call => "call",
            PredicateKey::Component => "component",
            PredicateKey::Element => "element",
            PredicateKey::Hook => "hook",
            PredicateKey::CustomHook => "customhook",
            PredicateKey::Prop => "prop",
            PredicateKey::Other(s) => s.as_str(),
        }
    }
}

impl From<&str> for PredicateKey {
    fn from(s: &str) -> Self {
        match s {
            "ext" => Self::Ext,
            "name" => Self::Name,
            "path" => Self::Path,
            "contains" => Self::Contains,
            "matches" => Self::Matches,
            "size" => Self::Size,
            "modified" => Self::Modified,
            "in" => Self::In,
            // --- SEMANTIC ---
            "def" => Self::Def,
            "func" => Self::Func,
            "import" => Self::Import,
            "class" => Self::Class,
            "struct" => Self::Struct,
            "enum" => Self::Enum,
            "interface" => Self::Interface,
            "trait" => Self::Trait,
            "type" => Self::Type,
            "impl" => Self::Impl,
            "macro" => Self::Macro,
            "comment" => Self::Comment,
            "str" => Self::Str,
            "call" => Self::Call,
            // --- REACT ---
            "component" => Self::Component,
            "element" => Self::Element,
            "hook" => Self::Hook,
            "customhook" => Self::CustomHook,
            "prop" => Self::Prop,
            // Any other key is captured here.
            other => Self::Other(other.to_string()),
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AstNode {
    Predicate(PredicateKey, String),
    LogicalOp(LogicalOperator, Box<AstNode>, Box<AstNode>),
    Not(Box<AstNode>),
}

#[derive(Debug, PartialEq, Clone)]
pub enum LogicalOperator {
    And,
    Or,
}

pub fn parse_query(query: &str) -> Result<AstNode> {
    if query.trim().is_empty() {
        return Err(anyhow!("Query cannot be empty."));
    }

    match RqlParser::parse(Rule::query, query) {
        Ok(mut pairs) => {
            // Get the first and only pair, which is the `query` rule.
            let query_pair = pairs.next().unwrap();
            // The `query` rule contains an `expression`.
            let expression_pairs = query_pair.into_inner();
            // Start the AST build from the expression.
            build_ast_from_expression(expression_pairs)
        }
        Err(e) => Err(anyhow!("Invalid query syntax:\n{}", e)),
    }
}

// Pratt parser logic lives here. It consumes an expression.
fn build_ast_from_expression(pairs: Pairs<Rule>) -> Result<AstNode> {
    PRATT_PARSER
        .map_primary(|primary| build_ast_from_term(primary))
        .map_infix(|lhs, op, rhs| {
            let op = match op.as_rule() {
                Rule::AND => LogicalOperator::And,
                Rule::OR => LogicalOperator::Or,
                _ => unreachable!(),
            };
            Ok(AstNode::LogicalOp(op, Box::new(lhs?), Box::new(rhs?)))
        })
        .parse(pairs)
}

// This function handles the "leaves" or primary parts of our grammar.
fn build_ast_from_term(pair: Pair<Rule>) -> Result<AstNode> {
    match pair.as_rule() {
        Rule::predicate => {
            // A simple predicate like `key:value`.
            let mut inner = pair.into_inner().next().unwrap().into_inner();
            let key = PredicateKey::from(inner.next().unwrap().as_str());
            let value = unescape_value(inner.next().unwrap().as_str());
            Ok(AstNode::Predicate(key, value))
        }
        Rule::expression => {
            // A parenthesized expression, like `(a | b)`. Recurse.
            build_ast_from_expression(pair.into_inner())
        }
        Rule::term => {
            // A term can be negated. Handle the `NOT` operator here.
            let mut inner = pair.into_inner();
            let first_child = inner.next().unwrap();
            if first_child.as_rule() == Rule::NOT {
                let negated_term = inner.next().unwrap();
                let ast = build_ast_from_term(negated_term)?;
                Ok(AstNode::Not(Box::new(ast)))
            } else {
                // Not negated, just a regular term. Descend.
                build_ast_from_term(first_child)
            }
        }
        Rule::factor => {
            // A factor is a container for a predicate or a parenthesized expression. Descend.
            build_ast_from_term(pair.into_inner().next().unwrap())
        }
        _ => Err(anyhow!("Unknown term rule: {:?}", pair.as_rule())),
    }
}


fn unescape_value(value: &str) -> String {
    let quote_char = value.chars().next();
    if quote_char == Some('"') || quote_char == Some('\'') {
        let inner = &value[1..value.len() - 1];
        let mut unescaped = String::with_capacity(inner.len());
        let mut chars = inner.chars();
        while let Some(c) = chars.next() {
            if c == '\\' {
                if let Some(next_c) = chars.next() {
                    unescaped.push(next_c);
                }
            } else {
                unescaped.push(c);
            }
        }
        return unescaped;
    }
    value.to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    // Helper to create a predicate node for cleaner tests.
    fn predicate(key: PredicateKey, value: &str) -> Box<AstNode> {
        Box::new(AstNode::Predicate(key, value.to_string()))
    }

    #[test]
    fn test_parse_simple_predicate() {
        let ast = parse_query("ext:rs").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Ext, "rs"));
    }

    #[test]
    fn test_parse_predicate_with_quoted_value() {
        let ast = parse_query("name:\"foo bar\"").unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Name, "foo bar"));
    }

    #[test]
    fn test_parse_logical_and() {
        let ast = parse_query("ext:rs & name:\"foo\"").unwrap();
        assert_eq!(
            ast,
            AstNode::LogicalOp(
                LogicalOperator::And,
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Name, "foo")
            )
        );
    }

    #[test]
    fn test_parse_logical_or() {
        let ast = parse_query("ext:rs | ext:toml").unwrap();
        assert_eq!(
            ast,
            AstNode::LogicalOp(
                LogicalOperator::Or,
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Ext, "toml")
            )
        );
    }

    #[test]
    fn test_parse_negation() {
        let ast = parse_query("!ext:rs").unwrap();
        assert_eq!(ast, AstNode::Not(predicate(PredicateKey::Ext, "rs")));
    }

    #[test]
    fn test_parse_complex_query() {
        let ast = parse_query("ext:rs & (name:\"foo\" | name:\"bar\") & !path:tests").unwrap();
        let inner_or = AstNode::LogicalOp(
            LogicalOperator::Or,
            predicate(PredicateKey::Name, "foo"),
            predicate(PredicateKey::Name, "bar"),
        );
        let and_with_or = AstNode::LogicalOp(
            LogicalOperator::And,
            predicate(PredicateKey::Ext, "rs"),
            Box::new(inner_or),
        );
        let final_ast = AstNode::LogicalOp(
            LogicalOperator::And,
            Box::new(and_with_or),
            Box::new(AstNode::Not(predicate(PredicateKey::Path, "tests"))),
        );
        assert_eq!(ast, final_ast);
    }

    #[test]
    fn test_unescape_value() {
        assert_eq!(unescape_value(r#""hello \"world\"""#), "hello \"world\"");
        assert_eq!(unescape_value(r#"'hello \'world\''"#), "hello 'world'");
        assert_eq!(unescape_value(r#""a \\ b""#), "a \\ b");
        assert_eq!(unescape_value("no_quotes"), "no_quotes");
    }

    #[test]
    fn test_parse_predicate_with_special_chars_in_value() {
        let ast = parse_query(r#"name:"foo&bar""#).unwrap();
        assert_eq!(ast, *predicate(PredicateKey::Name, "foo&bar"));
    }

    #[test]
    fn test_parse_semantic_predicates() {
        let ast_def = parse_query("def:User").unwrap();
        assert_eq!(ast_def, *predicate(PredicateKey::Def, "User"));

        let ast_func = parse_query("func:get_user").unwrap();
        assert_eq!(ast_func, *predicate(PredicateKey::Func, "get_user"));

        let ast_import = parse_query("import:serde").unwrap();
        assert_eq!(ast_import, *predicate(PredicateKey::Import, "serde"));
    }

    #[test]
    fn test_parse_granular_and_syntactic_predicates() {
        assert_eq!(
            parse_query("class:Foo").unwrap(),
            *predicate(PredicateKey::Class, "Foo")
        );
        assert_eq!(
            parse_query("struct:Bar").unwrap(),
            *predicate(PredicateKey::Struct, "Bar")
        );
        assert_eq!(
            parse_query("comment:TODO").unwrap(),
            *predicate(PredicateKey::Comment, "TODO")
        );
        assert_eq!(
            parse_query("str:'api_key'").unwrap(),
            *predicate(PredicateKey::Str, "api_key")
        );
        assert_eq!(
            parse_query("call:my_func").unwrap(),
            *predicate(PredicateKey::Call, "my_func")
        );
    }

    #[test]
    fn test_parse_react_and_new_rust_predicates() {
        assert_eq!(
            parse_query("component:App").unwrap(),
            *predicate(PredicateKey::Component, "App")
        );
        assert_eq!(
            parse_query("hook:useState").unwrap(),
            *predicate(PredicateKey::Hook, "useState")
        );
        assert_eq!(
            parse_query("macro:my_macro").unwrap(),
            *predicate(PredicateKey::Macro, "my_macro")
        );
        assert_eq!(
            parse_query("impl:User").unwrap(),
            *predicate(PredicateKey::Impl, "User")
        );
    }

    #[test]
    fn test_error_on_trailing_operator() {
        let result = parse_query("ext:rs &");
        let err = result.unwrap_err();
        assert!(err.to_string().contains("Invalid query syntax:"));
        assert!(err.to_string().contains("expected")); // Pest's pointer is still useful
    }

    #[test]
    fn test_error_on_missing_value() {
        let result = parse_query("ext:");
        let err = result.unwrap_err();
        assert!(err.to_string().contains("Invalid query syntax:"));
    }

    #[test]
    fn test_error_on_unclosed_parenthesis() {
        let result = parse_query("(ext:rs | path:src");
        let err = result.unwrap_err();
        assert!(err.to_string().contains("Invalid query syntax:"));
    }

    #[test]
    fn test_error_on_empty_query() {
        let result = parse_query("");
        assert_eq!(result.unwrap_err().to_string(), "Query cannot be empty.");
    }

    #[test]
    fn test_error_on_whitespace_query() {
        let result = parse_query("   ");
        assert_eq!(result.unwrap_err().to_string(), "Query cannot be empty.");
    }

    #[test]
    fn test_parse_keyword_operators() {
        // AND
        let ast_and = parse_query("ext:rs and name:\"foo\"").unwrap();
        assert_eq!(
            ast_and,
            AstNode::LogicalOp(
                LogicalOperator::And,
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Name, "foo")
            )
        );

        // OR
        let ast_or = parse_query("ext:rs or ext:toml").unwrap();
        assert_eq!(
            ast_or,
            AstNode::LogicalOp(
                LogicalOperator::Or,
                predicate(PredicateKey::Ext, "rs"),
                predicate(PredicateKey::Ext, "toml")
            )
        );

        // NOT
        let ast_not = parse_query("not ext:rs").unwrap();
        assert_eq!(ast_not, AstNode::Not(predicate(PredicateKey::Ext, "rs")));
    }

    #[test]
    fn test_parse_mixed_operators() {
        let ast = parse_query("ext:rs and (name:foo or name:bar) & not path:tests").unwrap();
        let inner_or = AstNode::LogicalOp(
            LogicalOperator::Or,
            predicate(PredicateKey::Name, "foo"),
            predicate(PredicateKey::Name, "bar"),
        );
        let and_with_or = AstNode::LogicalOp(
            LogicalOperator::And,
            predicate(PredicateKey::Ext, "rs"),
            Box::new(inner_or),
        );
        let final_ast = AstNode::LogicalOp(
            LogicalOperator::And,
            Box::new(and_with_or),
            Box::new(AstNode::Not(predicate(PredicateKey::Path, "tests"))),
        );
        assert_eq!(ast, final_ast);
    }

    #[test]
    fn test_parse_unknown_predicate() {
        let ast = parse_query("unknown:predicate").unwrap();
        assert_eq!(
            ast,
            *predicate(PredicateKey::Other("unknown".to_string()), "predicate")
        );
    }
}

---

File: ./src/predicates/code_aware/mod.rs
---
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use crate::predicates::PredicateEvaluator;
use anyhow::{Context, Result};
use tree_sitter::{Query, QueryCursor};

pub mod profiles;

/// The evaluator that uses tree-sitter to perform code-aware queries.
#[derive(Debug, Clone)]
pub struct CodeAwareEvaluator;

impl PredicateEvaluator for CodeAwareEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        // 1. Determine the language from the file extension.
        let extension = context
            .path
            .extension()
            .and_then(|s| s.to_str())
            .unwrap_or("");
        let binding = profiles::list_language_profiles();
        let profile = match binding.iter().find(|p| p.extensions.contains(&extension)) {
            Some(p) => p,
            None => return Ok(MatchResult::Boolean(false)), // Not a supported language for this predicate.
        };

        // 2. Get the tree-sitter query string for the specific predicate.
        let ts_query_str = match profile.queries.get(key) {
            Some(q) if !q.is_empty() => q,
            _ => return Ok(MatchResult::Boolean(false)), // This predicate is not implemented for this language yet.
        };

        // 3. Get content and lazily get the parsed tree from the file context.
        let content = context.get_content()?.to_string(); // Clone to avoid borrow issues
        let tree = match context.get_tree(profile.language.clone()) {
            Ok(tree) => tree,
            Err(e) => {
                eprintln!(
                    "Warning: Failed to parse {}: {}. Skipping.",
                    context.path.display(),
                    e
                );
                return Ok(MatchResult::Boolean(false));
            }
        };

        // 4. Compile the tree-sitter query.
        let query = Query::new(&profile.language, ts_query_str)
            .with_context(|| format!("Failed to compile tree-sitter query for key {key:?}"))?;
        let mut cursor = QueryCursor::new();
        let mut ranges = Vec::new();

        // 5. Execute the query and check for a match.
        let captures = cursor.matches(&query, tree.root_node(), content.as_bytes());

        for m in captures {
            for capture in m.captures {
                // We only care about nodes captured with the name `@match`.
                let capture_name = &query.capture_names()[capture.index as usize];
                if *capture_name != "match" {
                    continue;
                }

                let captured_node = capture.node;
                let captured_text = captured_node.utf8_text(content.as_bytes())?;

                // Use the correct matching strategy based on the predicate type.
                let is_match = match key {
                    // Content-based predicates check for substrings.
                    PredicateKey::Import | PredicateKey::Comment | PredicateKey::Str => {
                        captured_text.contains(value)
                    }
                    // Hook predicates can match any hook (`hook:.`) or a specific one
                    PredicateKey::Hook | PredicateKey::CustomHook => {
                        value == "." || captured_text == value
                    }
                    // Definition-based predicates require an exact match on the identifier, unless a wildcard is used.
                    _ => value == "." || captured_text == value,
                };

                if is_match {
                    ranges.push(captured_node.range());
                }
            }
        }

        Ok(MatchResult::Hunks(ranges))
    }
}

---

File: ./src/predicates/code_aware/profiles/go.rs
---
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Go language.
pub(super) fn create_go_profile() -> LanguageProfile {
    let language = tree_sitter_go::language();
    let mut queries = HashMap::new();

    let type_query = "(type_declaration (type_spec name: (type_identifier) @match))";
    let func_query = "[ (function_declaration name: (identifier) @match) (method_declaration name: (field_identifier) @match) ]";

    // --- Definitions ---
    let struct_query =
        "(type_declaration (type_spec name: (type_identifier) @match type: (struct_type)))";
    let interface_query =
        "(type_declaration (type_spec name: (type_identifier) @match type: (interface_type)))";

    queries.insert(PredicateKey::Def, [type_query, func_query].join("\n"));
    queries.insert(PredicateKey::Struct, struct_query.to_string());
    queries.insert(PredicateKey::Interface, interface_query.to_string());
    queries.insert(PredicateKey::Type, type_query.to_string());

    // --- Functions & Calls ---
    queries.insert(PredicateKey::Func, func_query.to_string());
    queries.insert(PredicateKey::Call, "(call_expression function: [ (identifier) @match (selector_expression field: (field_identifier) @match) ])".to_string());

    // --- Other ---
    queries.insert(
        PredicateKey::Import,
        "(import_declaration) @match".to_string(),
    );
    queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
    queries.insert(
        PredicateKey::Str,
        "[ (interpreted_string_literal) @match (raw_string_literal) @match ]".to_string(),
    );

    LanguageProfile {
        name: "Go",
        extensions: vec!["go"],
        language,
        queries,
    }
}

---

File: ./src/predicates/code_aware/profiles/java.rs
---
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Java language.
pub(super) fn create_java_profile() -> LanguageProfile {
    let language = tree_sitter_java::language();
    let mut queries = HashMap::new();

    // --- Definitions ---
    let class_query = "(class_declaration name: (identifier) @match)";
    let interface_query = "(interface_declaration name: (identifier) @match)";
    let enum_query = "(enum_declaration name: (identifier) @match)";

    queries.insert(
        PredicateKey::Def,
        format!("[ {class_query} {interface_query} {enum_query} ]"),
    );
    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Interface, interface_query.to_string());
    queries.insert(PredicateKey::Enum, enum_query.to_string());

    // --- Functions & Calls ---
    queries.insert(PredicateKey::Func, "[ (method_declaration name: (identifier) @match) (constructor_declaration name: (identifier) @match) ]".to_string());
    queries.insert(PredicateKey::Call, "[ (method_invocation name: (identifier) @match) (object_creation_expression type: (type_identifier) @match) ]".to_string());

    // --- Other ---
    queries.insert(
        PredicateKey::Import,
        "(import_declaration) @match".to_string(),
    );
    queries.insert(
        PredicateKey::Comment,
        "[(line_comment) @match (block_comment) @match]".to_string(),
    );
    queries.insert(PredicateKey::Str, "(string_literal) @match".to_string());

    LanguageProfile {
        name: "Java",
        extensions: vec!["java"],
        language,
        queries,
    }
}

---

File: ./src/predicates/code_aware/profiles/javascript.rs
---
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the JavaScript language.
pub(super) fn create_javascript_profile() -> LanguageProfile {
    let language = tree_sitter_javascript::language();
    let mut queries = HashMap::new();

    let class_query = "(class_declaration name: (identifier) @match)";
    let func_query = "[ (function_declaration name: (identifier) @match) (method_definition name: (property_identifier) @match) ]";

    queries.insert(PredicateKey::Def, [class_query, func_query].join("\n"));
    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Func, func_query.to_string());

    queries.insert(
        PredicateKey::Import,
        "(import_statement) @match".to_string(),
    );
    queries.insert(
       PredicateKey::Call,
       "[ (call_expression function: [ (identifier) @match (member_expression property: (property_identifier) @match) ]) (new_expression constructor: (identifier) @match) ]".to_string()
   );

    queries.insert(
        PredicateKey::Comment,
        "[(comment) @match (regex) @match]".to_string(),
    ); // JS Regexes are basically comments
    queries.insert(
        PredicateKey::Str,
        "[(string) @match (template_string) @match]".to_string(),
    );

    // --- React Hook Queries ---
    let hook_query = "
        (call_expression
            function: (identifier) @match
            (#match? @match \"^(use)\")
        )
    ";
    let custom_hook_query = r#"
[
  (function_declaration
    name: (identifier) @match)
  (lexical_declaration
    (variable_declarator
      name: (identifier) @match
      value: (arrow_function)))
  (export_statement
    declaration: [
      (function_declaration
        name: (identifier) @match)
      (lexical_declaration
        (variable_declarator
          name: (identifier) @match
          value: (arrow_function)))
    ])
]
(#match? @match "^use[A-Z]")
"#;
    queries.insert(PredicateKey::Hook, hook_query.to_string());
    queries.insert(PredicateKey::CustomHook, custom_hook_query.to_string());

    LanguageProfile {
        name: "JavaScript",
        extensions: vec!["js"],
        language,
        queries,
    }
}

---

File: ./src/predicates/code_aware/profiles/mod.rs
---
use crate::parser::PredicateKey;
use once_cell::sync::Lazy;
use std::collections::HashMap;

mod go;
mod java;
mod javascript;
mod python;
mod react; // Add react module
mod rust;
mod typescript;

/// Defines the tree-sitter queries and metadata for a specific language.
pub struct LanguageProfile {
    pub name: &'static str,
    pub extensions: Vec<&'static str>,
    pub(super) language: tree_sitter::Language,
    pub queries: HashMap<PredicateKey, String>,
}

pub(super) static LANGUAGE_PROFILES: Lazy<HashMap<&'static str, LanguageProfile>> =
    Lazy::new(|| {
        let mut m = HashMap::new();
        m.insert("rs", rust::create_rust_profile());
        m.insert("py", python::create_python_profile());
        m.insert("go", go::create_go_profile());
        m.insert("java", java::create_java_profile());
        m.insert("ts", typescript::create_typescript_profile());
        m.insert("js", javascript::create_javascript_profile());
        m.insert("jsx", react::create_react_profile());
        m
    });

/// Returns a list of all configured language profiles.
pub fn list_language_profiles() -> Vec<&'static LanguageProfile> {
    LANGUAGE_PROFILES.values().collect()
}

---

File: ./src/predicates/code_aware/profiles/python.rs
---
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Python language.
pub(super) fn create_python_profile() -> LanguageProfile {
    let language = tree_sitter_python::language();
    let mut queries = HashMap::new();

    let class_query = "(class_definition name: (identifier) @match)";
    let func_query = "(function_definition name: (identifier) @match)";

    queries.insert(PredicateKey::Def, [class_query, func_query].join("\n"));
    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Func, func_query.to_string());

    // Query for `import` and `from ... import` statements.
    queries.insert(
        PredicateKey::Import,
        "
        [
            (import_statement) @match
            (import_from_statement) @match
        ]
        "
        .to_string(),
    );

    // Query for function and method call sites.
    queries.insert(
        PredicateKey::Call,
        "
       (call
           function: [
               (identifier) @match
               (attribute attribute: (identifier) @match)
           ]
       )
       "
        .to_string(),
    );

    queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
    queries.insert(PredicateKey::Str, "(string) @match".to_string());

    LanguageProfile {
        name: "Python",
        extensions: vec!["py"],
        language,
        queries,
    }
}

---

File: ./src/predicates/code_aware/profiles/react.rs
---
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the React (JSX/TSX).
pub(super) fn create_react_profile() -> LanguageProfile {
    let language = tree_sitter_typescript::language_tsx();
    let mut queries = HashMap::new();

    // --- Component & Element Queries ---
    let component_query = "
        [
            (class_declaration name: (type_identifier) @match)
            (function_declaration name: (identifier) @match)
            (lexical_declaration
                (variable_declarator
                    name: (identifier) @match
                    value: (arrow_function)
                )
            )
            (export_statement
                declaration: (lexical_declaration
                    (variable_declarator
                        name: (identifier) @match
                        value: (call_expression
                            function: (member_expression
                                property: (property_identifier) @_prop
                            )
                            (#eq? @_prop \"memo\")
                        )
                    )
                )
            )
            (lexical_declaration
                (variable_declarator
                    name: (identifier) @match
                    value: (call_expression
                        function: (member_expression
                            property: (property_identifier) @_prop
                        )
                        (#eq? @_prop \"memo\")
                    )
                )
            )
        ]
    ";
    let element_query = "
        [
            (jsx_opening_element name: (_) @match)
            (jsx_self_closing_element name: (_) @match)
        ]
    ";
    queries.insert(PredicateKey::Component, component_query.to_string());
    queries.insert(PredicateKey::Element, element_query.to_string());

    // --- Hook Queries ---
    let hook_query = "
        (call_expression
            function: (identifier) @match
            (#match? @match \"^(use)\")
        )
    ";
    let custom_hook_query = r#"
[
  (function_declaration
    name: (identifier) @match)
  (lexical_declaration
    (variable_declarator
      name: (identifier) @match
      value: (arrow_function)))
  (export_statement
    declaration: [
      (function_declaration
        name: (identifier) @match)
      (lexical_declaration
        (variable_declarator
          name: (identifier) @match
          value: (arrow_function)))
    ])
]
(#match? @match "^use[A-Z]")
"#;
    queries.insert(PredicateKey::Hook, hook_query.to_string());
    queries.insert(PredicateKey::CustomHook, custom_hook_query.to_string());

    // --- Prop Query ---
    let prop_query = "(jsx_attribute (property_identifier) @match)";
    queries.insert(PredicateKey::Prop, prop_query.to_string());

    // --- Generic Queries (reusing from TS) ---
    queries.insert(
        PredicateKey::Import,
        "(import_statement) @match".to_string(),
    );
    queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
    queries.insert(
        PredicateKey::Str,
        "[(string) @match (template_string) @match]".to_string(),
    );

    LanguageProfile {
        name: "React",
        extensions: vec!["jsx", "tsx"],
        language,
        queries,
    }
}

---

File: ./src/predicates/code_aware/profiles/rust.rs
---
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Rust language.
pub(super) fn create_rust_profile() -> LanguageProfile {
    let language = tree_sitter_rust::language();
    let mut queries = HashMap::new();

    let struct_query = "(struct_item name: (_) @match)";
    let enum_query = "(enum_item name: (_) @match)";
    let trait_query = "(trait_item name: (_) @match)";
    let type_query = "(type_item name: (type_identifier) @match)";
    let impl_query = "(impl_item type: (type_identifier) @match)";
    let macro_query = "(macro_definition name: (identifier) @match)";

    let def_query = [struct_query, enum_query, trait_query, type_query].join("\n");

    queries.insert(PredicateKey::Def, def_query);
    queries.insert(PredicateKey::Struct, struct_query.to_string());
    queries.insert(PredicateKey::Enum, enum_query.to_string());
    queries.insert(PredicateKey::Trait, trait_query.to_string());
    queries.insert(PredicateKey::Type, type_query.to_string());
    queries.insert(PredicateKey::Impl, impl_query.to_string());
    queries.insert(PredicateKey::Macro, macro_query.to_string());

    // Query for standalone functions and methods in traits or impls.
    queries.insert(
        PredicateKey::Func,
        "
        [
            (function_item name: (identifier) @match)
            (function_signature_item name: (identifier) @match)
        ]
        "
        .to_string(),
    );
    // Query for the entire `use` declaration. We will match against its text content.
    queries.insert(
        PredicateKey::Import,
        "\n        (use_declaration) @match\n        "
        .to_string(),
    );

    // Query for function and method call sites.
    queries.insert(
        PredicateKey::Call,
        "\n       (call_expression\n           function: [\n               (identifier) @match\n               (field_expression field: (field_identifier) @match)\n           ]\n       )\n       (macro_invocation macro: (identifier) @match)\n       "
        .to_string(),
    );

    queries.insert(
        PredicateKey::Comment,
        "[(line_comment) @match (block_comment) @match]".to_string(),
    );
    queries.insert(
        PredicateKey::Str,
        "[(string_literal) @match (raw_string_literal) @match]".to_string(),
    );

    LanguageProfile {
        name: "Rust",
        extensions: vec!["rs"],
        language,
        queries,
    }
}

---

File: ./src/predicates/code_aware/profiles/typescript.rs
---
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the TypeScript language.
pub(super) fn create_typescript_profile() -> LanguageProfile {
    let language = tree_sitter_typescript::language_typescript();
    let mut queries = HashMap::new();

    let class_query = "(class_declaration name: (type_identifier) @match)";
    let interface_query = "(interface_declaration name: (type_identifier) @match)";
    let type_query = "(type_alias_declaration name: (type_identifier) @match)";
    let enum_query = "(enum_declaration name: (identifier) @match)";

    let def_query = [class_query, interface_query, type_query, enum_query].join("\n");
    queries.insert(PredicateKey::Def, def_query);

    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Interface, interface_query.to_string());
    queries.insert(PredicateKey::Type, type_query.to_string());
    queries.insert(PredicateKey::Enum, enum_query.to_string());

    queries.insert(PredicateKey::Func, "[ (function_declaration name: (identifier) @match) (method_definition name: (property_identifier) @match) ]".to_string());
    queries.insert(
        PredicateKey::Import,
        "(import_statement) @match".to_string(),
    );
    queries.insert(
       PredicateKey::Call,
       "[ (call_expression function: [ (identifier) @match (member_expression property: (property_identifier) @match) ]) (new_expression constructor: [ (identifier) @match (type_identifier) @match ]) ]".to_string()
   );

    queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
    queries.insert(
        PredicateKey::Str,
        "[(string) @match (template_string) @match]".to_string(),
    );

    // --- React Hook Queries ---
    let hook_query = "
        (call_expression
            function: (identifier) @match
            (#match? @match \"^(use)\")
        )
    ";
    let custom_hook_query = r#"
[
  (function_declaration
    name: (identifier) @match)
  (lexical_declaration
    (variable_declarator
      name: (identifier) @match
      value: (arrow_function)))
  (export_statement
    declaration: [
      (function_declaration
        name: (identifier) @match)
      (lexical_declaration
        (variable_declarator
          name: (identifier) @match
          value: (arrow_function)))
    ])
]
(#match? @match "^use[A-Z]")
"#;
    queries.insert(PredicateKey::Hook, hook_query.to_string());
    queries.insert(PredicateKey::CustomHook, custom_hook_query.to_string());

    LanguageProfile {
        name: "TypeScript",
        extensions: vec!["ts"],
        language,
        queries,
    }
}

---

File: ./src/predicates/contains.rs
---
use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;
use tree_sitter::Range;

pub(super) struct ContainsEvaluator;

impl PredicateEvaluator for ContainsEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let content = context.get_content()?;
        let mut ranges = Vec::new();
        for (i, line) in content.lines().enumerate() {
            if line.to_lowercase().contains(&value.to_lowercase()) {
                let start_byte = content.lines().take(i).map(|l| l.len() + 1).sum();
                let end_byte = start_byte + line.len();
                let range = Range {
                    start_byte,
                    end_byte,
                    start_point: tree_sitter::Point { row: i, column: 0 },
                    end_point: tree_sitter::Point {
                        row: i,
                        column: line.len(),
                    },
                };
                ranges.push(range);
            }
        }
        Ok(MatchResult::Hunks(ranges))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use std::path::PathBuf;
    use tempfile::NamedTempFile;
    fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }
    #[test]
    fn test_contains_evaluator() {
        let file = create_temp_file("Hello world\nThis is a test.");
        let mut context = FileContext::new(file.path().to_path_buf(), PathBuf::from("/"));
        let evaluator = ContainsEvaluator;
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Contains, "world")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Contains, "is a test")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Contains, "goodbye")
            .unwrap()
            .is_match());
    }
}

---

File: ./src/predicates/ext.rs
---
use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct ExtEvaluator;
impl PredicateEvaluator for ExtEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let file_ext = context
            .path
            .extension()
            .and_then(|s| s.to_str())
            .unwrap_or("");
        Ok(MatchResult::Boolean(file_ext.eq_ignore_ascii_case(value)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_ext_evaluator() {
        let mut context_rs = FileContext::new(PathBuf::from("main.rs"), PathBuf::from("/"));
        let mut context_toml = FileContext::new(PathBuf::from("Cargo.TOML"), PathBuf::from("/"));
        let mut context_no_ext = FileContext::new(PathBuf::from("README"), PathBuf::from("/"));
        let mut context_dotfile = FileContext::new(PathBuf::from(".bashrc"), PathBuf::from("/"));

        let evaluator = ExtEvaluator;
        assert!(evaluator
            .evaluate(&mut context_rs, &PredicateKey::Ext, "rs")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context_rs, &PredicateKey::Ext, "toml")
            .unwrap()
            .is_match());
        assert!(
            evaluator
                .evaluate(&mut context_toml, &PredicateKey::Ext, "toml")
                .unwrap()
                .is_match(),
            "Should be case-insensitive"
        );
        assert!(!evaluator
            .evaluate(&mut context_no_ext, &PredicateKey::Ext, "rs")
            .unwrap()
            .is_match());
        assert!(
            !evaluator
                .evaluate(&mut context_dotfile, &PredicateKey::Ext, "bashrc")
                .unwrap()
                .is_match(),
            "Dotfiles should have no extension"
        );
    }
}

---

File: ./src/predicates/helpers.rs
---
use anyhow::{anyhow, Result};
use chrono::{Local, NaiveDate, NaiveDateTime, NaiveTime, TimeZone};
use std::time::{Duration, SystemTime};

pub(super) fn parse_and_compare_size(file_size: u64, query: &str) -> Result<bool> {
    let query = query.trim();
    let (op, size_str) = if query.starts_with(['>', '<', '=']) {
        query.split_at(1)
    } else {
        ("=", query)
    };

    let size_str = size_str.trim().to_lowercase();
    let (num_str, unit) = size_str.split_at(
        size_str
            .find(|c: char| !c.is_digit(10) && c != '.')
            .unwrap_or(size_str.len()),
    );

    let num = num_str.parse::<f64>()?;
    let multiplier = match unit.trim() {
        "b" | "" => 1.0,
        "kb" | "k" => 1024.0,
        "mb" | "m" => 1024.0 * 1024.0,
        "gb" | "g" => 1024.0 * 1024.0 * 1024.0,
        _ => return Err(anyhow!("Invalid size unit: {}", unit)),
    };

    let target_size_bytes = (num * multiplier) as u64;

    match op {
        ">" => Ok(file_size > target_size_bytes),
        "<" => Ok(file_size < target_size_bytes),
        "=" => Ok(file_size == target_size_bytes),
        _ => Err(anyhow!("Invalid size operator: {}", op)),
    }
}

pub(super) fn parse_and_compare_time(modified_time: SystemTime, query: &str) -> Result<bool> {
    let now = SystemTime::now();
    let (op, time_str) = if query.starts_with(['>', '<', '=']) {
        query.split_at(1)
    } else {
        ("=", query)
    };
    let time_str = time_str.trim();

    let threshold_time = if let Ok(duration) = parse_relative_time(time_str) {
        now.checked_sub(duration)
            .ok_or_else(|| anyhow!("Time calculation underflow"))?
    } else if let Ok(datetime) = parse_absolute_time(time_str) {
        datetime
    } else {
        return Err(anyhow!("Invalid date format: '{}'", time_str));
    };

    match op {
        ">" => Ok(modified_time > threshold_time),
        "<" => Ok(modified_time < threshold_time),
        "=" => {
            // For date-only comparisons, check if the modified time is within the same day
            if time_str.len() == 10 {
                let modified_local = chrono::DateTime::<Local>::from(modified_time);
                let threshold_local = chrono::DateTime::<Local>::from(threshold_time);
                Ok(modified_local.date_naive() == threshold_local.date_naive())
            } else {
                Ok(modified_time == threshold_time)
            }
        }
        _ => Err(anyhow!("Invalid time operator: {}", op)),
    }
}

fn parse_relative_time(time_str: &str) -> Result<Duration> {
    let (num_str, unit) = time_str.split_at(
        time_str
            .find(|c: char| !c.is_digit(10))
            .unwrap_or(time_str.len()),
    );
    let num = num_str.parse::<u64>()?;
    let multiplier = match unit.trim() {
        "s" => 1,
        "m" => 60,
        "h" => 3600,
        "d" => 86400,
        "w" => 86400 * 7,
        "y" => 86400 * 365,
        _ => return Err(anyhow!("Invalid time unit")),
    };
    Ok(Duration::from_secs(num * multiplier))
}

fn parse_absolute_time(time_str: &str) -> Result<SystemTime> {
    let datetime = if let Ok(dt) = NaiveDateTime::parse_from_str(time_str, "%Y-%m-%d %H:%M:%S") {
        dt
    } else if let Ok(date) = NaiveDate::parse_from_str(time_str, "%Y-%m-%d") {
        date.and_time(NaiveTime::from_hms_opt(0, 0, 0).unwrap())
    } else {
        return Err(anyhow!("Invalid absolute date format"));
    };

    Ok(Local
        .from_local_datetime(&datetime)
        .single()
        .ok_or_else(|| anyhow!("Failed to convert to local time"))?
        .into())
}

---

File: ./src/predicates/in_path.rs
---
use anyhow::Result;
use globset::Glob;
use std::path::PathBuf;

use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;

pub(super) struct InPathEvaluator;

impl PredicateEvaluator for InPathEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        // Check for glob metacharacters to switch between logic paths.
        if value.contains('*') || value.contains('?') || value.contains('[') || value.contains('{')
        {
            // --- Wildcard Logic ---
            let glob = Glob::new(value)?.compile_matcher();

            if let Some(parent) = context.path.parent() {
                // Strip the root from the parent path to make the match relative.
                let relative_parent = parent.strip_prefix(&context.root).unwrap_or(parent);
                Ok(MatchResult::Boolean(glob.is_match(relative_parent)))
            } else {
                Ok(MatchResult::Boolean(false))
            }
        } else {
            // --- Non-recursive Exact-Path Logic ---
            let target_dir = PathBuf::from(value);
            let absolute_target_dir = if target_dir.is_absolute() {
                target_dir
            } else {
                context.root.join(target_dir)
            };

            if !absolute_target_dir.is_dir() {
                return Ok(MatchResult::Boolean(false));
            }

            let canonical_target = match dunce::canonicalize(&absolute_target_dir) {
                Ok(path) => path,
                Err(_) => return Ok(MatchResult::Boolean(false)),
            };

            if let Some(file_parent) = context.path.parent() {
                let canonical_file_parent = match dunce::canonicalize(file_parent) {
                    Ok(path) => path,
                    Err(_) => return Ok(MatchResult::Boolean(false)),
                };
                Ok(MatchResult::Boolean(canonical_file_parent == canonical_target))
            } else {
                Ok(MatchResult::Boolean(false))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn test_in_path_evaluator_exact() -> Result<()> {
        let evaluator = InPathEvaluator;

        // Create a temporary directory structure
        let root_dir = tempdir()?;
        let root_path = root_dir.path();

        let project_dir = root_path.join("project");
        let src_dir = project_dir.join("src");
        let other_project_dir = root_path.join("other_project");
        fs::create_dir_all(&src_dir)?;
        fs::create_dir_all(&other_project_dir)?;

        let main_rs_path = src_dir.join("main.rs");
        fs::write(&main_rs_path, "fn main() {}")?;

        // --- Test Cases ---

        let mut context = FileContext::new(main_rs_path.clone(), root_path.to_path_buf());

        // 1. Absolute Path: Exact parent directory. Should match.
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::In, src_dir.to_str().unwrap())?
            .is_match());

        // 2. Absolute Path: Grandparent directory. Should NOT match due to non-recursive logic.
        assert!(!evaluator
            .evaluate(
                &mut context,
                &PredicateKey::In,
                project_dir.to_str().unwrap()
            )?
            .is_match());

        // 3. Absolute Path: Non-matching directory.
        assert!(!evaluator
            .evaluate(
                &mut context,
                &PredicateKey::In,
                other_project_dir.to_str().unwrap()
            )?
            .is_match());

        // 4. Relative Path: from the root. Should match.
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::In, "project/src")?
            .is_match());

        // 5. Relative Path: with dot-slash. Should match.
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::In, "./project/src")?
            .is_match());

        // 6. Relative Path: non-matching.
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::In, "other_project")?
            .is_match());

        // 7. A file path is not a directory. Should not match.
        assert!(!evaluator
            .evaluate(
                &mut context,
                &PredicateKey::In,
                main_rs_path.to_str().unwrap()
            )?
            .is_match());

        // 8. Non-existent directory should not error, just return false.
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::In, "non_existent_dir")?
            .is_match());

        Ok(())
    }

    #[test]
    fn test_in_path_evaluator_wildcard() -> Result<()> {
        let evaluator = InPathEvaluator;

        // Create a temporary directory structure
        let root_dir = tempdir()?;
        let root_path = root_dir.path();

        let project_a_src = root_path.join("project_a").join("src");
        let project_b_source = root_path.join("project_b").join("source");
        let other_src = root_path.join("other").join("src");
        fs::create_dir_all(&project_a_src)?;
        fs::create_dir_all(&project_b_source)?;
        fs::create_dir_all(&other_src)?;

        let file_a = project_a_src.join("main.rs");
        fs::write(&file_a, "")?;
        let file_b = project_b_source.join("lib.rs");
        fs::write(&file_b, "")?;
        let file_c = other_src.join("component.js");
        fs::write(&file_c, "")?;

        let mut context_a = FileContext::new(file_a, root_path.to_path_buf());
        let mut context_b = FileContext::new(file_b, root_path.to_path_buf());
        let mut context_c = FileContext::new(file_c, root_path.to_path_buf());

        // --- Test Cases ---

        // 1. `**/src` should match files in any `src` directory
        assert!(evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "**/src")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context_b, &PredicateKey::In, "**/src")?
            .is_match());
        assert!(evaluator
            .evaluate(&mut context_c, &PredicateKey::In, "**/src")?
            .is_match());

        // 2. `project_*/src` glob should match relative to the root.
        assert!(evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "project_a/src")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context_b, &PredicateKey::In, "project_*/src")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context_c, &PredicateKey::In, "project_*/src")?
            .is_match());

        // 3. More specific glob `**/project_a/s?c`
        assert!(evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "**/project_a/s?c")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context_b, &PredicateKey::In, "**/project_a/s?c")?
            .is_match());

        // 4. Glob that should not match anything
        assert!(!evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "**/test")?
            .is_match());

        // 5. Glob matching a different directory `**/so*ce`
        assert!(!evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "**/so*ce")?
            .is_match());
        assert!(evaluator
            .evaluate(&mut context_b, &PredicateKey::In, "**/so*ce")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context_c, &PredicateKey::In, "**/so*ce")?
            .is_match());

        Ok(())
    }

    #[test]
    fn test_in_path_evaluator_relative_wildcard() -> Result<()> {
        let evaluator = InPathEvaluator;

        // Create a temporary directory structure
        let root_dir = tempdir()?;
        let root_path = root_dir.path();

        let project_a_src = root_path.join("project_a").join("src");
        fs::create_dir_all(&project_a_src)?;

        let file_a = project_a_src.join("main.rs");
        fs::write(&file_a, "")?;

        // The context's root is the temporary directory we created.
        let mut context_a = FileContext::new(file_a, root_path.to_path_buf());

        // This glob is relative to the context's root.
        // It should match `.../project_a/src`
        assert!(evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "project_a/*")?
            .is_match());

        // This glob should not match.
        assert!(!evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "project_b/*")?
            .is_match());
            
        // This glob should also match.
        assert!(evaluator
            .evaluate(&mut context_a, &PredicateKey::In, "project_a/s?c")?
            .is_match());

        Ok(())
    }

    #[test]
    fn test_in_path_evaluator_advanced_wildcards() -> Result<()> {
        let evaluator = InPathEvaluator;
        let root_dir = tempdir()?;
        let root_path = root_dir.path();

        // Structure:
        //  /src/api/routes.js
        //  /src/db/connect.js
        //  /lib/auth/token.js
        //  /lib/deep/down/utils.js
        let src_api = root_path.join("src").join("api");
        let src_db = root_path.join("src").join("db");
        let lib_auth = root_path.join("lib").join("auth");
        let lib_deep = root_path.join("lib").join("deep").join("down");
        fs::create_dir_all(&src_api)?;
        fs::create_dir_all(&src_db)?;
        fs::create_dir_all(&lib_auth)?;
        fs::create_dir_all(&lib_deep)?;

        let file_in_src_api = src_api.join("routes.js");
        fs::write(&file_in_src_api, "")?;
        let file_in_src_db = src_db.join("connect.js");
        fs::write(&file_in_src_db, "")?;
        let file_in_lib_auth = lib_auth.join("token.js");
        fs::write(&file_in_lib_auth, "")?;
        let file_in_lib_deep = lib_deep.join("utils.js");
        fs::write(&file_in_lib_deep, "")?;

        let mut ctx_api = FileContext::new(file_in_src_api, root_path.to_path_buf());
        let mut ctx_db = FileContext::new(file_in_src_db, root_path.to_path_buf());
        let mut ctx_auth = FileContext::new(file_in_lib_auth, root_path.to_path_buf());
        let mut ctx_deep = FileContext::new(file_in_lib_deep, root_path.to_path_buf());

        // Test single-level wildcard `in:'src/*'`
        assert!(evaluator
            .evaluate(&mut ctx_api, &PredicateKey::In, "src/*")?
            .is_match());
        assert!(evaluator
            .evaluate(&mut ctx_db, &PredicateKey::In, "src/*")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut ctx_auth, &PredicateKey::In, "src/*")?
            .is_match());

        // Test recursive globstar `in:'**/*'`
        assert!(evaluator
            .evaluate(&mut ctx_deep, &PredicateKey::In, "lib/**")?
            .is_match());
        assert!(evaluator
            .evaluate(&mut ctx_deep, &PredicateKey::In, "lib/d*p/**")?
            .is_match());
         assert!(evaluator
            .evaluate(&mut ctx_auth, &PredicateKey::In, "lib/**")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut ctx_api, &PredicateKey::In, "lib/**")?
            .is_match());

        // Test non-matching wildcard
        assert!(!evaluator
            .evaluate(&mut ctx_api, &PredicateKey::In, "dist/*")?
            .is_match());

        Ok(())
    }
}

---

File: ./src/predicates/matches.rs
---
use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;
use regex::Regex;
use tree_sitter::Range;

pub(super) struct MatchesEvaluator;
impl PredicateEvaluator for MatchesEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let content = context.get_content()?;
        let re = Regex::new(value)?;

        let mut ranges = Vec::new();
        for (i, line) in content.lines().enumerate() {
            if re.is_match(line) {
                let start_byte = content.lines().take(i).map(|l| l.len() + 1).sum();
                let end_byte = start_byte + line.len();
                ranges.push(Range {
                    start_byte,
                    end_byte,
                    start_point: tree_sitter::Point { row: i, column: 0 },
                    end_point: tree_sitter::Point {
                        row: i,
                        column: line.len(),
                    },
                });
            }
        }
        Ok(MatchResult::Hunks(ranges))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use std::path::PathBuf;
    use tempfile::NamedTempFile;

    fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_matches_evaluator() {
        let file = create_temp_file("version = \"0.1.0\"\nauthor = \"test\"");
        let mut context = FileContext::new(file.path().to_path_buf(), PathBuf::from("/"));
        let evaluator = MatchesEvaluator;
        // Simple regex
        assert!(evaluator
            .evaluate(
                &mut context,
                &PredicateKey::Matches,
                r#"version = "[0-9]+\.[0-9]+\.[0-9]+""#
            )
            .unwrap()
            .is_match());
        // Test regex that finds a line
        assert!(evaluator
            .evaluate(
                &mut context,
                &PredicateKey::Matches,
                r#"author = "test""#
            )
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(
                &mut context,
                &PredicateKey::Matches,
                r#"^version = "1.0.0"$"#
            )
            .unwrap()
            .is_match());
    }
}

---

File: ./src/predicates/mod.rs
---
pub mod code_aware;
pub mod contains;
pub mod ext;
mod helpers;
pub mod in_path;
pub mod matches;
pub mod modified;
pub mod name;
pub mod path;
pub mod size;

use self::code_aware::CodeAwareEvaluator;
use self::contains::ContainsEvaluator;
use self::ext::ExtEvaluator;
use self::in_path::InPathEvaluator;
use self::matches::MatchesEvaluator;
use self::modified::ModifiedEvaluator;
use self::name::NameEvaluator;
use self::path::PathEvaluator;
use self::size::SizeEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;
use std::collections::HashMap;

// The core trait that all predicate evaluators must implement.
pub trait PredicateEvaluator {
    // The key is now passed to allow one evaluator to handle multiple predicate types.
    fn evaluate(
        &self,
        context: &mut FileContext,
        key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult>;
}

/// Creates a predicate registry with only the fast, metadata-based predicates.
/// This is used for the pre-filtering pass.
pub fn create_metadata_predicate_registry(
) -> HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> {
    let mut registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> =
        HashMap::new();

    registry.insert(PredicateKey::Ext, Box::new(ExtEvaluator));
    registry.insert(PredicateKey::Name, Box::new(NameEvaluator));
    registry.insert(PredicateKey::Path, Box::new(PathEvaluator));
    registry.insert(PredicateKey::In, Box::new(InPathEvaluator));
    registry.insert(PredicateKey::Size, Box::new(SizeEvaluator));
    registry.insert(PredicateKey::Modified, Box::new(ModifiedEvaluator));

    registry
}

/// Creates and populates the complete predicate registry.
pub fn create_predicate_registry(
) -> HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> {
    // Start with the metadata predicates
    let mut registry = create_metadata_predicate_registry();

    // Add content-based predicates
    registry.insert(PredicateKey::Contains, Box::new(ContainsEvaluator));
    registry.insert(PredicateKey::Matches, Box::new(MatchesEvaluator));

    // Register the single CodeAwareEvaluator for all semantic predicate keys.
    let code_evaluator = Box::new(CodeAwareEvaluator);
    registry.insert(PredicateKey::Def, code_evaluator.clone());
    registry.insert(PredicateKey::Func, code_evaluator.clone());
    registry.insert(PredicateKey::Import, code_evaluator.clone());
    registry.insert(PredicateKey::Class, code_evaluator.clone());
    registry.insert(PredicateKey::Struct, code_evaluator.clone());
    registry.insert(PredicateKey::Enum, code_evaluator.clone());
    registry.insert(PredicateKey::Interface, code_evaluator.clone());
    registry.insert(PredicateKey::Trait, code_evaluator.clone());
    registry.insert(PredicateKey::Type, code_evaluator.clone());
    registry.insert(PredicateKey::Impl, code_evaluator.clone());
    registry.insert(PredicateKey::Macro, code_evaluator.clone());
    registry.insert(PredicateKey::Comment, code_evaluator.clone());
    registry.insert(PredicateKey::Str, code_evaluator.clone());
    registry.insert(PredicateKey::Call, code_evaluator.clone());
    // Add React predicates
    registry.insert(PredicateKey::Component, code_evaluator.clone());
    registry.insert(PredicateKey::Element, code_evaluator.clone());
    registry.insert(PredicateKey::Hook, code_evaluator.clone());
    registry.insert(PredicateKey::CustomHook, code_evaluator.clone());
    registry.insert(PredicateKey::Prop, code_evaluator);

    registry
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;

    // The `code_aware` suite remains here as it tests the interaction
    // of multiple profiles, which is a responsibility of this parent module.
    #[test]
    fn test_code_aware_evaluator_full_rust_suite() {
        let rust_code = r#"
            // TODO: refactor this module
            use std::collections::HashMap;

            type ConfigMap = HashMap<String, String>;

            pub struct AppConfig {}
            pub trait Runnable {
                fn run(&self);
            }
            fn launch_app() {
                let msg = "Launching...";
                println!("{}", msg);
            }
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("complex.rs");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(rust_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        // --- Granular Defs ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Struct, "AppConfig")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Trait, "Runnable")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Type, "ConfigMap")
            .unwrap()
            .is_match());

        // --- Functions ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "run")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "launch_app")
            .unwrap()
            .is_match());

        // --- Calls ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "println")
                .unwrap()
                .is_match(),
            "Should find function call"
        );
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            !evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "launch_app")
                .unwrap()
                .is_match(),
            "Should not find the definition as a call"
        );

        // --- Syntactic Content ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "TODO")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "Launching...")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_not_found() {
        let rust_code = r#"
            // This file has some content
            pub struct AppConfig {}
            fn launch_app() {}
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("some_file.rs");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(rust_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());

        // Search for a struct that does not exist.
        let result = evaluator
            .evaluate(&mut ctx, &PredicateKey::Struct, "NonExistentStruct")
            .unwrap();

        assert!(
            !result.is_match(),
            "Should not find a struct that doesn't exist"
        );
    }


    #[test]
    fn test_code_aware_evaluator_python_suite() {
        let python_code = r#"
# FIXME: use a real database
import os

class DataProcessor:
    def __init__(self):
        self.api_key = "secret_key"
        self.connect()

    def connect(self):
        print("Connecting...")

def process_data():
    proc = DataProcessor()
    print("Processing")
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("script.py");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(python_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        // --- Granular Defs ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Class, "DataProcessor")
            .unwrap()
            .is_match());

        // --- Functions ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "process_data")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "connect")
            .unwrap()
            .is_match());

        // --- Calls ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "print")
                .unwrap()
                .is_match(),
            "Should find multiple calls to print"
        );
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "DataProcessor")
                .unwrap()
                .is_match(),
            "Should find constructor call"
        );
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "connect")
                .unwrap()
                .is_match(),
            "Should find method call"
        );

        // --- Syntactic Content ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "FIXME")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "secret_key")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_javascript_suite() {
        let js_code = r#"
            import { open } from 'fs/promises';

            class Logger {
                log(message) { console.log(message); }
            }

            function a() {
                const l = new Logger();
                l.log("hello");
            }
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("script.js");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(js_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Def, "Logger")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "log")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "fs/promises")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "Logger")
                .unwrap()
                .is_match(),
            "Should find constructor call"
        );
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "log")
                .unwrap()
                .is_match(),
            "Should find method call"
        );
    }

    #[test]
    fn test_code_aware_evaluator_typescript_suite() {
        let ts_code = r#"
            import React from 'react';

            interface User { id: number; }
            type ID = string | number;

            class ApiClient {
                // The URL for the API
                private url = "https://api.example.com";
                fetchUser(): User | null { return null; }
            }

            const client = new ApiClient();
            client.fetchUser();
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("api.ts");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(ts_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        // --- Granular Defs ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Def, "ApiClient")
                .unwrap()
                .is_match(),
            "Should find class"
        );
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "fetchUser")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "React")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "ApiClient")
                .unwrap()
                .is_match(),
            "Should find TS constructor call"
        );
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(
            evaluator
                .evaluate(&mut ctx, &PredicateKey::Call, "fetchUser")
                .unwrap()
                .is_match(),
            "Should find TS method call"
        );

        // --- Syntactic Content ---
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "The URL")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "https://api.example.com")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_go_suite() {
        let go_code = r#"
           package main

           import "fmt"

           // User represents a user
           type User struct {
               ID int
           }

           func (u *User) Greet() {
               fmt.Println("Hello")
           }

           func main() {
               user := User{ID: 1}
               user.Greet()
           }
       "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("main.go");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(go_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Struct, "User")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "Greet")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Call, "Println")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "fmt")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "represents a user")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_code_aware_evaluator_java_suite() {
        let java_code = r#"
           package com.example;

           import java.util.List;

           // Represents a user
           public class User {
               public User() {
                   System.out.println("User created");
               }

               public void greet() {}
           }
       "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("User.java");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(java_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Class, "User")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Func, "greet")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Call, "println")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Import, "java.util.List")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Comment, "Represents a user")
            .unwrap()
            .is_match());
        let mut ctx = FileContext::new(file_path.clone(), file_path.parent().unwrap().to_path_buf());
        assert!(evaluator
            .evaluate(&mut ctx, &PredicateKey::Str, "User created")
            .unwrap()
            .is_match());
    }
}

---

File: ./src/predicates/modified.rs
---
use super::{helpers, PredicateEvaluator};
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct ModifiedEvaluator;
impl PredicateEvaluator for ModifiedEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let metadata = context.path.metadata()?;
        let modified_time = metadata.modified()?;
        Ok(MatchResult::Boolean(helpers::parse_and_compare_time(
            modified_time,
            value,
        )?))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use std::path::PathBuf;
    use tempfile::NamedTempFile;

    fn create_temp_file(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_modified_evaluator() {
        let file = create_temp_file("content");
        let mut context = FileContext::new(file.path().to_path_buf(), PathBuf::from("/"));

        let evaluator = ModifiedEvaluator;
        // File was just created
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Modified, ">1m")
            .unwrap()
            .is_match()); // Modified more recently than 1 min ago
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Modified, "<1m")
            .unwrap()
            .is_match()); // Not modified longer than 1 min ago
    }
}

---

File: ./src/predicates/name.rs
---
use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::{anyhow, Result};
use glob::{MatchOptions, Pattern};

pub(super) struct NameEvaluator;
impl PredicateEvaluator for NameEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        if value.is_empty() {
            return Err(anyhow!("Invalid glob pattern: cannot be empty."));
        }

        let file_name = context
            .path
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or("");
        let options = MatchOptions {
            case_sensitive: false,
            ..Default::default()
        };
        let pattern = Pattern::new(value)?;
        Ok(MatchResult::Boolean(
            pattern.matches_with(file_name, options),
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_name_evaluator() {
        let mut context1 = FileContext::new(PathBuf::from("/home/user/Cargo.toml"), PathBuf::from("/"));
        let mut context2 = FileContext::new(PathBuf::from("/home/user/main.rs"), PathBuf::from("/"));

        let evaluator = NameEvaluator;
        assert!(evaluator
            .evaluate(&mut context1, &PredicateKey::Name, "Cargo.toml")
            .unwrap()
            .is_match());
        assert!(
            evaluator
                .evaluate(&mut context1, &PredicateKey::Name, "C*.toml")
                .unwrap()
                .is_match(),
            "Glob pattern should match"
        );
        assert!(
            evaluator
                .evaluate(&mut context2, &PredicateKey::Name, "*.rs")
                .unwrap()
                .is_match(),
            "Glob pattern should match"
        );
        assert!(!evaluator
            .evaluate(&mut context1, &PredicateKey::Name, "*.rs")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_name_evaluator_case_insensitive() {
        let mut context =
            FileContext::new(PathBuf::from("/home/user/MyFile.txt"), PathBuf::from("/"));
        let evaluator = NameEvaluator;
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Name, "myfile.txt")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Name, "MYFILE.TXT")
            .unwrap()
            .is_match());
    }
}

---

File: ./src/predicates/path.rs
---
use super::PredicateEvaluator;
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;
use globset::Glob;

pub(super) struct PathEvaluator;

impl PredicateEvaluator for PathEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let path_str = context.path.to_string_lossy();

        if value.contains('*') || value.contains('?') || value.contains('[') || value.contains('{')
        {
            // Convert glob-style pattern to a regex
            let glob = Glob::new(value)?.compile_matcher();
            Ok(MatchResult::Boolean(glob.is_match(path_str.as_ref())))
        } else {
            // Fallback to simple substring search for non-glob patterns
            Ok(MatchResult::Boolean(path_str.contains(value)))
        }
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_path_evaluator_contains() {
        let mut context = FileContext::new(
            PathBuf::from("/home/user/project/src/main.rs"),
            PathBuf::from("/"),
        );
        let evaluator = PathEvaluator;
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "project/src")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "/home/user")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Path, "project/lib")
            .unwrap()
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "main.rs")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_path_evaluator_wildcard() {
        let mut context = FileContext::new(
            PathBuf::from("/home/user/project/src/main.rs"),
            PathBuf::from("/"),
        );
        let evaluator = PathEvaluator;

        // This should match because ** crosses directory boundaries
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "**/main.rs")
            .unwrap()
            .is_match());
        // This should also match
        assert!(evaluator
            .evaluate(
                &mut context,
                &PredicateKey::Path,
                "/home/user/project/src/*.rs"
            )
            .unwrap()
            .is_match());
        // This SHOULD match because a glob without a separator matches the file name.
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "*.rs")
            .unwrap()
            .is_match());
        // This should match
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "**/*.rs")
            .unwrap()
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Path, "**/*.ts")
            .unwrap()
            .is_match());
    }

    #[test]
    fn test_empty_path_query() {
        let mut context = FileContext::new(
            PathBuf::from("/home/user/project/src/main.rs"),
            PathBuf::from("/"),
        );
        let evaluator = PathEvaluator;

        // Empty string should match everything with `contains`
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Path, "")
            .unwrap()
            .is_match());
    }
}

---

File: ./src/predicates/size.rs
---
use super::{helpers, PredicateEvaluator};
use crate::evaluator::{FileContext, MatchResult};
use crate::parser::PredicateKey;
use anyhow::Result;

pub(super) struct SizeEvaluator;
impl PredicateEvaluator for SizeEvaluator {
    fn evaluate(
        &self,
        context: &mut FileContext,
        _key: &PredicateKey,
        value: &str,
    ) -> Result<MatchResult> {
        let metadata = context.path.metadata()?;
        let file_size = metadata.len();
        Ok(MatchResult::Boolean(helpers::parse_and_compare_size(
            file_size, value,
        )?))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use std::io::Write;
    use std::path::PathBuf;
    use tempfile::tempdir;

    #[test]
    fn test_size_evaluator_valid_comparisons() -> Result<()> {
        let dir = tempdir()?;
        let file_path = dir.path().join("file_1kb");
        let mut file = File::create(&file_path)?;
        file.write_all(&[0; 1024])?;

        let mut context = FileContext::new(file_path, PathBuf::from("/"));
        let evaluator = SizeEvaluator;

        // Exact match
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, "=1kb")?
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, "=1024")?
            .is_match());

        // Greater than
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">1000")?
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">0.9kb")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">2kb")?
            .is_match());

        // Less than
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, "<2kb")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Size, "<1kb")?
            .is_match());

        Ok(())
    }

    #[test]
    fn test_size_evaluator_empty_file() -> Result<()> {
        let dir = tempdir()?;
        let file_path = dir.path().join("empty_file");
        File::create(&file_path)?;

        let mut context = FileContext::new(file_path, PathBuf::from("/"));
        let evaluator = SizeEvaluator;

        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, "=0")?
            .is_match());
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, "<1")?
            .is_match());
        assert!(!evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">0")?
            .is_match());

        Ok(())
    }

    #[test]
    fn test_size_evaluator_invalid_input() -> Result<()> {
        let dir = tempdir()?;
        let file_path = dir.path().join("any_file");
        File::create(&file_path)?;
        let mut context = FileContext::new(file_path, PathBuf::from("/"));
        let evaluator = SizeEvaluator;

        // Invalid number
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">abc")
            .is_err());

        // Invalid operator
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, "?123")
            .is_err());
            
        // Missing value
        assert!(evaluator
            .evaluate(&mut context, &PredicateKey::Size, ">")
            .is_err());

        Ok(())
    }
}

---

File: ./tests/advanced_logic.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

#[test]
fn test_distinguishes_function_call_from_definition() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=hunks")
        .arg("call:my_func & path:same_file_def_call.rs");

    // The output should contain the CALL line but not the DEFINITION line.
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("my_func();"))
        .stdout(predicate::str::contains("fn my_func()").not());
}

#[test]
fn test_and_combination_of_hunk_and_boolean_predicates() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=hunks")
        .arg("struct:MyStruct & ext:rs & path:code.rs");

    // The output should be just the struct hunk, not the whole file.
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("struct MyStruct"))
        .stdout(predicate::str::contains("fn my_func").not());
}

#[test]
fn test_or_combination_with_negation() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=paths")
        .arg("contains:foo | !contains:baz");

    // Should find logical1.rs (contains foo) and logical2.rs (does not contain baz),
    // but not logical3.rs (because it contains baz).
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("logical1.rs"))
        .stdout(predicate::str::contains("logical2.rs"))
        .stdout(predicate::str::contains("logical3.rs").not());
}

#[test]
fn test_graceful_failure_on_non_existent_root_path() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg(".")
        .arg("--root")
        .arg("/path/that/absolutely/does/not/exist");

    // Should fail with a clear error message.
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(
            "root path '/path/that/absolutely/does/not/exist' does not exist",
        ));
}

#[test]
fn test_behavior_on_unknown_predicate() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    // Search for a predicate that doesn't exist.
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("nonexistent:predicate");

    // The current behavior is to silently treat this as a "true" match for that predicate.
    // Therefore, the command succeeds and finds all files. This test documents that behavior.
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("code.rs"))
        .stdout(predicate::str::contains("calls.rs"));
}

#[test]
fn test_negation_of_hunk_predicate_produces_boolean_match() {
    // Case 1: Negating a predicate that DOES match the file.
    // The file code.rs contains `struct MyStruct`.
    // `!struct:MyStruct` should evaluate to false for this file.
    let mut cmd1 = Command::cargo_bin("rdump").unwrap();
    cmd1.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("!struct:MyStruct & name:code.rs");

    cmd1.assert().success().stdout(predicate::str::is_empty());

    // Case 2: Negating a predicate that does NOT match the file.
    // The file code.rs does NOT contain `struct NonExistent`.
    // `!struct:NonExistent` should evaluate to true for this file.
    let mut cmd2 = Command::cargo_bin("rdump").unwrap();
    cmd2.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("!struct:NonExistent & name:code.rs");

    cmd2.assert()
        .success()
        .stdout(predicate::str::contains("File: ../insane_test_bed/code.rs"));
}

#[test]
fn test_empty_contains_predicate_matches_all_files() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=paths")
        .arg("contains:''"); // Empty string

    // An empty `contains` query should match every file.
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("code.rs"))
        .stdout(predicate::str::contains("logical1.rs"))
        .stdout(predicate::str::contains("trait.rs"));
}

#[test]
fn test_empty_name_predicate_fails_gracefully() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("name:''"); // Empty glob pattern

    // An empty glob is invalid, so this should fail with a clear error.
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("Invalid glob pattern"));
}

---

File: ./tests/cli.rs
---
// In rdump/tests/cli.rs

use assert_cmd::prelude::*; // Adds methods on commands
use predicates::prelude::*; // Used for writing assertions
use std::fs;
use std::io::Write;
use std::process::Command; // Lets us run other programs
use tempfile::tempdir; // Create temporary directories for testing

// --- Helper Functions ---

/// A helper to set up a temporary directory with a predictable file structure for tests.
/// Returns the TempDir object (which cleans up the directory when it's dropped)
/// and the PathBuf of the root, for convenience.
fn setup_test_dir() -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let root = dir.path().to_path_buf();

    // Create a file to be found
    fs::File::create(root.join("main.rs"))
        .unwrap()
        .write_all(b"fn main() {\n    println!(\"Hello\");\n}")
        .unwrap();

    // Create a file that shouldn't be found by most queries
    fs::File::create(root.join("other.txt"))
        .unwrap()
        .write_all(b"some text")
        .unwrap();

    (dir, root)
}

// --- Test Implementation ---

#[test]
fn test_help_message() -> Result<(), Box<dyn std::error::Error>> {
    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.arg("--help");
    cmd.assert()
        .success()
        .stdout(predicate::str::contains(
            "A fast, expressive, code-aware tool",
        ))
        .stdout(predicate::str::contains("Usage: rdump <COMMAND>"))
        .stdout(predicate::str::contains("Commands:\n  search"))
        .stdout(predicate::str::contains("  preset"))
        .stdout(predicate::str::contains("Options:\n  -h, --help"))
        .stdout(predicate::str::contains("  -V, --version"));
    Ok(())
}

#[test]
fn test_version_message() -> Result<(), Box<dyn std::error::Error>> {
    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.arg("--version");
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("rdump 0.1.0")); // Assumes version in Cargo.toml
    Ok(())
}

#[test]
fn test_no_args_fails() -> Result<(), Box<dyn std::error::Error>> {
    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.assert()
        .failure() // Should fail because a subcommand is required
        .stderr(predicate::str::contains("Usage: rdump <COMMAND>"));
    Ok(())
}

#[test]
fn test_search_simple_predicate_succeeds() -> Result<(), Box<dyn std::error::Error>> {
    // Setup a temporary directory with our test files
    let (_dir, root) = setup_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root); // Run the command *from* our test directory
    cmd.arg("search").arg("ext:rs");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("File: ./main.rs"))
        .stdout(predicate::str::contains("fn main()"))
        .stdout(predicate::str::contains("---").count(1))
        .stdout(predicate::str::contains("other.txt").not());
    Ok(())
}

#[test]
fn test_search_no_results() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    cmd.arg("search").arg("ext:java"); // No java files exist

    cmd.assert().success().stdout(predicate::str::is_empty()); // Nothing should be printed
    Ok(())
}

#[test]
fn test_search_invalid_query_fails() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    cmd.arg("search").arg("ext:"); // Query with a missing value

    cmd.assert()
        .failure()
        .stdout(predicate::str::is_empty())
        .stderr(predicate::str::contains("expected value"));
    Ok(())
}

#[test]
fn test_lang_describe_command() -> Result<(), Box<dyn std::error::Error>> {
    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.arg("lang").arg("describe").arg("rust");

    // Assert that the output contains the key sections for a supported language.
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("Predicates for Rust"))
        .stdout(predicate::str::contains("METADATA"))
        .stdout(predicate::str::contains("ext, name, path"))
        .stdout(predicate::str::contains("CONTENT"))
        .stdout(predicate::str::contains("contains, matches"))
        .stdout(predicate::str::contains("SEMANTIC"));
    Ok(())
}

// Add this new helper function to rdump/tests/cli.rs

/// Sets up a more complex directory for testing discovery and formatting.
fn setup_advanced_test_dir() -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let root = dir.path().to_path_buf();

    // Top-level files
    fs::File::create(root.join("main.rs"))
        .unwrap()
        .write_all(b"fn main() {}")
        .unwrap();
    fs::File::create(root.join(".hidden_config"))
        .unwrap()
        .write_all(b"secret=true")
        .unwrap();

    // Subdirectory with a file
    fs::create_dir(root.join("src")).unwrap();
    fs::File::create(root.join("src/lib.rs"))
        .unwrap()
        .write_all(b"// a library")
        .unwrap();

    // Directory and file to be ignored
    fs::create_dir(root.join("logs")).unwrap();
    fs::File::create(root.join("logs/latest.log"))
        .unwrap()
        .write_all(b"INFO: started")
        .unwrap();

    // .gitignore file to ignore the logs
    let mut gitignore = fs::File::create(root.join(".gitignore")).unwrap();
    writeln!(gitignore, "*.log").unwrap();

    (dir, root)
}

// Add these new tests to the end of rdump/tests/cli.rs

#[test]
fn test_file_discovery_flags() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_advanced_test_dir();

    // Test --hidden flag
    let mut cmd_hidden = Command::cargo_bin("rdump")?;
    cmd_hidden.current_dir(&root);
    cmd_hidden.arg("search").arg("--hidden").arg("path:hidden");
    cmd_hidden
        .assert()
        .success()
        .stdout(predicate::str::contains(".hidden_config"));

    // Test --no-ignore flag
    let mut cmd_no_ignore = Command::cargo_bin("rdump")?;
    cmd_no_ignore.current_dir(&root);
    cmd_no_ignore
        .arg("search")
        .arg("--no-ignore")
        .arg("ext:log");
    cmd_no_ignore
        .assert()
        .success()
        .stdout(predicate::str::contains("latest.log"));

    // Test --max-depth flag
    let mut cmd_depth = Command::cargo_bin("rdump")?;
    cmd_depth.current_dir(&root);
    // This should find `main.rs` but not `src/lib.rs`
    cmd_depth
        .arg("search")
        .arg("--max-depth")
        .arg("1")
        .arg("ext:rs");
    cmd_depth
        .assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("src/lib.rs").not());

    Ok(())
}

#[test]
fn test_output_formatting_flags() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_advanced_test_dir();

    // Test --format paths
    let mut cmd_paths = Command::cargo_bin("rdump")?;
    cmd_paths.current_dir(&root);
    cmd_paths
        .arg("search")
        .arg("--format")
        .arg("paths")
        .arg("ext:rs");
    // Should contain ONLY the paths, sorted. The extra newline is important.
    let expected_paths = "./main.rs\n./src/lib.rs\n";
    cmd_paths.assert().success().stdout(expected_paths);

    // Test --format json
    let mut cmd_json = Command::cargo_bin("rdump")?;
    cmd_json.current_dir(&root);
    cmd_json
        .arg("search")
        .arg("--format")
        .arg("json")
        .arg("path:main.rs");
    // Assert it contains the key parts of a valid JSON output
    cmd_json
        .assert()
        .success()
        .stdout(predicate::str::contains(r#""path": "./main.rs""#))
        .stdout(predicate::str::contains(r#""content": "fn main() {}""#));

    // Test --format cat with --line-numbers (no color, since it's a pipe)
    let mut cmd_cat = Command::cargo_bin("rdump")?;
    cmd_cat.current_dir(&root);
    cmd_cat
        .arg("search")
        .arg("--format")
        .arg("cat")
        .arg("--line-numbers")
        .arg("path:main.rs");
    cmd_cat
        .assert()
        .success()
        .stdout(predicate::str::contains("1 | fn main() {}"))
        .stdout(predicate::str::contains("\x1b[").not()); // Check for NO ANSI color codes

    // Test --color=always to force highlighting
    let mut cmd_color = Command::cargo_bin("rdump")?;
    cmd_color.current_dir(&root);
    cmd_color
        .arg("search")
        .arg("--color=always")
        .arg("path:main.rs");
    cmd_color
        .assert()
        .success()
        .stdout(predicate::str::contains("\x1b[")); // Check FOR ANSI color codes

    // Test --find shorthand flag
    let mut cmd_find = Command::cargo_bin("rdump")?;
    cmd_find.current_dir(&root);
    cmd_find.arg("search").arg("--find").arg("path:main.rs");
    // We can't know the exact permissions/date, but we can check for the structure
    cmd_find
        .assert()
        .success()
        .stdout(predicate::str::contains("main.rs")) // The path
        .stdout(predicate::str::contains("12")); // The size (fn main() {} is 12 bytes)

    Ok(())
}

/// Sets up an environment for testing presets, with a fake home and project directory.
fn setup_preset_test_env() -> (tempfile::TempDir, std::path::PathBuf, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let fake_home = dir.path().join("home");
    fs::create_dir(&fake_home).unwrap();
    let project_dir = dir.path().join("project");
    fs::create_dir(&project_dir).unwrap();

    // Create a file in the project directory to be found by searches
    fs::File::create(project_dir.join("main.rs"))
        .unwrap()
        .write_all(b"fn main() {}")
        .unwrap();
    fs::File::create(project_dir.join("main.toml"))
        .unwrap()
        .write_all(b"[package]")
        .unwrap();

    (dir, fake_home, project_dir)
}

// Add these new tests to the end of rdump/tests/cli.rs

#[test]
fn test_preset_lifecycle() -> Result<(), Box<dyn std::error::Error>> {
    // We get a clean home directory AND a clean project directory
    let (_dir, fake_home, project_dir) = setup_preset_test_env();
    let config_path = fake_home.join("rdump/config.toml");

    // 1. List when no presets exist.
    // CRITICAL FIX: Run this command from the clean project_dir.
    let mut cmd_list1 = Command::cargo_bin("rdump")?;
    cmd_list1.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd_list1.current_dir(&project_dir); // <--- THIS IS THE FIX
    cmd_list1.arg("preset").arg("list");
    cmd_list1
        .assert()
        .success()
        .stdout(predicate::str::contains("No presets found."));

    // 2. Add a preset. This command is not affected by current_dir, but it's good practice.
    let mut cmd_add = Command::cargo_bin("rdump")?;
    cmd_add.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd_add.current_dir(&project_dir); // Add for consistency
    cmd_add
        .arg("preset")
        .arg("add")
        .arg("rust-files")
        .arg("ext:rs");
    cmd_add.assert().success();

    // Verify the file content directly
    assert!(config_path.exists());
    let content = fs::read_to_string(&config_path)?;
    assert!(content.contains(r#"rust-files = "ext:rs""#));

    // 3. List again to see the new preset.
    let mut cmd_list2 = Command::cargo_bin("rdump")?;
    cmd_list2.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd_list2.current_dir(&project_dir); // Add for consistency
    cmd_list2.arg("preset").arg("list");
    cmd_list2
        .assert()
        .success()
        .stdout(predicate::str::contains("rust-files : ext:rs"));

    // 4. Remove the preset.
    let mut cmd_remove = Command::cargo_bin("rdump")?;
    cmd_remove.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd_remove.current_dir(&project_dir); // Add for consistency
    cmd_remove.arg("preset").arg("remove").arg("rust-files");
    cmd_remove.assert().success();

    // Verify the file content has changed
    let content_after_remove = fs::read_to_string(&config_path)?;
    assert!(!content_after_remove.contains("rust-files"));

    Ok(())
}

#[test]
fn test_search_and_preset_interaction() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, fake_home, project_dir) = setup_preset_test_env();

    // 1. Setup: Create presets
    let preset_content = r#"
[presets]
rust = "ext:rs"
config = "ext:toml"
"#;
    let config_dir = fake_home.join("rdump");
    fs::create_dir_all(&config_dir)?;
    fs::write(config_dir.join("config.toml"), preset_content)?;

    // 2. Test search with one preset
    let mut cmd_search1 = Command::cargo_bin("rdump")?;
    cmd_search1.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd_search1.current_dir(&project_dir);
    cmd_search1.arg("search").arg("-p").arg("rust");
    cmd_search1
        .assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("main.toml").not());

    // 3. Test search with a preset AND a query
    // Should evaluate to `(ext:rs) & contains:main`
    let mut cmd_search2 = Command::cargo_bin("rdump")?;
    cmd_search2.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd_search2.current_dir(&project_dir);
    cmd_search2
        .arg("search")
        .arg("-p")
        .arg("rust")
        .arg("contains:main");
    cmd_search2
        .assert()
        .success()
        .stdout(predicate::str::contains("main.rs"));

    // 4. Test search with multiple presets
    // Should evaluate to `(ext:toml) & (ext:rs)` -> no results
    let mut cmd_search3 = Command::cargo_bin("rdump")?;
    cmd_search3.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd_search3.current_dir(&project_dir);
    cmd_search3
        .arg("search")
        .arg("-p")
        .arg("rust")
        .arg("-p")
        .arg("config");
    cmd_search3
        .assert()
        .success()
        .stdout(predicate::str::is_empty());

    Ok(())
}

#[test]
fn test_local_config_override() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, fake_home, project_dir) = setup_preset_test_env();

    // 1. Setup: Create a global config
    let global_preset = r#"[presets]
app = "ext:rs""#;
    let config_dir = fake_home.join("rdump");
    fs::create_dir_all(&config_dir)?;
    fs::write(config_dir.join("config.toml"), global_preset)?;

    // 2. Setup: Create a local .rdump.toml that OVERRIDES the preset
    let local_preset = r#"[presets]
app = "ext:toml""#;
    fs::write(project_dir.join(".rdump.toml"), local_preset)?;

    // 3. Run the search from the project directory
    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    cmd.current_dir(&project_dir); // CRITICAL: Run from where the local config is
    cmd.arg("search").arg("-p").arg("app");

    // 4. Assert that it used the LOCAL definition (ext:toml) and not the global one (ext:rs)
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("main.toml"))
        .stdout(predicate::str::contains("main.rs").not());

    Ok(())
}

#[test]
fn test_preset_error_handling() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, fake_home, _project_dir) = setup_preset_test_env();

    // Test removing a preset that doesn't exist
    let mut cmd_remove = Command::cargo_bin("rdump")?;
    cmd_remove.env("RDUMP_TEST_CONFIG_DIR", &fake_home);
    // Note: We have to create an empty config file first for the remove error to trigger
    let config_dir = fake_home.join("rdump");
    fs::create_dir_all(&config_dir)?;
    fs::write(config_dir.join("config.toml"), "")?;
    cmd_remove.arg("preset").arg("remove").arg("no-such-preset");

    cmd_remove
        .assert()
        .failure()
        .stderr(predicate::str::contains(
            "Preset 'no-such-preset' not found",
        ));

    Ok(())
}

#[test]
fn test_search_with_or_operator() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    cmd.arg("search").arg("ext:rs | contains:text");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("other.txt"));
    Ok(())
}

#[test]
fn test_output_to_file_disables_color() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_test_dir();
    let output_path = root.join("output.txt");

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg("ext:rs")
        .arg("--output")
        .arg(&output_path);

    // Even though the default is Auto, writing to a file should disable color.
    cmd.assert().success();

    let output_content = fs::read_to_string(&output_path)?;
    assert!(
        !output_content.contains("\x1b["),
        "Output to file should not contain ANSI color codes by default"
    );
    assert!(
        output_content.contains("fn main()"),
        "Output file should contain the matched content"
    );

    Ok(())
}

#[test]
fn test_output_to_file_forced_color() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_test_dir();
    let output_path = root.join("output_forced.txt");

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg("ext:rs")
        .arg("--output")
        .arg(&output_path)
        .arg("--color=always"); // Force color

    cmd.assert().success();

    let output_content = fs::read_to_string(&output_path)?;
    assert!(
        output_content.contains("\x1b["),
        "Output to file with --color=always should contain ANSI color codes"
    );

    Ok(())
}

---

File: ./tests/common.rs
---
#![allow(dead_code)] // a-llow dead code for this common helper module

use std::fs;
use std::io::Write;
use tempfile::tempdir;
use tempfile::TempDir;

/// A helper to set up a temporary directory with a multi-language sample project.
pub fn setup_test_project() -> TempDir {
    let dir = tempdir().unwrap();
    let src_dir = dir.path().join("src");
    fs::create_dir(&src_dir).unwrap();

    let main_rs_content = r#"
#[macro_use]
mod macros;
mod lib;
mod traits;

// TODO: Refactor this later
use crate::lib::{User, Role};

struct Cli {
    pattern: String,
}

impl Cli {
    fn new() -> Self { Self { pattern: "".into() } }
}

pub fn main() {
    // This is the main function
    let _u = User::new();
    println!("Hello, world!");
    my_macro!();
}
"#;
    let mut main_rs = fs::File::create(src_dir.join("main.rs")).unwrap();
    main_rs.write_all(main_rs_content.as_bytes()).unwrap();

    let lib_rs_content = r#"
// This is a library file.
use serde::Serialize;

pub type UserId = u64;

pub struct User {
    id: UserId,
    name: String,
}

impl User {
    pub fn new() -> Self {
        Self { id: 0, name: "".into() }
    }
}

pub enum Role {
    Admin,
    User,
}
"#;
    let mut lib_rs = fs::File::create(src_dir.join("lib.rs")).unwrap();
    lib_rs.write_all(lib_rs_content.as_bytes()).unwrap();

    let readme_md_content = "# Test Project\nThis is a README for Role and User structs.";
    let mut readme_md = fs::File::create(dir.path().join("README.md")).unwrap();
    readme_md.write_all(readme_md_content.as_bytes()).unwrap();

    // --- Add a Python file ---
    let py_content = r#"
# FIXME: Hardcoded path
import os

class Helper:
    def __init__(self):
        self.path = "/tmp/data"
        self.do_setup()

    def do_setup(self):
        print("Setup complete")

def run_helper():
    h = Helper()
    return h.path

if __name__ == "__main__":
    run_helper()
"#;
    let mut py_file = fs::File::create(dir.path().join("helper.py")).unwrap();
    py_file.write_all(py_content.as_bytes()).unwrap();

    // --- Add JS and TS files ---
    let js_content = r#"
// HACK: for demo purposes
import { a } from './lib';

export class OldLogger {
    log(msg) { console.log("logging: " + msg); }
}

const logger = new OldLogger();
logger.log("init");
"#;
    fs::File::create(src_dir.join("logger.js"))
        .unwrap()
        .write_all(js_content.as_bytes())
        .unwrap();

    let ts_content = r#"
// REVIEW: Use a real logging library
import * as path from 'path';

export interface ILog {
    message: string;
}

export type LogLevel = "info" | "warn" | "error";

export function createLog(message: string): ILog {
    const newLog = { message };
    console.log(newLog);
    return newLog;
}
"#;
    fs::File::create(src_dir.join("log_utils.ts"))
        .unwrap()
        .write_all(ts_content.as_bytes())
        .unwrap();

    // --- Add a Go file ---
    let go_content = r#"
package main

import "fmt"

// Server represents our HTTP server.
type Server struct {
	Address string
}

func NewServer(addr string) *Server {
	return &Server{Address: addr}
}

func main() {
	server := NewServer(":8080")
	fmt.Println(server.Address)
}
"#;
    fs::File::create(src_dir.join("main.go"))
        .unwrap()
        .write_all(go_content.as_bytes())
        .unwrap();

    // --- Add a Java file ---
    let java_dir = dir.path().join("src/main/java/com/example");
    fs::create_dir_all(&java_dir).unwrap();
    let java_content = r#"
package com.example;

import java.util.ArrayList;

/**
 * Main application class.
 * HACK: This is just for a test.
 */
public class Application {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        System.out.println("Hello from Java!");
    }
}
"#;
    fs::File::create(java_dir.join("Application.java"))
        .unwrap()
        .write_all(java_content.as_bytes())
        .unwrap();

    let traits_rs_content = r#"
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
"#;
    let mut traits_rs = fs::File::create(src_dir.join("traits.rs")).unwrap();
    traits_rs.write_all(traits_rs_content.as_bytes()).unwrap();

    let macros_rs_content = r#"
#[macro_export]
macro_rules! my_macro {
    () => {
        println!("This is my macro!");
    };
}
"#;
    let mut macros_rs = fs::File::create(src_dir.join("macros.rs")).unwrap();
    macros_rs.write_all(macros_rs_content.as_bytes()).unwrap();

    // --- Add React Test Files ---
    let app_tsx_content = r#"
import React, { useState } from 'react';
import { Button } from './Button';
import useAuth from './useAuth';

// A simple component
function App() {
  const [count, setCount] = useState(0);
  const { user } = useAuth();

  return (
    <div>
      <h1>Welcome, {user?.name}</h1>
      <p>Count: {count}</p>
      <Button onClick={() => setCount(c => c + 1)} disabled={false} />
    </div>
  );
}
export default App;
"#;
    fs::File::create(src_dir.join("App.tsx"))
        .unwrap()
        .write_all(app_tsx_content.as_bytes())
        .unwrap();

    let button_jsx_content = r#"
// A button component
export const Button = ({ onClick, disabled }) => {
  return <button onClick={onClick} disabled={disabled}>Click Me</button>;
};
"#;
    fs::File::create(src_dir.join("Button.jsx"))
        .unwrap()
        .write_all(button_jsx_content.as_bytes())
        .unwrap();

    let hook_ts_content = r#"
// A custom hook
export default function useAuth() {
  return { user: { name: 'Guest' } };
}
"#;
    fs::File::create(src_dir.join("useAuth.ts"))
        .unwrap()
        .write_all(hook_ts_content.as_bytes())
        .unwrap();

    dir
}

---

File: ./tests/complex_queries.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs;
use std::io::Write;
use std::process::Command;
use tempfile::tempdir;

fn setup_test_dir() -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let root = dir.path().to_path_buf();

    fs::File::create(root.join("a.log"))
        .unwrap()
        .write_all(b"[error] something went wrong")
        .unwrap();

    fs::File::create(root.join("b.txt"))
        .unwrap()
        .write_all(b"this is a test")
        .unwrap();

    fs::File::create(root.join("important.log"))
        .unwrap()
        .write_all(b"[warn] something might be wrong")
        .unwrap();

    fs::create_dir(root.join("old")).unwrap();
    fs::File::create(root.join("old/old_file.txt"))
        .unwrap()
        .write_all(b"this is an old error")
        .unwrap();

    fs::File::create(root.join("exact_size_123.bin"))
        .unwrap()
        .write_all(&[0; 123])
        .unwrap();

    (dir, root)
}

#[test]
fn test_deeply_nested_query() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg(r#"((name:"*.log" or name:"*.txt") and (contains:"error" or contains:"warn")) and not (path:"old")"#);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("a.log"))
        .stdout(predicate::str::contains("important.log"))
        .stdout(predicate::str::contains("old_file.txt").not());
}

#[test]
fn test_query_with_mixed_case_operators() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search").arg(r#"name:"*.log" AND contains:"error""#);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("a.log"));
}

#[test]
fn test_exact_size_query() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search").arg(r#"size:"=123""#);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("exact_size_123.bin"));
}

#[test]
fn test_empty_file_size_query() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search").arg(r#"size:"=0""#);

    cmd.assert().success().stdout(predicate::str::is_empty());
}

---

File: ./tests/contains_predicate.rs
---


// In rdump/tests/contains_predicate.rs

use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_contains_simple() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("contains:\"main function\"")
        .assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("main function").from_utf8());
}

#[test]
fn test_contains_case_insensitivity() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("contains:\"MAIN FUNCTION\"")
        .assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("main function").from_utf8());
}

#[test]
fn test_contains_no_results() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("contains:\"this should not be found\"")
        .assert()
        .success()
        .stdout(predicate::str::is_empty());
}

#[test]
fn test_contains_with_other_predicates() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("contains:\"main function\" and ext:rs")
        .assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("main.go").not());
}


---

File: ./tests/extended_cli.rs
---
// In rdump/tests/extended_cli.rs

use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs;
use std::io::Write;
use std::process::Command;
use tempfile::tempdir;

/// Helper to create a directory with a few files for testing complex queries.
fn setup_query_test_dir() -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let root = dir.path().to_path_buf();

    // A file that will match multiple criteria (44 bytes)
    fs::File::create(root.join("main.rs"))
        .unwrap()
        .write_all(b"// main file\nfn main() {\n    println!(\"hello\");\n}")
        .unwrap();

    // A file with a different name but similar content (44 bytes)
    fs::File::create(root.join("utils.rs"))
        .unwrap()
        .write_all(b"// utility file\nfn helper() {\n    println!(\"world\");\n}")
        .unwrap();

    // A file to test case-insensitivity (8 bytes)
    fs::File::create(root.join("README.md"))
        .unwrap()
        .write_all(b"# Readme")
        .unwrap();

    (dir, root)
}

#[test]
fn test_complex_query_with_grouping() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_query_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    // Query: (contains:"main" or contains:"utility") and ext:rs
    cmd.arg("search")
        .arg("(contains:main | contains:utility) & ext:rs");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("utils.rs"))
        .stdout(predicate::str::contains("README.md").not());

    Ok(())
}

#[test]
fn test_name_predicate_case_insensitivity() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_query_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    // Query: name should match "readme.md" case-insensitively by default
    cmd.arg("search").arg("name:readme.md");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("README.md"));

    Ok(())
}

#[test]
fn test_matches_predicate_with_regex() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_query_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    // Query: matches a regex pattern for "hello" or "world"
    cmd.arg("search").arg("matches:\"(hello|world)\"");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("utils.rs"))
        .stdout(predicate::str::contains("README.md").not());

    Ok(())
}

#[test]
fn test_size_predicate() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_query_test_dir();

    // Test for files greater than 40 bytes
    let mut cmd_gt = Command::cargo_bin("rdump")?;
    cmd_gt.current_dir(&root);
    cmd_gt.arg("search").arg("size:>40b").arg("--format=paths");

    let output_gt = cmd_gt.output()?.stdout;
    let output_gt_str = String::from_utf8_lossy(&output_gt);
    assert_eq!(output_gt_str.lines().count(), 2, "Expected 2 files greater than 40 bytes, found: {}", output_gt_str);


    // Test for files less than 40 bytes
    let mut cmd_lt = Command::cargo_bin("rdump")?;
    cmd_lt.current_dir(&root);
    cmd_lt.arg("search").arg("size:<40b").arg("--format=paths");

    let output_lt = cmd_lt.output()?.stdout;
    let output_lt_str = String::from_utf8_lossy(&output_lt);
    assert_eq!(output_lt_str.lines().count(), 1, "Expected 1 file less than 40 bytes, found: {}", output_lt_str);

    Ok(())
}

#[test]
fn test_complex_predicate_combination() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_query_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    // Query: (name:main.rs or name:utils.rs) and contains:hello
    cmd.arg("search")
        .arg("(name:main.rs | name:utils.rs) & contains:hello");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("main.rs"))
        .stdout(predicate::str::contains("utils.rs").not());

    Ok(())
}

---

File: ./tests/filesystem_edge_cases.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs;
use std::io::Write;
#[cfg(unix)]
use std::os::unix::fs::symlink;
use std::process::Command;
use tempfile::tempdir;

#[test]
#[cfg(unix)] // Symlinks are best tested on Unix-like systems.
fn test_search_does_not_follow_symlinks_by_default() {
    let dir = tempdir().unwrap();
    let root = dir.path();

    let target_file = root.join("target.txt");
    fs::write(&target_file, "content").unwrap();

    let symlink_path = root.join("link.txt");
    symlink(&target_file, &symlink_path).unwrap();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(root);
    cmd.arg("search")
        .arg("--format=paths")
        .arg("contains:content");

    // The output should contain the real file but NOT the symlink.
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("target.txt"))
        .stdout(predicate::str::contains("link.txt").not());
}

#[test]
fn test_search_handles_invalid_utf8_file_gracefully() {
    let dir = tempdir().unwrap();
    let root = dir.path();

    let invalid_path = root.join("invalid.bin");
    let mut file = fs::File::create(&invalid_path).unwrap();
    // Write an invalid UTF-8 byte sequence (0xC3 followed by a non-continuation byte).
    file.write_all(&[0x41, 0x42, 0xC3, 0x28, 0x43, 0x44])
        .unwrap();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(root);
    // This query forces the tool to read the file content.
    cmd.arg("search").arg("contains:any");

    // The tool should not panic. It should report an error and exit.
    cmd.assert()
        .failure()
        .stdout(predicate::str::is_empty())
        .stderr(predicate::str::contains("Error evaluating file"));
}

---

File: ./tests/formatter.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs;
use std::io::Write;
use std::process::Command;
use tempfile::tempdir;

#[test]
fn test_formatter_merges_overlapping_hunks() {
    let dir = tempdir().unwrap();
    let root = dir.path();
    let file_path = root.join("test.txt");

    // Create a file where two matches are close enough that their contexts will overlap.
    let content = "line 1\nline 2 (match 1)\nline 3\nline 4 (match 2)\nline 5\n";
    fs::write(&file_path, content).unwrap();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(root);
    // Query for "match", with a context of 1 line (-C 1).
    // The context for "match 1" is lines 1-3.
    // The context for "match 2" is lines 3-5.
    // These overlap on line 3 and should be merged.
    cmd.arg("search")
        .arg("contains:match")
        .arg("-C")
        .arg("1");

    // The output should be a single, continuous block from line 1 to 5.
    // Crucially, it should NOT contain the "..." separator that would
    // appear if the hunks were printed separately.
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("line 1"))
        .stdout(predicate::str::contains("line 2 (match 1)"))
        .stdout(predicate::str::contains("line 3"))
        .stdout(predicate::str::contains("line 4 (match 2)"))
        .stdout(predicate::str::contains("line 5"))
        .stdout(predicate::str::contains("...").not());
}

---

File: ./tests/go_search.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_struct_predicate_go() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("struct:Server & ext:go")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/main.go"))
        .stdout(predicate::str::contains("type Server struct"));
}

#[test]
fn test_func_and_call_predicates_go() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("func:NewServer | call:NewServer")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            "func NewServer(addr string) *Server",
        ))
        .stdout(predicate::str::contains("server := NewServer(\":8080\")"));
}

#[test]
fn test_import_and_comment_predicates_go() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("import:fmt & comment:\"HTTP server\"")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/main.go"));
}

#[test]
fn test_struct_not_found_go() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("struct:NonExistent & ext:go")
        .assert()
        .success()
        .stdout(predicate::str::is_empty());
}

---

File: ./tests/hunks_format_test.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs;
use std::io::Write;
use std::process::Command;
use tempfile::tempdir;

fn setup_hunks_test_dir() -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let root = dir.path().to_path_buf();

    let file_path = root.join("test.txt");
    let mut file = fs::File::create(&file_path).unwrap();
    writeln!(file, "line 1").unwrap();
    writeln!(file, "line 2").unwrap();
    writeln!(file, "line 3").unwrap();
    writeln!(file, "line 4").unwrap();
    writeln!(file, "line 5").unwrap();

    (dir, root)
}

#[test]
fn test_hunks_format() -> Result<(), Box<dyn std::error::Error>> {
    let (_dir, root) = setup_hunks_test_dir();

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg("contains:'line 3'")
        .arg("--format")
        .arg("hunks")
        .arg("-C")
        .arg("1");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("line 2"))
        .stdout(predicate::str::contains("line 3"))
        .stdout(predicate::str::contains("line 4"))
        .stdout(predicate::str::contains("line 1").not())
        .stdout(predicate::str::contains("line 5").not());

    Ok(())
}

---

File: ./tests/ignore.rs
---

// In rdump/tests/ignore.rs

use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use std::io::Write;
use std::process::{Command as StdCommand, Stdio};
use tempfile::tempdir;

#[test]
fn test_rdumpignore() -> Result<(), Box<dyn std::error::Error>> {
    let dir = tempdir()?;
    let root = dir.path();

    // Create a file that should be ignored
    fs::File::create(root.join("ignored.txt"))?
        .write_all(b"This should be ignored.")?;

    // Create a file that should not be ignored
    fs::File::create(root.join("not_ignored.txt"))?
        .write_all(b"This should not be ignored.")?;

    // Create a .rdumpignore file
    fs::File::create(root.join(".rdumpignore"))?
        .write_all(b"ignored.txt")?;

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(root);
    cmd.arg("search").arg("contains:\"This should be ignored.\"");

    cmd.assert()
        .success()
        .stdout(predicate::str::is_empty());

    Ok(())
}

#[test]
fn test_rdumpignore_excludes_matching_pattern() -> Result<(), Box<dyn std::error::Error>> {
    let dir = tempdir()?;
    let root = dir.path();

    fs::File::create(root.join("app.log"))?.write_all(b"log content")?;
    fs::File::create(root.join(".rdumpignore"))?.write_all(b"*.log")?;

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(root);
    cmd.arg("search").arg("ext:log");

    cmd.assert()
        .success()
        .stdout(predicate::str::is_empty());

    Ok(())
}

#[test]
fn test_rdumpignore_unignore_overrides_gitignore() -> Result<(), Box<dyn std::error::Error>> {
    let dir = tempdir()?;
    let root = dir.path();

    // Initialize a git repository so .gitignore is respected
    StdCommand::new("git")
        .arg("init")
        .current_dir(root)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()?;

    fs::File::create(root.join("main.log"))?.write_all(b"main log")?;
    fs::File::create(root.join("debug.log"))?.write_all(b"debug log")?;

    fs::File::create(root.join(".gitignore"))?.write_all(b"*.log")?;
    fs::File::create(root.join(".rdumpignore"))?.write_all(b"!main.log")?;

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(root);
    cmd.arg("search").arg("ext:log");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("main.log"))
        .stdout(predicate::str::contains("debug.log").not());

    Ok(())
}

#[test]
fn test_rdumpignore_unignore_overrides_default_ignores() -> Result<(), Box<dyn std::error::Error>> {
    let dir = tempdir()?;
    let root = dir.path();

    let target_dir = root.join("target");
    fs::create_dir(&target_dir)?;
    fs::File::create(target_dir.join("build_info.txt"))?.write_all(b"build info")?;

    fs::File::create(root.join(".rdumpignore"))?.write_all(b"!target/")?;

    let mut cmd = Command::cargo_bin("rdump")?;
    cmd.current_dir(root);
    cmd.arg("search").arg("path:build_info");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("build_info.txt"));

    Ok(())
}

---

File: ./tests/java_search.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_class_predicate_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("class:Application & ext:java")
        .assert()
        .success()
        .stdout(predicate::str::contains("Application.java"))
        .stdout(predicate::str::contains("public class Application"));
}

#[test]
fn test_func_and_call_predicates_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("func:main & call:println")
        .assert()
        .success()
        .stdout(predicate::str::contains("Application.java"));
}

#[test]
fn test_import_and_comment_predicates_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("import:ArrayList & comment:HACK")
        .assert()
        .success()
        .stdout(predicate::str::contains("Application.java"));
}

#[test]
fn test_str_predicate_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("str:\"Hello from Java!\"")
        .assert()
        .success()
        .stdout(predicate::str::contains("Application.java"));
}

#[test]
fn test_class_not_found_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("class:NonExistent & ext:java")
        .assert()
        .success()
        .stdout(predicate::str::is_empty());
}

---

File: ./tests/js_ts_search.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_def_finds_javascript_class() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("def:OldLogger");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("logger.js"))
        .stdout(predicate::str::contains("export class OldLogger"))
        .stdout(predicate::str::contains("log_utils.ts").not());
}

#[test]
fn test_def_finds_typescript_interface_and_type() {
    let dir = setup_test_project();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path())
        .arg("search")
        .arg("def:ILog | def:LogLevel");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("log_utils.ts"))
        .stdout(predicate::str::contains("interface ILog"))
        .stdout(predicate::str::contains(
            r#"type LogLevel = "info" | "warn" | "error";"#,
        ));
}

#[test]
fn test_func_finds_typescript_function() {
    let dir = setup_test_project();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path())
        .arg("search")
        .arg("func:createLog");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("log_utils.ts"))
        .stdout(predicate::str::contains("export function createLog"));
}

#[test]
fn test_import_finds_typescript_import() {
    let dir = setup_test_project();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path())
        .arg("search")
        .arg("import:path & ext:ts");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("log_utils.ts"))
        .stdout(predicate::str::contains("import * as path from 'path';"));
}

#[test]
fn test_call_predicate_javascript() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("call:log & ext:js")
        .assert()
        .success()
        .stdout(predicate::str::contains("logger.js"))
        .stdout(predicate::str::contains("logger.log(\"init\");"));
}

#[test]
fn test_call_predicate_typescript() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("call:log & ext:ts")
        .assert()
        .success()
        .stdout(predicate::str::contains("log_utils.ts"))
        .stdout(predicate::str::contains("console.log(newLog);"));
}

#[test]
fn test_comment_predicate_typescript() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("comment:REVIEW")
        .assert()
        .success()
        .stdout(predicate::str::contains("log_utils.ts"));
}

#[test]
fn test_str_predicate_javascript() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("str:logging:")
        .assert()
        .success()
        .stdout(predicate::str::contains("logger.js"));
}

#[test]
fn test_interface_and_type_predicates_typescript() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("interface:ILog & type:LogLevel")
        .assert()
        .success()
        .stdout(predicate::str::contains("log_utils.ts"));
}

#[test]
fn test_def_not_found_js_ts() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("def:NonExistent & (ext:js | ext:ts)")
        .assert()
        .success()
        .stdout(predicate::str::is_empty());
}

---

File: ./tests/macos_debug.rs
---
// tests/macos_debug.rs

extern crate rdump;

use rdump::parser::{Parser, RqlParser, Rule};


#[test]
fn test_macos_problematic_query() {
    let query = "in:**/shared/*/use-boolean and ext:ts";
    let result = RqlParser::parse(Rule::query, query);
    assert!(result.is_ok(), "Parser failed to parse the query '{:?}'. Error: {:?}", query, result.err().unwrap());
}

---

File: ./tests/matches_predicate.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs;
use std::io::Write;
use std::process::Command;
use tempfile::tempdir;

fn setup_test_dir() -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let root = dir.path().to_path_buf();

    fs::File::create(root.join("file1.txt"))
        .unwrap()
        .write_all(b"hello world\n(hello world)\nHELLO WORLD")
        .unwrap();

    fs::File::create(root.join("file2.txt"))
        .unwrap()
        .write_all(b"this is a test\nfoo bar baz")
        .unwrap();

    fs::File::create(root.join("unicode.txt"))
        .unwrap()
        .write_all("こんにちは世界\n你好世界".as_bytes())
        .unwrap();

    (dir, root)
}

#[test]
fn test_matches_with_special_characters() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg(r#"matches:'\(hello world\)'"#);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("file1.txt"));
}

#[test]
fn test_matches_multiple_lines() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg(r#"matches:'hello world'"#);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("hello world\n(hello world)"));
}

#[test]
fn test_matches_no_match() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg(r#"matches:'goodbye world'"#);

    cmd.assert().success().stdout(predicate::str::is_empty());
}

#[test]
fn test_matches_case_insensitive() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg(r#"matches:'(?i)hello world'"#);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("file1.txt"))
        .stdout(predicate::str::contains("hello world\n(hello world)\nHELLO WORLD"));
}

#[test]
fn test_matches_unicode() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search")
        .arg(r#"matches:'こんにちは世界'"#);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("unicode.txt"));
}

#[test]
fn test_invalid_regex() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search").arg(r#"matches:'('"#);

    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("regex parse error"));
}

---

File: ./tests/modified_predicate.rs
---

use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs::File;
use std::process::Command;
use std::thread;
use std::time::Duration;
use tempfile::tempdir;

fn setup_test_dir() -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempdir().unwrap();
    let root = dir.path().to_path_buf();

    // Create files with different modification times
    thread::sleep(Duration::from_secs(2));
    File::create(root.join("old.txt")).unwrap();
    thread::sleep(Duration::from_secs(2));
    File::create(root.join("recent.txt")).unwrap();

    (dir, root)
}

#[test]
fn test_modified_after() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search").arg("modified:>1s");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("recent.txt"))
        .stdout(predicate::str::contains("old.txt").not());
}

#[test]
fn test_modified_before() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search").arg("modified:<1s");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("old.txt"))
        .stdout(predicate::str::contains("recent.txt").not());
}

#[test]
fn test_modified_exact_date() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    let now = chrono::Local::now().format("%Y-%m-%d").to_string();
    cmd.arg("search").arg(format!("modified:{}", now));

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("recent.txt"))
        .stdout(predicate::str::contains("old.txt"));
}

#[test]
fn test_invalid_date_format() {
    let (_dir, root) = setup_test_dir();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(&root);
    cmd.arg("search").arg("modified:invalid-date");

    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("Invalid date format"));
}

---

File: ./tests/path_predicate.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::fs;
use std::process::Command;
use tempfile::tempdir;

#[test]
fn test_path_glob_respects_directory_boundaries() {
    let dir = tempdir().unwrap();
    let root = dir.path();

    let sub_dir = root.join("sub");
    fs::create_dir(&sub_dir).unwrap();
    fs::File::create(sub_dir.join("deep_file.rs")).unwrap();
    fs::File::create(root.join("root_file.rs")).unwrap();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(root);
    // FIX: Use a combination of `in` and `name` to correctly express "files in this directory".
    // `in:.` constrains the search to the current directory (and is now non-recursive).
    // `name:*.rs` applies the glob to the filename only.
    cmd.arg("search")
        .arg("--format=paths")
        .arg("in:. & name:*.rs");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("root_file.rs"))
        .stdout(predicate::str::contains("deep_file.rs").not());
}

#[test]
fn test_path_globstar_crosses_directory_boundaries() {
    let dir = tempdir().unwrap();
    let root = dir.path();

    let sub_dir = root.join("sub");
    fs::create_dir(&sub_dir).unwrap();
    fs::File::create(sub_dir.join("deep_file.rs")).unwrap();
    fs::File::create(root.join("root_file.rs")).unwrap();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(root);
    // This globstar (**) should match files at any depth.
    cmd.arg("search")
        .arg("--format=paths")
        .arg("path:**/*.rs");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("root_file.rs"))
        .stdout(predicate::str::contains("deep_file.rs"));
}

---

File: ./tests/python_search.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_def_finds_python_class() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("def:Helper & ext:py");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("helper.py"))
        .stdout(predicate::str::contains("class Helper"))
        .stdout(predicate::str::contains("src/main.rs").not());
}

#[test]
fn test_func_finds_python_function() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("func:run_helper");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("helper.py"))
        .stdout(predicate::str::contains("def run_helper()"))
        .stdout(predicate::str::contains("src/main.rs").not());
}

#[test]
fn test_import_finds_python_import() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("import:os & ext:py");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("helper.py"))
        .stdout(predicate::str::contains("import os"))
        .stdout(predicate::str::contains("src/lib.rs").not());
}

#[test]
fn test_comment_and_class_predicates_python() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("comment:FIXME & class:Helper")
        .assert()
        .success()
        .stdout(predicate::str::contains("helper.py"));
}

#[test]
fn test_str_predicate_python() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("str:/tmp/data")
        .assert()
        .success()
        .stdout(predicate::str::contains("helper.py"));
}

#[test]
fn test_call_predicate_python() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("call:run_helper | call:do_setup")
        .assert()
        .success()
        .stdout(predicate::str::contains("self.do_setup()"))
        .stdout(predicate::str::contains("run_helper()"));
}

#[test]
fn test_def_not_found_python() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("def:NonExistent & ext:py")
        .assert()
        .success()
        .stdout(predicate::str::is_empty());
}

---

File: ./tests/react_comprehensive_search.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

// This test suite queries the `insane_test_bed/react_comprehensive.tsx` file.

fn rdump_search() -> Command {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=hunks")
        // Always target the specific test file to keep tests focused
        .arg("path:react_comprehensive.tsx");
    cmd
}

#[test]
fn test_finds_class_component() {
    rdump_search()
        .arg("&")
        .arg("component:ClassComponent")
        .assert()
        .success()
        .stdout(predicate::str::contains("export class ClassComponent"));
}

#[test]
fn test_finds_memoized_component() {
    rdump_search()
        .arg("&")
        .arg("component:MemoizedComponent")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            "export const MemoizedComponent = React.memo",
        ));
}

#[test]
fn test_finds_all_custom_hook_definitions() {
    let mut cmd = rdump_search();
    cmd.arg("&").arg("customhook:."); // Wildcard match
    let output = cmd.output().unwrap();
    let stdout = String::from_utf8(output.stdout).unwrap();

    // Should find both useCounter and useWindowWidth
    assert!(stdout.contains("function useCounter("));
    assert!(stdout.contains("const useWindowWidth = () =>"));
    assert_eq!(stdout.matches("File:").count(), 1); // Both in the same file
}

#[test]
fn test_finds_specific_custom_hook_definition() {
    rdump_search()
        .arg("&")
        .arg("customhook:useWindowWidth")
        .assert()
        .success()
        .stdout(predicate::str::contains("const useWindowWidth = () =>"))
        .stdout(predicate::str::contains("function useCounter").not());
}

#[test]
fn test_finds_all_hook_calls() {
    let mut cmd = rdump_search();
    cmd.arg("&").arg("hook:."); // Wildcard match
    let output = cmd.output().unwrap();
    let stdout = String::from_utf8(output.stdout).unwrap();

    // Should find all hook calls
    assert!(stdout.contains("useState(initialValue)"));
    assert!(stdout.contains("useState(window.innerWidth)"));
    assert!(stdout.contains("useEffect(() => {"));
    assert!(stdout.contains("useMemo(() => {"));
    assert!(stdout.contains("useCounter(10)"));
    assert!(stdout.contains("useWindowWidth()"));
    assert!(stdout.contains("useRef<HTMLInputElement>(null)"));
    assert!(stdout.contains("useContext(ThemeContext)"));
    assert!(stdout.contains("useCallback(() => {"));
}

#[test]
fn test_finds_specific_built_in_hook_call() {
    rdump_search()
        .arg("&")
        .arg("hook:useEffect")
        .assert()
        .success()
        .stdout(predicate::str::contains("useEffect(() => {"));
}

#[test]
fn test_finds_jsx_element_and_prop() {
    rdump_search()
        .arg("&")
        .arg("element:input & prop:id")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            r#"<input ref={inputRef} id="test-input" type="text" />"#,
        ));
}

#[test]
fn test_finds_custom_component_element() {
    rdump_search()
        .arg("&")
        .arg("element:ClassComponent")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            r#"<ClassComponent title="Class Component Title" />"#,
        ));
}

#[test]
fn test_finds_namespaced_svg_element() {
    // Note: The current tree-sitter grammar for TSX might parse `SVG.Circle`
    // as a single identifier `SVG.Circle` or as a member expression.
    // The query `element:SVG.Circle` should work if it's parsed as an identifier.
    // If it's a member expression, a more complex query might be needed,
    // but the current implementation handles identifiers well.
    rdump_search()
        .arg("&")
        .arg("element:SVG.Circle")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            r#"<SVG.Circle cx="50" cy="50" r="40" stroke="green" fill="yellow" />"#,
        ));
}

#[test]
fn test_negation_of_react_predicate() {
    // Find files that are TSX but DO NOT define a 'ClassComponent'
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=paths")
        .arg("ext:tsx & !component:ClassComponent");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("react_comprehensive.tsx").not())
        // It should find App.tsx which is a .tsx file but doesn't define ClassComponent
        .stdout(predicate::str::contains("App.tsx"));
}

#[test]
fn test_find_component_with_specific_hook() {
    // Find a component that uses the `useMemo` hook.
    rdump_search()
        .arg("&")
        .arg("component:MemoizedComponent & hook:useMemo")
        .assert()
        .success()
        // The output should contain the whole component definition because both predicates match the file
        // and the hunks are combined.
        .stdout(predicate::str::contains("export const MemoizedComponent"))
        .stdout(predicate::str::contains("const calculated = useMemo("));
}

#[test]
fn test_find_jsx_comment() {
    // Note: Tree-sitter grammars might parse JSX comments differently from regular comments.
    // This tests if the `comment` predicate is correctly configured for JSX contexts.
    // TSX grammar does not have a dedicated `jsx_comment` node, it's just `comment`.
    rdump_search()
        .arg("&")
        .arg("comment:\"A JSX comment\"")
        .assert()
        .success()
        .stdout(predicate::str::contains("// A JSX comment"));
}

#[test]
fn test_find_prop_with_boolean_value() {
    rdump_search()
        .arg("&")
        .arg("element:button & prop:disabled")
        .assert()
        .success()
        .stdout(predicate::str::contains("disabled={false}"));
}

---

File: ./tests/react_search.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_component_predicate_finds_functional_component() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("component:App & ext:tsx")
        .assert()
        .success()
        .stdout(predicate::str::contains("function App()"));
}

#[test]
fn test_component_predicate_finds_arrow_function_component() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("component:Button & ext:jsx")
        .assert()
        .success()
        .stdout(predicate::str::contains("export const Button"));
}

#[test]
fn test_element_predicate_finds_html_element() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("element:h1 & ext:tsx")
        .assert()
        .success()
        .stdout(predicate::str::contains("<h1>Welcome, {user?.name}</h1>"));
}

#[test]
fn test_element_predicate_finds_component_element() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("element:Button & ext:tsx")
        .assert()
        .success()
        .stdout(predicate::str::contains("<Button onClick="));
}

#[test]
fn test_hook_predicate_finds_built_in_hook() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("hook:useState")
        .assert()
        .success()
        .stdout(predicate::str::contains("const [count, setCount] = useState(0);"));
}

#[test]
fn test_hook_predicate_finds_custom_hook_call() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("hook:useAuth")
        .assert()
        .success()
        .stdout(predicate::str::contains("const { user } = useAuth();"));
}

#[test]
fn test_customhook_predicate_finds_hook_definition() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("customhook:useAuth")
        .assert()
        .success()
        .stdout(predicate::str::contains("export default function useAuth()"));
}

#[test]
fn test_prop_predicate_finds_prop() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("prop:onClick")
        .assert()
        .success()
        .stdout(predicate::str::contains("<Button onClick={")) // In App.tsx
        .stdout(predicate::str::contains("<button onClick={onClick}")); // In Button.jsx
}

#[test]
fn test_react_and_logic_across_predicates() {
    let dir = setup_test_project();
    // Find a Button element that is also passed a `disabled` prop.
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("element:Button & prop:disabled")
        .assert()
        .success()
        .stdout(predicate::str::contains("App.tsx"))
        .stdout(predicate::str::contains("Button.jsx").not());
}

---

File: ./tests/rust_search.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_def_finds_struct_in_correct_file() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("def:Cli"); // Query for the Cli struct

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs"))
        .stdout(predicate::str::contains("struct Cli"))
        .stdout(predicate::str::contains("src/lib.rs").not());
}

#[test]
fn test_def_finds_enum_in_correct_file() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("def:Role"); // Query for the Role enum

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("src/lib.rs"))
        .stdout(predicate::str::contains("pub enum Role"))
        .stdout(predicate::str::contains("src/main.rs").not());
}

#[test]
fn test_def_with_ext_predicate_and_paths_format() {
    let dir = setup_test_project();
    let root = dir.path();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(root);
    cmd.arg("search").arg("def:User & ext:rs");
    cmd.arg("--format=paths");

    // Normalize path for cross-platform compatibility
    let expected_path_str = format!("src{}lib.rs", std::path::MAIN_SEPARATOR);

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(expected_path_str));
}

#[test]
fn test_def_returns_no_matches_for_non_existent_item() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("def:NonExistent");

    // Should succeed with no output
    cmd.assert().success().stdout(predicate::str::is_empty());
}

#[test]
fn test_def_does_not_match_in_non_rust_files() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    // The README.md contains the words "Role" and "User"
    cmd.arg("search").arg("def:Role | def:User");

    // It should ONLY find src/lib.rs, not README.md
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("src/lib.rs"))
        .stdout(predicate::str::contains("README.md").not());
}

#[test]
fn test_func_finds_standalone_function() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("func:main");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs"))
        .stdout(predicate::str::contains("src/lib.rs").not());
}

#[test]
fn test_func_finds_impl_method() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("func:new");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("src/lib.rs"))
        .stdout(predicate::str::contains("src/main.rs"));
}

#[test]
fn test_import_finds_use_statement() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search")
        .arg("--format=markdown")
        .arg("import:serde");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("src/lib.rs"))
        .stdout(predicate::str::contains("```rs")) // Check for markdown code fence
        .stdout(predicate::str::contains("src/main.rs").not());
}

#[test]
fn test_logical_or_across_files() {
    let dir = setup_test_project();

    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search").arg("func:main | import:serde");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs"))
        .stdout(predicate::str::contains("src/lib.rs"));
}

#[test]
fn test_comment_predicate_rust() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("comment:TODO")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs"))
        .stdout(predicate::str::contains("src/lib.rs").not());
}

#[test]
fn test_str_predicate_rust() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("str:\"Hello, world!\"")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs"));
}

#[test]
fn test_type_and_struct_predicates_rust() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("type:UserId & struct:User")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/lib.rs"))
        .stdout(predicate::str::contains("src/main.rs").not());
}

#[test]
fn test_call_predicate_rust() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("call:println & ext:rs")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs")) // The call is in main.rs
        .stdout(predicate::str::contains("src/lib.rs").not()); // The definition is in lib.rs
}

#[test]
fn test_logical_operators_with_hunks() {
    let dir = setup_test_project();
    // Query: find the file that defines the `Cli` struct AND ALSO contains a `TODO` comment.
    // This should only match main.rs
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("--format=hunks")
        .arg("struct:Cli & comment:TODO")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs"))
        .stdout(predicate::str::contains("src/lib.rs").not());
}

#[test]
fn test_negation_with_hunks() {
    let dir = setup_test_project();
    // Query: find files with `User` struct but NOT containing `TODO`
    // This should only match lib.rs
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("--format=hunks")
        .arg("struct:User & !comment:TODO")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/lib.rs"))
        .stdout(predicate::str::contains("User"))
        .stdout(predicate::str::contains("src/main.rs").not());
}

#[test]
fn test_and_of_semantic_predicates() {
    let dir = setup_test_project();
    // Query: find files with a `struct` AND a `func`
    // This should only match lib.rs (User struct, new function)
    // and main.rs (Cli struct, main function)
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path());
    cmd.arg("search");
    cmd.arg("--format=paths");
    cmd.arg("struct:. & func:. & ext:rs");

    let output = cmd.output().unwrap();
    let stdout = String::from_utf8(output.stdout).unwrap();
    let lines: Vec<&str> = stdout.lines().collect();
    assert_eq!(
        lines.len(),
        3,
        "Expected exactly 3 files, but found {}: {:?}",
        lines.len(),
        lines
    );
}

#[test]
fn test_func_not_found() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("func:non_existent_function")
        .assert()
        .success()
        .stdout(predicate::str::is_empty());
}

---

File: ./tests/rust_search_macros.rs
---

use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_macro_def_predicate() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("macro:my_macro")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/macros.rs"))
        .stdout(predicate::str::contains("macro_rules! my_macro"));
}

#[test]
fn test_macro_call_predicate() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("call:my_macro")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/main.rs"))
        .stdout(predicate::str::contains("my_macro!"));
}

---

File: ./tests/rust_search_traits.rs
---

use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_trait_predicate() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("trait:Summary")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/traits.rs"))
        .stdout(predicate::str::contains("pub trait Summary"));
}

#[test]
fn test_impl_predicate() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump")
        .unwrap()
        .current_dir(dir.path())
        .arg("search")
        .arg("impl:NewsArticle")
        .assert()
        .success()
        .stdout(predicate::str::contains("src/traits.rs"))
        .stdout(predicate::str::contains("impl Summary for NewsArticle"));
}

---

File: ./tests/search_integration.rs
---
use anyhow::Result;
use rdump::{commands::search::run_search, ColorChoice, Format, SearchArgs};
use std::fs;
use std::path::Path;
use tempfile::tempdir;

/// Helper to create a default SearchArgs for testing.
/// We enable `no_ignore` and `hidden` to make tests self-contained and predictable.
fn create_test_args(root: &Path, query: &str) -> SearchArgs {
    SearchArgs {
        query: query.split(' ').map(String::from).collect(), // Split query for clap
        root: root.to_path_buf(),
        preset: vec![],
        output: None,
        line_numbers: false,
        no_headers: false,
        format: Format::Paths,
        no_ignore: true, // Crucial for hermetic tests
        hidden: true,    // Crucial for hermetic tests
        color: ColorChoice::Never,
        max_depth: None,
        context: None,
        find: false,
    }
}

/// Helper to run a search and return the relative paths of matching files.
/// NOTE: This now uses `run_search` and captures stdout, as `perform_search` is not public.
/// To make perform_search public, we'd need to adjust the `lib.rs` design.
/// For these tests, we will create a custom test helper that calls the full `run_search`
/// and returns the result, which is more of a true integration test.
///
/// Let's stick with the previous `perform_search` for simplicity and make it public.
/// The `lib.rs` change makes this possible. Let's re-import it.
use rdump::commands::search::perform_search;

fn run_test_search(root: &Path, query: &str) -> Result<Vec<String>> {
    let args = create_test_args(root, query);
    let results = perform_search(&args)?;
    let mut paths: Vec<String> = results
        .into_iter()
        .map(|(p, _)| {
            p.strip_prefix(root)
                .unwrap()
                .to_string_lossy()
                .replace('\\', "/") // Normalize for Windows
        })
        .collect();
    paths.sort();
    Ok(paths)
}

/// Sets up a standard test project structure.
fn setup_test_project() -> Result<tempfile::TempDir> {
    let dir = tempdir()?;
    let root = dir.path();

    fs::create_dir_all(root.join("src"))?;
    fs::create_dir_all(root.join("tests"))?;
    fs::create_dir_all(root.join("benches"))?;
    fs::create_dir_all(root.join("docs"))?;

    fs::write(
        root.join("src/user.rs"),
        "// TODO: Add more fields\nstruct User {}",
    )?;
    fs::write(root.join("src/order.rs"), "struct Order {}")?;
    fs::write(
        root.join("src/special.txt"),
        "the user's settings\nvalue * 2",
    )?;
    fs::write(root.join("tests/user_test.rs"), "fn test_user() {}")?;
    fs::write(root.join("benches/user.rs"), "fn bench_user() {}")?;
    fs::write(root.join("docs/api.md"), "# API Docs")?;

    Ok(dir)
}

#[test]
fn test_query_with_negated_group() -> Result<()> {
    let dir = setup_test_project()?;
    let root = dir.path();

    // Find all rust files that are NOT in the tests or benches directories.
    let query = "ext:rs & !(in:tests | in:benches)";
    let results = run_test_search(root, query)?;

    assert_eq!(results.len(), 2);
    assert_eq!(results, vec!["src/order.rs", "src/user.rs"]);
    Ok(())
}

#[test]
fn test_query_combining_semantic_and_content_predicates() -> Result<()> {
    let dir = setup_test_project()?;
    let root = dir.path();

    // Find a struct named 'User' that also has a 'TODO' comment.
    let query = "struct:User & comment:TODO";
    let results = run_test_search(root, query)?;
    assert_eq!(results, vec!["src/user.rs"]);

    // Find a struct named 'Order' that also has a 'TODO' comment (it doesn't).
    let query_no_match = "struct:Order & comment:TODO";
    let results_no_match = run_test_search(root, query_no_match)?;
    assert!(results_no_match.is_empty());

    Ok(())
}

#[test]
fn test_query_combining_metadata_and_semantic_predicates() -> Result<()> {
    let dir = setup_test_project()?;
    let root = dir.path();

    // Find a struct named 'User' but only within the 'src' directory.
    let query = "in:src & struct:User";
    let results = run_test_search(root, query)?;
    assert_eq!(results, vec!["src/user.rs"]);

    // Search for a function inside the 'docs' directory (it won't find one).
    let query_no_match = "in:docs & func:test_user";
    let results_no_match = run_test_search(root, query_no_match)?;
    assert!(results_no_match.is_empty());

    Ok(())
}

#[test]
#[cfg(unix)] // This test relies on Unix-style permissions and paths
fn test_search_fails_on_unwritable_output_path() -> Result<()> {
    let dir = setup_test_project()?;
    let root = dir.path();
    let unwritable_dir = root.join("unwritable");
    fs::create_dir(&unwritable_dir)?;

    // Make directory read-only
    let mut perms = fs::metadata(&unwritable_dir)?.permissions();
    perms.set_readonly(true);
    fs::set_permissions(&unwritable_dir, perms)?;

    let output_path = unwritable_dir.join("output.txt");

    let mut args = create_test_args(root, "ext:rs");
    args.output = Some(output_path);

    // Call the full `run_search` which attempts to create the file
    let result = run_search(args);

    assert!(result.is_err());
    let error_message = result.unwrap_err().to_string();
    assert!(
        error_message.contains("Permission denied") || error_message.contains("os error 13"),
        "Error message should indicate a permission issue"
    );

    // Set back to writable so tempdir can clean up
    let mut perms = fs::metadata(&unwritable_dir)?.permissions();
    perms.set_readonly(false);
    fs::set_permissions(&unwritable_dir, perms)?;

    Ok(())
}

#[test]
fn test_query_with_literal_glob_character() -> Result<()> {
    let dir = setup_test_project()?;
    let root = dir.path();

    // The single quotes in the RQL string are crucial
    let query = "contains:'value * 2'";
    let results = run_test_search(root, query)?;

    assert_eq!(results, vec!["src/special.txt"]);
    Ok(())
}

#[test]
fn test_query_with_escaped_quote() -> Result<()> {
    let dir = setup_test_project()?;
    let root = dir.path();

    // Using double quotes for the value allows it to contain a single quote.
    let query = "contains:\"user's settings\"";
    let results = run_test_search(root, query)?;

    assert_eq!(results, vec!["src/special.txt"]);
    Ok(())
}

---

File: ./tests/semantic_wildcard.rs
---
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

#[test]
fn test_semantic_wildcard_matches_any_struct() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=paths")
        .arg("struct:."); // The "." is the "match any" wildcard

    // Should find code.rs (has MyStruct) but not files that only use it
    // or files without structs like calls.rs or enum.rs
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("code.rs"))
        .stdout(predicate::str::contains("complex_query.rs").not())
        .stdout(predicate::str::contains("calls.rs").not())
        .stdout(predicate::str::contains("enum.rs").not());
}

#[test]
fn test_semantic_wildcard_matches_any_function() {
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.arg("search")
        .arg("--root")
        .arg("../insane_test_bed")
        .arg("--format=paths")
        .arg("func:."); // Match any function

    // Should find all files with function definitions
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("calls.rs"))
        .stdout(predicate::str::contains("code.rs"))
        .stdout(predicate::str::contains("complex_query.rs"))
        .stdout(predicate::str::contains("same_file_def_call.rs"))
        .stdout(predicate::str::contains("trait.rs"))
        .stdout(predicate::str::contains("enum.rs").not()); // enums have variants, not funcs
}
