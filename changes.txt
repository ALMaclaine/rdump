Let's do it. Completing the feature set is the right move.

Here are the complete changes to implement the `call:` predicate for JavaScript and TypeScript, including all necessary tests to ensure it's working correctly.

---

### **`rdump/src/predicates/code_aware/profiles/javascript.rs` (Modified)**

I'm adding the `tree-sitter` query for the `call:` predicate, designed to match both standard function calls and method calls.

```diff
// START rdump/src/predicates/code_aware/profiles/javascript.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the JavaScript language.
pub(super) fn create_javascript_profile() -> LanguageProfile {
    let language = tree_sitter_javascript::language();
    let mut queries = HashMap::new();

    let class_def_query = "(class_declaration name: (identifier) @match)";
    queries.insert(PredicateKey::Def, class_def_query.to_string());
    queries.insert(PredicateKey::Class, class_def_query.to_string());

    queries.insert(PredicateKey::Func, "[ (function_declaration name: (identifier) @match) (method_definition name: (property_identifier) @match) ]".to_string());
    queries.insert(
        PredicateKey::Import,
        "(import_statement) @match".to_string(),
    );
+   queries.insert(
+       PredicateKey::Call,
+       "(call_expression function: [ (identifier) @match (member_expression property: (property_identifier) @match) ])".to_string()
+   );

    queries.insert(PredicateKey::Comment, "[(comment) @match (regex) @match]".to_string()); // JS Regexes are basically comments
    queries.insert(PredicateKey::Str, "[(string) @match (template_string) @match]".to_string());

    LanguageProfile { language, queries }
}
// END rdump/src/predicates/code_aware/profiles/javascript.rs
```

### **`rdump/src/predicates/code_aware/profiles/typescript.rs` (Modified)**

The `call:` query for TypeScript is effectively the same as for JavaScript, so I'm adding it here as well.

```diff
// START rdump/src/predicates/code_aware/profiles/typescript.rs

use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the TypeScript language.
pub(super) fn create_typescript_profile() -> LanguageProfile {
    let language = tree_sitter_typescript::language_typescript();
    let mut queries = HashMap::new();

    let def_query = "[ (class_declaration name: (type_identifier) @match) (interface_declaration name: (type_identifier) @match) (type_alias_declaration name: (type_identifier) @match) (enum_declaration name: (type_identifier) @match) ]";
    queries.insert(PredicateKey::Def, def_query.to_string());
    queries.insert(PredicateKey::Class, "(class_declaration name: (type_identifier) @match)".to_string());
    queries.insert(PredicateKey::Interface, "(interface_declaration name: (type_identifier) @match)".to_string());
    queries.insert(PredicateKey::Type, "(type_alias_declaration name: (type_identifier) @match)".to_string());
    queries.insert(PredicateKey::Enum, "(enum_declaration name: (type_identifier) @match)".to_string());

    queries.insert(PredicateKey::Func, "[ (function_declaration name: (identifier) @match) (method_definition name: (property_identifier) @match) ]".to_string());
    queries.insert(
        PredicateKey::Import,
        "(import_statement) @match".to_string(),
    );
+   queries.insert(
+       PredicateKey::Call,
+       "(call_expression function: [ (identifier) @match (member_expression property: (property_identifier) @match) ])".to_string()
+   );

    queries.insert(PredicateKey::Comment, "(comment) @match".to_string());
    queries.insert(PredicateKey::Str, "[(string) @match (template_string) @match]".to_string());

    LanguageProfile { language, queries }
}
// END rdump/src/predicates/code_aware/profiles/typescript.rs
```

### **`rdump/src/predicates/mod.rs` (Modified)**

The unit tests for JavaScript and TypeScript have been updated with new code samples that include function calls, plus new assertions to verify the `call:` predicate.

```diff
// START rdump/src/predicates/mod.rs
// ... (top of file and other tests are unchanged) ...
    #[test]
    fn test_code_aware_evaluator_javascript_suite() {
        let js_code = r#"
            import { open } from 'fs/promises';

            class Logger {
                log(message) { console.log(message); }
            }

            function a() {
                const l = new Logger();
                l.log("hello");
            }
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("script.js");
        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(js_code.as_bytes()).unwrap();

        let evaluator = CodeAwareEvaluator;

        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "Logger").unwrap());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "log").unwrap());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "fs/promises").unwrap());
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Call, "Logger").unwrap(), "Should find constructor call");
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Call, "log").unwrap(), "Should find method call");
    }

    #[test]
    fn test_code_aware_evaluator_typescript_suite() {
        let ts_code = r#"
            import React from 'react';

            interface User { id: number; }
            type ID = string | number;

            class ApiClient {
                // The URL for the API
                private url = "https://api.example.com";
                fetchUser(): User | null { return null; }
            }

            const client = new ApiClient();
            client.fetchUser();
        "#;

        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("api.ts");
// ... (rest of test unchanged except for new assertions)
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "ApiClient").unwrap(), "Should find class");
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "fetchUser").unwrap());
        let mut ctx = FileContext::new(file_path.clone());
        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "React").unwrap());
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Call, "ApiClient").unwrap(), "Should find TS constructor call");
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Call, "fetchUser").unwrap(), "Should find TS method call");

        // --- Syntactic Content ---
        let mut ctx = FileContext::new(file_path.clone());
// ...
// END rdump/src/predicates/mod.rs
```

### **`tests/common.rs` (Modified)**

The project setup helper now creates JS/TS files that include function and method calls.

```diff
// START tests/common.rs
// ... (top of file unchanged) ...
    // --- NEW: Add JS and TS files ---
    let js_content = r#"
// HACK: for demo purposes
import { a } from './lib';

export class OldLogger {
    log(msg) { console.log("logging: " + msg); }
}

const logger = new OldLogger();
logger.log("init");
"#;
    fs::File::create(src_dir.join("logger.js"))
        .unwrap()
        .write_all(js_content.as_bytes())
        .unwrap();

    let ts_content = r#"
// REVIEW: Use a real logging library
import * as path from 'path';

export interface ILog {
    message: string;
}

export type LogLevel = "info" | "warn" | "error";

export function createLog(message: string): ILog {
    const newLog = { message };
    console.log(newLog);
    return newLog;
}
"#;
    fs::File::create(src_dir.join("log_utils.ts"))
        .unwrap()
// ... (rest of file unchanged)
// END tests/common.rs
```

### **`tests/js_ts_search.rs` (Modified)**

Finally, new integration tests are added to validate the `call:` predicate for both JavaScript and TypeScript end-to-end.

```diff
// START tests/js_ts_search.rs
// ... (existing tests unchanged) ...
#[test]
fn test_import_finds_typescript_import() {
    let dir = setup_test_project();
    let mut cmd = Command::cargo_bin("rdump").unwrap();
    cmd.current_dir(dir.path()).arg("import:path & ext:ts");

    cmd.assert()
        .success()
        .stdout(predicate::str::contains("log_utils.ts"))
        .stdout(predicate::str::contains("import * as path from 'path';"));
}

+#[test]
+fn test_call_predicate_javascript() {
+    let dir = setup_test_project();
+    Command::cargo_bin("rdump").unwrap()
+        .current_dir(dir.path())
+        .arg("call:log & ext:js")
+        .assert()
+        .success()
+        .stdout(predicate::str::contains("logger.js"))
+        .stdout(predicate::str::contains("logger.log(\"init\");"));
+}
+
+#[test]
+fn test_call_predicate_typescript() {
+    let dir = setup_test_project();
+    Command::cargo_bin("rdump").unwrap()
+        .current_dir(dir.path())
+        .arg("call:log & ext:ts")
+        .assert()
+        .success()
+        .stdout(predicate::str::contains("log_utils.ts"))
+        .stdout(predicate::str::contains("console.log(newLog);"));
+}
// END tests/js_ts_search.rs
```

This completes the implementation. `rdump` now has feature parity for `def`, `func`, `import`, and `call` across our four core languages: Rust, Python, JavaScript, and TypeScript. This is a powerful and consistent toolset for any developer.