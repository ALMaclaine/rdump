Absolutely. Time to conquer the enterprise. Adding Java support is a statementâ€”it shows that `rdump` is a serious tool for any environment. Our architecture is ready. Let's do this.

---

### **`rdump/Cargo.toml` (Modified)**

Adding the `tree-sitter-java` grammar crate.

```diff
// START rdump/Cargo.toml
[package]
name = "rdump"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = { version = "4.5.4", features = ["derive"] }
anyhow = "1.0.86"
ignore = "0.4.22"
rayon = "1.10.0"
regex = "1.10.4"
serde = { version = "1.0.203", features = ["derive"] }
serde_json = "1.0.117"
pest = "2.7.10"
pest_derive = "2.7.10"
tempfile = "3.20.0"
glob = "0.3.1"
dirs = "5.0.1"
toml = "0.8.12"
chrono = { version = "0.4", features = ["serde"] }
lazy_static = "1.4.0"
tree-sitter = "0.22.6"
tree-sitter-rust = "0.21.0"
tree-sitter-python = "0.21.0"
tree-sitter-javascript = "0.21.0"
tree-sitter-typescript = "0.21.0"
tree-sitter-go = "0.21.0"
+tree-sitter-java = "0.21.0"
syntect = "5.2.0"
atty = "0.2.14"

[dev-dependencies]
// ...
// END rdump/Cargo.toml
```

### **`rdump/src/predicates/code_aware/profiles/java.rs` (New File)**

This new profile contains all the `tree-sitter` queries for understanding Java syntax.

```rust
// START rdump/src/predicates/code_aware/profiles/java.rs
use super::LanguageProfile;
use crate::parser::PredicateKey;
use std::collections::HashMap;

/// Creates the profile for the Java language.
pub(super) fn create_java_profile() -> LanguageProfile {
    let language = tree_sitter_java::language();
    let mut queries = HashMap::new();

    // --- Definitions ---
    let class_query = "(class_declaration name: (identifier) @match)";
    let interface_query = "(interface_declaration name: (identifier) @match)";
    let enum_query = "(enum_declaration name: (identifier) @match)";

    queries.insert(PredicateKey::Def, format!("[ {} {} {} ]", class_query, interface_query, enum_query));
    queries.insert(PredicateKey::Class, class_query.to_string());
    queries.insert(PredicateKey::Interface, interface_query.to_string());
    queries.insert(PredicateKey::Enum, enum_query.to_string());

    // --- Functions & Calls ---
    queries.insert(PredicateKey::Func, "[ (method_declaration name: (identifier) @match) (constructor_declaration name: (identifier) @match) ]".to_string());
    queries.insert(PredicateKey::Call, "[ (method_invocation name: (identifier) @match) (object_creation_expression type: (type_identifier) @match) ]".to_string());

    // --- Other ---
    queries.insert(PredicateKey::Import, "(import_declaration) @match".to_string());
    queries.insert(PredicateKey::Comment, "[(line_comment) @match (block_comment) @match]".to_string());
    queries.insert(PredicateKey::Str, "(string_literal) @match".to_string());

    LanguageProfile { language, queries }
}
// END rdump/src/predicates/code_aware/profiles/java.rs
```

### **`rdump/src/predicates/code_aware/profiles/mod.rs` (Modified)**

Registering the new Java profile.

```diff
// START rdump/src/predicates/code_aware/profiles/mod.rs
use crate::parser::PredicateKey;
use lazy_static::lazy_static;
use std::collections::HashMap;

mod javascript;
mod python;
mod rust;
mod typescript;
mod go;
+mod java;

/// Defines the tree-sitter queries for a specific language.
pub(super) struct LanguageProfile {
// ...
lazy_static! {
    pub(super) static ref LANGUAGE_PROFILES: HashMap<&'static str, LanguageProfile> = {
        let mut m = HashMap::new();
        m.insert("rs", rust::create_rust_profile());
        m.insert("py", python::create_python_profile());
        m.insert("go", go::create_go_profile());
+       m.insert("java", java::create_java_profile());
        let ts_profile = typescript::create_typescript_profile();
        m.insert("ts", ts_profile);
        m.insert("tsx", typescript::create_typescript_profile());
// ...
// END rdump/src/predicates/code_aware/profiles/mod.rs
```

### **`rdump/src/predicates/mod.rs` (Modified)**

Adding a new unit test for the Java profile.

```diff
// START rdump/src/predicates/mod.rs
// ... (existing tests unchanged) ...
       let mut ctx = FileContext::new(file_path.clone());
       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Comment, "represents a user").unwrap());
    }

+   #[test]
+   fn test_code_aware_evaluator_java_suite() {
+       let java_code = r#"
+           package com.example;
+
+           import java.util.List;
+
+           // Represents a user
+           public class User {
+               public User() {
+                   System.out.println("User created");
+               }
+
+               public void greet() {}
+           }
+       "#;
+
+       let temp_dir = tempfile::tempdir().unwrap();
+       let file_path = temp_dir.path().join("User.java");
+       let mut file = std::fs::File::create(&file_path).unwrap();
+       file.write_all(java_code.as_bytes()).unwrap();
+
+       let evaluator = CodeAwareEvaluator;
+
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Class, "User").unwrap());
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "greet").unwrap());
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Call, "println").unwrap());
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "java.util.List").unwrap());
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Comment, "Represents a user").unwrap());
+       let mut ctx = FileContext::new(file_path.clone());
+       assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Str, "User created").unwrap());
+   }
}
// END rdump/src/predicates/mod.rs
```

### **`tests/common.rs` (Modified)**

The integration test helper now creates a sample `.java` file in a realistic directory structure.

```diff
// START tests/common.rs
// ...
       .unwrap()
       .write_all(go_content.as_bytes())
       .unwrap();

+   // --- NEW: Add a Java file ---
+   let java_dir = dir.path().join("src/main/java/com/example");
+   fs::create_dir_all(&java_dir).unwrap();
+   let java_content = r#"
+package com.example;
+
+import java.util.ArrayList;
+
+/**
+ * Main application class.
+ * HACK: This is just for a test.
+ */
+public class Application {
+    public static void main(String[] args) {
+        ArrayList<String> list = new ArrayList<>();
+        System.out.println("Hello from Java!");
+    }
+}
+"#;
+   fs::File::create(java_dir.join("Application.java"))
+       .unwrap()
+       .write_all(java_content.as_bytes())
+       .unwrap();
+
    dir
}
// END tests/common.rs
```

### **`tests/java_search.rs` (New File)**

Finally, this new integration test file ensures our Java support works end-to-end.

```rust
// START tests/java_search.rs
use assert_cmd::prelude::*;
use predicates::prelude::*;
use std::process::Command;

mod common;
use common::setup_test_project;

#[test]
fn test_class_predicate_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump").unwrap()
        .current_dir(dir.path())
        .arg("class:Application & ext:java")
        .assert()
        .success()
        .stdout(predicate::str::contains("Application.java"))
        .stdout(predicate::str::contains("public class Application"));
}

#[test]
fn test_func_and_call_predicates_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump").unwrap()
        .current_dir(dir.path())
        .arg("func:main & call:println")
        .assert()
        .success()
        .stdout(predicate::str::contains("public static void main"))
        .stdout(predicate::str::contains("System.out.println"));
}

#[test]
fn test_import_and_comment_predicates_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump").unwrap()
        .current_dir(dir.path())
        .arg("import:ArrayList & comment:HACK")
        .assert()
        .success()
        .stdout(predicate::str::contains("Application.java"));
}

#[test]
fn test_str_predicate_java() {
    let dir = setup_test_project();
    Command::cargo_bin("rdump").unwrap()
        .current_dir(dir.path())
        .arg("str:\"Hello from Java!\"")
        .assert()
        .success()
        .stdout(predicate::str::contains("Application.java"));
}
// END tests/java_search.rs
```

We have successfully integrated full semantic support for Java into `rdump`. The architecture continues to prove its extensibility. The tool's reach has expanded significantly. What's our next target?