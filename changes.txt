 // START rdump/src/formatter.rs
 
 use anyhow::{Context, Result};
 use chrono::{DateTime, Local}; // For formatting timestamps
+use lazy_static::lazy_static;
 use serde::{Deserialize, Serialize};
 use std::fs;
 use std::io::Write;
 #[cfg(unix)]
 use std::os::unix::fs::PermissionsExt; // For Unix permissions
 use std::path::PathBuf;
+use syntect::easy::HighlightLines;
+use syntect::highlighting::{ThemeSet, Style};
+use syntect::parsing::SyntaxSet;
+use syntect::util::{as_24_bit_terminal_escaped, LinesWithEndings};
 
 // We need to pass the format enum from main.rs
 use crate::Format;
 
+lazy_static! {
+    // Lazily load syntax and theme sets once.
+    static ref SYNTAX_SET: SyntaxSet = SyntaxSet::load_defaults_newlines();
+    static ref THEME_SET: ThemeSet = ThemeSet::load_defaults();
+}
+
 #[derive(Serialize, Deserialize, Debug, PartialEq)]
 struct FileOutput {
     path: String,
     content: String,
 }
 
 /// Formats and prints the final output to a generic writer based on the chosen format.
 pub fn print_output(
     writer: &mut impl Write,
     matching_files: &[PathBuf],
     format: &Format,
     with_line_numbers: bool,
+    use_color: bool,
 ) -> Result<()> {
     match format {
         Format::Find => {
@@ -216,13 +229,14 @@
         }
         Format::Cat => {
             for path in matching_files {
-                let content = fs::read_to_string(path).with_context(|| {
-                    format!("Failed to read file for final output: {}", path.display())
-                })?;
-                if with_line_numbers {
-                    for (i, line) in content.lines().enumerate() {
-                        writeln!(writer, "{:>5} | {}", i + 1, line)?;
-                    }
+                let content = fs::read_to_string(path)?;
+                if use_color {
+                    print_highlighted_content(
+                        writer,
+                        &content,
+                        &path.extension().and_then(|s| s.to_str()).unwrap_or(""),
+                        with_line_numbers,
+                    )?;
                 } else {
-                    writeln!(writer, "{}", content)?;
+                    print_plain_content(writer, &content, with_line_numbers)?;
                 }
             }
         }
@@ -244,22 +258,58 @@
                 }
                 writeln!(writer, "File: {}", path.display())?;
                 writeln!(writer, "---")?;
-                let content = fs::read_to_string(path).with_context(|| {
-                    format!("Failed to read file for final output: {}", path.display())
-                })?;
-
-                if with_line_numbers {
-                    for (i, line) in content.lines().enumerate() {
-                        writeln!(writer, "{:>5} | {}", i + 1, line)?;
-                    }
+                let content = fs::read_to_string(path)?;
+
+                if use_color {
+                    print_highlighted_content(
+                        writer,
+                        &content,
+                        &path.extension().and_then(|s| s.to_str()).unwrap_or(""),
+                        with_line_numbers,
+                    )?;
                 } else {
-                    writeln!(writer, "{}", content)?;
+                    print_plain_content(writer, &content, with_line_numbers)?;
                 }
             }
         }
     }
     Ok(())
 }
 
+/// Prints content with syntax highlighting.
+fn print_highlighted_content(
+    writer: &mut impl Write,
+    content: &str,
+    extension: &str,
+    with_line_numbers: bool,
+) -> Result<()> {
+    let syntax = SYNTAX_SET
+        .find_syntax_by_extension(extension)
+        .unwrap_or_else(|| SYNTAX_SET.find_syntax_plain_text());
+    // Using a theme with a background color is important for correctness.
+    let theme = &THEME_SET.themes["base16-ocean.dark"];
+    let mut highlighter = HighlightLines::new(syntax, theme);
+
+    for (i, line) in LinesWithEndings::from(content).enumerate() {
+        if with_line_numbers {
+            write!(writer, "{:>5} | ", i + 1)?;
+        }
+        let ranges: Vec<(Style, &str)> = highlighter.highlight_line(line, &SYNTAX_SET)?;
+        let escaped = as_24_bit_terminal_escaped(&ranges[..], false);
+        write!(writer, "{}", escaped)?;
+    }
+    // Reset terminal colors
+    write!(writer, "\x1b[0m")?;
+    Ok(())
+}
+
+/// Prints content without syntax highlighting.
+fn print_plain_content(writer: &mut impl Write, content: &str, with_line_numbers: bool) -> Result<()> {
+    for (i, line) in content.lines().enumerate() {
+        if with_line_numbers {
+            writeln!(writer, "{:>5} | {}", i + 1, line)?;
+        } else {
+            writeln!(writer, "{}", line)?;
+        }
+    }
+    Ok(())
+}
+
 fn format_mode(mode: u32) -> String {
     #[cfg(unix)]
     {
@@ -330,7 +380,7 @@
         let file = create_temp_file_with_content("line 1");
         let paths = vec![file.path().to_path_buf()];
         let mut writer = Vec::new();
-        print_output(&mut writer, &paths, &Format::Markdown, false).unwrap();
+        print_output(&mut writer, &paths, &Format::Markdown, false, false).unwrap();
         let output = String::from_utf8(writer).unwrap();
         let expected = format!("File: {}\n---\nline 1\n", file.path().display());
         assert_eq!(output, expected);
@@ -341,7 +391,7 @@
         let file = create_temp_file_with_content("a\nb");
         let paths = vec![file.path().to_path_buf()];
         let mut writer = Vec::new();
-        print_output(&mut writer, &paths, &Format::Cat, true).unwrap();
+        print_output(&mut writer, &paths, &Format::Cat, true, false).unwrap();
         let output = String::from_utf8(writer).unwrap();
         assert_eq!(output, "    1 | a\n    2 | b\n");
     }
@@ -352,7 +402,7 @@
         let file2 = create_temp_file_with_content("b");
         let paths = vec![file1.path().to_path_buf(), file2.path().to_path_buf()];
         let mut writer = Vec::new();
-        print_output(&mut writer, &paths, &Format::Paths, false).unwrap();
+        print_output(&mut writer, &paths, &Format::Paths, false, false).unwrap();
         let output = String::from_utf8(writer).unwrap();
         let expected = format!("{}\n{}\n", file1.path().display(), file2.path().display());
         assert_eq!(output, expected);
@@ -364,7 +414,7 @@
         let file2 = create_temp_file_with_content("some text");
         let paths = vec![file1.path().to_path_buf(), file2.path().to_path_buf()];
         let mut writer = Vec::new();
-        print_output(&mut writer, &paths, &Format::Json, false).unwrap();
+        print_output(&mut writer, &paths, &Format::Json, false, false).unwrap();
 
         // The output is pretty-printed, so we compare the parsed data, not the raw string.
         let output_data: Vec<FileOutput> = serde_json::from_slice(&writer).unwrap();
@@ -382,7 +432,7 @@
         let paths = vec![file.path().to_path_buf()];
         let mut writer = Vec::new();
 
-        print_output(&mut writer, &paths, &Format::Find, false).unwrap();
+        print_output(&mut writer, &paths, &Format::Find, false, false).unwrap();
 
         let output = String::from_utf8(writer).unwrap();
 
@@ -391,6 +441,20 @@
         assert!(output.contains(file.path().to_str().unwrap())); // Check for path
         assert!(output.ends_with('\n'));
     }
+
+    #[test]
+    fn test_highlighting_adds_ansi_codes() {
+        let rust_code = "fn main() {}";
+        let temp_dir = tempfile::tempdir().unwrap();
+        let file_path = temp_dir.path().join("test.rs");
+        std::fs::write(&file_path, rust_code).unwrap();
+
+        let paths = vec![file_path];
+        let mut writer = Vec::new();
+        print_output(&mut writer, &paths, &Format::Cat, false, true).unwrap();
+        let output = String::from_utf8(writer).unwrap();
+
+        // A simple check to see if ANSI escape codes are present.
+        assert!(output.contains("\x1b[38;2;"), "Output should contain ANSI color codes for highlighting");
+        assert!(output.ends_with("\x1b[0m"), "Output should end with ANSI reset code");
+    }
 }
 
 // END rdump/src/formatter.rs