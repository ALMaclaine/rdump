Excellent. Let's get this done. We'll implement the full output functionality as planned. This will involve updating the CLI, refactoring the formatter to handle different formats, and connecting it all in `main`.

---

### Step 1: Update the CLI in `main.rs`

First, we need to teach `clap` about our new `--format` option. To do this cleanly, we'll create a `Format` enum and tell `clap` how to parse it. We'll also update the `Cli` struct.

**Replace the `Cli` struct and add the `Format` enum in `rdump/src/main.rs`.**

```rust
// In src/main.rs

// Add this to your `use` statements at the top
use clap::ValueEnum;

// NEW: An enum to represent our output formats for clap
#[derive(Debug, Clone, ValueEnum)]
enum Format {
    Markdown,
    Json,
    Paths,
    Cat,
}

/// A fast, expressive tool to find and dump file contents for LLM context using a query language.
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Cli {
    /// The query string to search for files.
    #[arg(required = true)]
    query: String,

    /// The root directory to start the search from.
    #[arg(short, long, default_value = ".")]
    root: PathBuf,

    /// Output file path. If not provided, output is written to stdout.
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Add line numbers to the output.
    #[arg(short, long)]
    line_numbers: bool,

    /// A shorthand for '--format cat'.
    #[arg(long)]
    no_headers: bool,

    /// The output format for the results.
    #[arg(long, value_enum, default_value_t = Format::Markdown)]
    format: Format,
}
```

### Step 2: Refactor the Formatter

Now, we'll completely rewrite `formatter.rs` to handle the different formats. It will now take our new `Format` enum and use a `match` statement to decide what to do.

**Replace the entire contents of `rdump/src/formatter.rs` with this new version.**

```rust
use anyhow::{Result, Context};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use serde::Serialize;

// We need to pass the format enum from main.rs
use crate::Format;

#[derive(Serialize)]
struct FileOutput {
    path: String,
    content: String,
}

/// Formats and prints the final output to a generic writer based on the chosen format.
pub fn print_output(
    writer: &mut impl Write,
    matching_files: &[PathBuf],
    format: &Format,
    with_line_numbers: bool,
) -> Result<()> {
    match format {
        Format::Paths => {
            for path in matching_files {
                writeln!(writer, "{}", path.display())?;
            }
        }
        Format::Cat => {
            for path in matching_files {
                let content = fs::read_to_string(path)
                    .with_context(|| format!("Failed to read file for final output: {}", path.display()))?;
                if with_line_numbers {
                    for (i, line) in content.lines().enumerate() {
                        writeln!(writer, "{:>5} | {}", i + 1, line)?;
                    }
                } else {
                    writeln!(writer, "{}", content)?;
                }
            }
        }
        Format::Json => {
            let mut outputs = Vec::new();
            for path in matching_files {
                let content = fs::read_to_string(path)
                    .with_context(|| format!("Failed to read file for final output: {}", path.display()))?;
                outputs.push(FileOutput {
                    path: path.to_string_lossy().to_string(),
                    content,
                });
            }
            // Use to_writer_pretty for readable JSON output
            serde_json::to_writer_pretty(writer, &outputs)?;
        }
        Format::Markdown => {
            for (i, path) in matching_files.iter().enumerate() {
                if i > 0 {
                    writeln!(writer, "\n---\n")?;
                }
                writeln!(writer, "File: {}", path.display())?;
                writeln!(writer, "---")?;
                let content = fs::read_to_string(path)
                    .with_context(|| format!("Failed to read file for final output: {}", path.display()))?;

                if with_line_numbers {
                    for (i, line) in content.lines().enumerate() {
                        writeln!(writer, "{:>5} | {}", i + 1, line)?;
                    }
                } else {
                    writeln!(writer, "{}", content)?;
                }
            }
        }
    }
    Ok(())
}


#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::Write;
    use std::path::PathBuf;

    fn create_temp_file_with_content(content: &str) -> NamedTempFile {
        let mut file = tempfile::NamedTempFile::new().unwrap();
        file.write_all(content.as_bytes()).unwrap();
        file
    }

    // --- UPDATED AND NEW TESTS ---

    #[test]
    fn test_format_markdown() {
        let file = create_temp_file_with_content("line 1");
        let paths = vec![file.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Markdown, false).unwrap();
        let output = String::from_utf8(writer).unwrap();
        let expected = format!("File: {}\n---\nline 1\n", file.path().display());
        assert_eq!(output, expected);
    }

    #[test]
    fn test_format_cat_with_line_numbers() {
        let file = create_temp_file_with_content("a\nb");
        let paths = vec![file.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Cat, true).unwrap();
        let output = String::from_utf8(writer).unwrap();
        assert_eq!(output, "    1 | a\n    2 | b\n");
    }

    #[test]
    fn test_format_paths() {
        let file1 = create_temp_file_with_content("a");
        let file2 = create_temp_file_with_content("b");
        let paths = vec![file1.path().to_path_buf(), file2.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Paths, false).unwrap();
        let output = String::from_utf8(writer).unwrap();
        let expected = format!("{}\n{}\n", file1.path().display(), file2.path().display());
        assert_eq!(output, expected);
    }

    #[test]
    fn test_format_json() {
        let file1 = create_temp_file_with_content("{\"key\": \"value\"}");
        let file2 = create_temp_file_with_content("some text");
        let paths = vec![file1.path().to_path_buf(), file2.path().to_path_buf()];
        let mut writer = Vec::new();
        print_output(&mut writer, &paths, &Format::Json, false).unwrap();

        // The output is pretty-printed, so we compare the parsed data, not the raw string.
        let output_data: Vec<FileOutput> = serde_json::from_slice(&writer).unwrap();

        assert_eq!(output_data.len(), 2);
        assert_eq!(output_data[0].path, file1.path().to_string_lossy());
        assert_eq!(output_data[0].content, "{\"key\": \"value\"}");
        assert_eq!(output_data[1].path, file2.path().to_string_lossy());
        assert_eq!(output_data[1].content, "some text");
    }
}
```

### Step 3: Finalize `main.rs`

Now we'll update the `main` function to handle the `--output` flag and pass the correct format to our new formatter. This uses a nice pattern called a "boxed trait object" (`Box<dyn Write>`) to seamlessly switch between writing to the console and writing to a file.

**Replace the `main` function in `rdump/src/main.rs` with this final version.**

```rust
// In src/main.rs

// Add these to your `use` statements at the top
use std::fs::File;
use std::io::{self, Write};

fn main() -> Result<()> {
    let mut cli = Cli::parse();

    // --- Handle `--no-headers` shorthand ---
    if cli.no_headers {
        cli.format = Format::Cat;
    }

    // --- 1. Find candidates ---
    let candidate_files = get_candidate_files(&cli.root)?;

    // --- 2. Parse query ---
    let ast = parser::parse_query(&cli.query)?;

    // --- 3. Evaluate files ---
    let evaluator = Evaluator::new(&ast);
    let mut matching_files: Vec<PathBuf> = candidate_files
        .par_iter()
        .filter_map(|path| match evaluator.evaluate(path) {
            Ok(true) => Some(path.clone()),
            Ok(false) => None,
            Err(e) => {
                eprintln!("Error evaluating file {}: {}", path.display(), e);
                None
            }
        })
        .collect();

    matching_files.sort();

    // --- 4. Format and print results ---
    // This `Box<dyn Write>` lets us decide at runtime whether to write
    // to stdout or a file, without changing the formatter's code.
    let mut writer: Box<dyn Write> = if let Some(output_path) = &cli.output {
        Box::new(File::create(output_path)?)
    } else {
        Box::new(io::stdout())
    };

    formatter::print_output(
        &mut writer,
        &matching_files,
        &cli.format,
        cli.line_numbers,
    )?;

    Ok(())
}
```

### Your Next Steps

1.  Update the `Cli` struct and add the `Format` enum in `src/main.rs`.
2.  Replace the entire contents of `src/formatter.rs` with the new version.
3.  Replace the `main` function in `src/main.rs` with the final version.
4.  Run `cargo test`. All tests should pass.
5.  **Run the finished tool!**
    *   `cargo run -- "ext:toml"`
    *   `cargo run -- --format=json "ext:toml"`
    *   `cargo run -- --format=paths "ext:toml"`
    *   `cargo run -- --output=my_dump.txt "ext:toml"` (This will create a file!)

With this, your tool is now fully spec-complete for v1.0, minus a few of the more advanced predicates and flags. Congratulations