Of course. This is the final and crucial step in our "Polish & Release" roadmap: improving the user experience when they make a mistake. A great tool not only works well but also fails gracefully and provides helpful feedback.

The following changes will be entirely localized to `rdump/src/parser.rs`. I will update the `parse_query` function to catch the raw `pest` error and reformat it into a much more user-friendly message. I will also update the existing error-related tests to assert that these new, cleaner messages are being produced.

---

### **`rdump/src/parser.rs` (Modified)**

The core change is in the `parse_query` function. Instead of simply mapping the error, it now catches it and wraps it in a more helpful `anyhow!` message. The unit tests are also updated to check the content of the error message, making them more robust.

```diff
// START rdump/src/parser.rs

use anyhow::{anyhow, Result};
use pest::iterators::Pair;
use pest::Parser;
use pest_derive::Parser;

#[derive(Parser)]
#[grammar = "rql.pest"]
pub struct RqlParser;

#[derive(Debug, PartialEq, Eq, Hash, Clone)]
pub enum PredicateKey {
    Ext,
    Name,
    Path,
    Contains,
    Matches,
    Size,
    Modified,
    // --- SEMANTIC PREDICATES ---
    // Generic
    Def,
    Func,
    Import,
    // Granular Definitions
    Class,
    Struct,
    Enum,
    Interface,
    Trait,
    Type,
    // Syntactic Content
    Comment,
    Str,
    // A key for testing or unknown predicates
    Other(String),
}

impl From<&str> for PredicateKey {
    fn from(s: &str) -> Self {
        match s {
            "ext" => Self::Ext,
            "name" => Self::Name,
            "path" => Self::Path,
            "contains" => Self::Contains,
            "matches" => Self::Matches,
            "size" => Self::Size,
            "modified" => Self::Modified,
            // --- SEMANTIC ---
            "def" => Self::Def,
            "func" => Self::Func,
            "import" => Self::Import,
            "class" => Self::Class,
            "struct" => Self::Struct,
            "enum" => Self::Enum,
            "interface" => Self::Interface,
            "trait" => Self::Trait,
            "type" => Self::Type,
            "comment" => Self::Comment,
            "str" => Self::Str,
            // Any other key is captured here.
            other => Self::Other(other.to_string()),
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum AstNode {
    Predicate(PredicateKey, String),
    LogicalOp(LogicalOperator, Box<AstNode>, Box<AstNode>),
    Not(Box<AstNode>),
}

#[derive(Debug, PartialEq)]
pub enum LogicalOperator {
    And,
    Or,
}

pub fn parse_query(query: &str) -> Result<AstNode> {
-   let pairs = RqlParser::parse(Rule::query, query)?;
-   build_ast_from_pairs(pairs.peek().unwrap())
+   // Check for empty or whitespace-only queries BEFORE parsing.
+   if query.trim().is_empty() {
+       return Err(anyhow!("Query cannot be empty."));
+   }
+
+   match RqlParser::parse(Rule::query, query) {
+       Ok(pairs) => build_ast_from_pairs(pairs.peek().unwrap()),
+       Err(e) => {
+           // Re-format the pest error to be more user-friendly.
+           Err(anyhow!("Invalid query syntax:\n{}", e))
+       }
+   }
}

fn build_ast_from_pairs(pair: Pair<Rule>) -> Result<AstNode> {
// ... (rest of parsing logic is unchanged) ...
// ...

#[cfg(test)]
mod tests {
// ... (existing success tests are unchanged) ...
    use super::*;

    // Helper to create a predicate node for cleaner tests.
    fn predicate(key: PredicateKey, value: &str) -> Box<AstNode> {
        Box::new(AstNode::Predicate(key, value.to_string()))
    }
// ...
    #[test]
    fn test_parse_semantic_predicates() {
        let ast_def = parse_query("def:User").unwrap();
        assert_eq!(ast_def, *predicate(PredicateKey::Def, "User"));

        let ast_func = parse_query("func:get_user").unwrap();
        assert_eq!(ast_func, *predicate(PredicateKey::Func, "get_user"));

        let ast_import = parse_query("import:serde").unwrap();
        assert_eq!(ast_import, *predicate(PredicateKey::Import, "serde"));
    }

    #[test]
    fn test_parse_granular_and_syntactic_predicates() {
        assert_eq!(parse_query("class:Foo").unwrap(), *predicate(PredicateKey::Class, "Foo"));
        assert_eq!(parse_query("struct:Bar").unwrap(), *predicate(PredicateKey::Struct, "Bar"));
        assert_eq!(parse_query("comment:TODO").unwrap(), *predicate(PredicateKey::Comment, "TODO"));
        assert_eq!(parse_query("str:'api_key'").unwrap(), *predicate(PredicateKey::Str, "api_key"));
    }

+   #[test]
+   fn test_error_on_trailing_operator() {
+       let result = parse_query("ext:rs &");
+       let err = result.unwrap_err();
+       assert!(err.to_string().contains("Invalid query syntax:"));
+       assert!(err.to_string().contains("expected")); // Pest's pointer is still useful
+   }
+
+   #[test]
+   fn test_error_on_missing_value() {
+       let result = parse_query("ext:");
+       let err = result.unwrap_err();
+       assert!(err.to_string().contains("Invalid query syntax:"));
+   }
+
+   #[test]
+   fn test_error_on_unclosed_parenthesis() {
+       let result = parse_gquery("(ext:rs | path:src");
+       let err = result.unwrap_err();
+       assert!(err.to_string().contains("Invalid query syntax:"));
+   }
+
+   #[test]
+   fn test_error_on_empty_query() {
+       let result = parse_query("");
+       assert_eq!(result.unwrap_err().to_string(), "Query cannot be empty.");
+   }
+
+   #[test]
+   fn test_error_on_whitespace_query() {
+       let result = parse_query("   ");
+       assert_eq!(result.unwrap_err().to_string(), "Query cannot be empty.");
+   }
}
// END rdump/src/parser.rs
```

This completes the "Polish & Release" roadmap. We have:
1.  **Optimized** the core evaluation loop for performance.
2.  **Improved** usability by adding sane default ignore patterns.
3.  **Polished** the user experience by providing clear, helpful error messages for invalid queries.

The tool is now fast, intelligent, robust, and user-friendly. It is officially ready for a `v1.0.0` release. Congratulations on building a truly exceptional developer tool.