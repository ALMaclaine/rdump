Of course. Here are the complete changes to add full Python support, validating our extensible architecture.

---

### **`rdump/Cargo.toml` (Modified)**

I've added the `tree-sitter-python` grammar crate as a new dependency.

```diff
 // START rdump/Cargo.toml

 [package]
 name = "rdump"
 version = "0.1.0"
 edition = "2021"

 [dependencies]
 clap = { version = "4.5.4", features = ["derive"] }
 anyhow = "1.0.86"
 ignore = "0.4.22"
 rayon = "1.10.0"
 regex = "1.10.4"
 serde = { version = "1.0.203", features = ["derive"] }
 serde_json = "1.0.117"
 pest = "2.7.10"
 pest_derive = "2.7.10"
 tempfile = "3.20.0"
 glob = "0.3.1"
 dirs = "5.0.1"
 toml = "0.8.12"
 chrono = { version = "0.4", features = ["serde"] }
 lazy_static = "1.4.0"
 tree-sitter = "0.22.6"
 tree-sitter-rust = "0.21.0"
+tree-sitter-python = "0.21.0"

 [dev-dependencies]
 assert_cmd = "2.0.14"
 predicates = "3.1.0"
 tempfile = "3.10.1"

 // END rdump/Cargo.toml
```

### **`rdump/src/predicates/code_aware.rs` (Modified)**

This is the key architectural validation. I've added a `create_python_profile` and registered it, but the core `evaluate` function remains completely unchanged.

```diff
 // START rdump/src/predicates/code_aware.rs

 use crate::evaluator::FileContext;
 use crate::parser::PredicateKey;
 use super::PredicateEvaluator;

 use anyhow::{anyhow, Context, Result};
 use lazy_static::lazy_static;
 use std::collections::HashMap;
 use tree_sitter::{Query, QueryCursor};

 /// Defines the tree-sitter queries for a specific language.
 struct LanguageProfile {
     language: tree_sitter::Language,
     queries: HashMap<PredicateKey, String>,
 }

 // A static registry of language profiles, loaded at compile time.
 lazy_static! {
     static ref LANGUAGE_PROFILES: HashMap<&'static str, LanguageProfile> = {
         let mut m = HashMap::new();
         // Phase 2.0: Only Rust is implemented.
         m.insert("rs", create_rust_profile());
-        // In the future, we will add:
-        // m.insert("py", create_python_profile());
-        // m.insert("js", create_javascript_profile());
+        // Phase 2.1: Add Python support.
+        m.insert("py", create_python_profile());
         m
     };
 }

 /// Creates the profile for the Rust language.
 fn create_rust_profile() -> LanguageProfile {
     let language = tree_sitter_rust::language();
     let mut queries = HashMap::new();

     // Query for struct, enum, and trait definitions.
     // We capture the node associated with the name using `@match`.
     queries.insert(
         PredicateKey::Def,
         "
         [
           (struct_item name: (identifier) @match)
           (enum_item name: (identifier) @match)
           (trait_item name: (identifier) @match)
         ]"
         .to_string(),
     );

     // Query for standalone functions and methods in traits or impls.
     queries.insert(
         PredicateKey::Func,
         "
         [
             (function_item name: (identifier) @match)
             (function_signature_item name: (identifier) @match)
         ]"
         .to_string(),
     );
     // Query for the entire `use` declaration. We will match against its text content.
     queries.insert(
         PredicateKey::Import,
         "
         (use_declaration) @match
         "
         .to_string(),
     );

     LanguageProfile { language, queries }
 }

+/// Creates the profile for the Python language.
+fn create_python_profile() -> LanguageProfile {
+    let language = tree_sitter_python::language();
+    let mut queries = HashMap::new();
+
+    // Query for class definitions.
+    queries.insert(
+        PredicateKey::Def,
+        "
+        (class_definition name: (identifier) @match)
+        "
+        .to_string(),
+    );
+
+    // Query for function definitions.
+    queries.insert(
+        PredicateKey::Func,
+        "
+        (function_definition name: (identifier) @match)
+        "
+        .to_string(),
+    );
+
+    // Query for `import` and `from ... import` statements.
+    queries.insert(
+        PredicateKey::Import,
+        "
+        [
+            (import_statement) @match
+            (import_from_statement) @match
+        ]
+        "
+        .to_string(),
+    );
+
+    LanguageProfile { language, queries }
+}
+
 /// The evaluator that uses tree-sitter to perform code-aware queries.
 #[derive(Debug)]
 pub struct CodeAwareEvaluator;

 impl PredicateEvaluator for CodeAwareEvaluator {
     fn evaluate(&self, context: &mut FileContext, key: &PredicateKey, value: &str) -> Result<bool> {
         // 1. Determine the language from the file extension.
         let extension = context.path.extension().and_then(|s| s.to_str()).unwrap_or("");
         let profile = match LANGUAGE_PROFILES.get(extension) {
             Some(p) => p,
             None => return Ok(false), // Not a supported language for this predicate.
         };

         // 2. Get the tree-sitter query string for the specific predicate.
         let ts_query_str = match profile.queries.get(key) {
             Some(q) if !q.is_empty() => q,
             _ => return Ok(false), // This predicate is not implemented for this language yet.
         };

-        // 3. Lazily get the parsed tree from the file context.
-        let tree = context.get_tree(profile.language)?;
-        let content = context.get_content()?;
+        // 3. Get content and lazily get the parsed tree from the file context.
+        // We get content first to avoid mutable/immutable borrow issues with context.
+        let content = context.get_content()?.to_string(); // Clone to avoid borrow issues
+        let tree = context.get_tree(profile.language)?;

         // 4. Compile the tree-sitter query.
         let query = Query::new(profile.language, ts_query_str)
             .with_context(|| format!("Failed to compile tree-sitter query for key {:?}", key))?;
         let mut cursor = QueryCursor::new();

         // 5. Execute the query and check for a match.
         let captures = cursor.matches(&query, tree.root_node(), content.as_bytes());

         for m in captures {
             for capture in m.captures {
                 // We only care about nodes captured with the name `@match`.
                 let capture_name = &query.capture_names()[capture.index as usize];
                 if capture_name == "match" {
                     let captured_node = capture.node;
                     let captured_text = captured_node.utf8_text(content.as_bytes())?;

                     // `import:` uses substring matching, `def:` and `func:` use exact matching.
                     let is_match = if key == &PredicateKey::Import {
                         captured_text.contains(value)
                     } else {
                         captured_text == value
                     };

                     if is_match {
                         return Ok(true);
                     }
                 }
             }
         }

         Ok(false)
     }
 }
 // END rdump/src/predicates/code_aware.rs
```

### **`rdump/src/predicates/mod.rs` (Modified)**

I've added a new unit test, `test_code_aware_evaluator_python_suite`, to verify the Python logic at the component level.

```diff
 // START rdump/src/predicates/mod.rs

 pub mod code_aware;

 use crate::evaluator::FileContext;
 use crate::parser::PredicateKey;
 use anyhow::{anyhow, Result};
 use std::collections::HashMap;
 use std::time::{Duration, SystemTime};
 use self::code_aware::CodeAwareEvaluator;

 // The core trait that all predicate evaluators must implement.
 pub trait PredicateEvaluator {
     // The key is now passed to allow one evaluator to handle multiple predicate types.
     fn evaluate(&self, context: &mut FileContext, key: &PredicateKey, value: &str) -> Result<bool>;
 }

 // --- Concrete Implementations ---

 struct ExtEvaluator;
 impl PredicateEvaluator for ExtEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let file_ext = context.path.extension().and_then(|s| s.to_str()).unwrap_or("");
         Ok(file_ext.eq_ignore_ascii_case(value))
     }
 }

 struct PathEvaluator;
 impl PredicateEvaluator for PathEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let path_str = context.path.to_string_lossy();
         Ok(path_str.contains(value))
     }
 }

 struct NameEvaluator;
 impl PredicateEvaluator for NameEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let file_name = context.path.file_name().and_then(|s| s.to_str()).unwrap_or("");
         let pattern = glob::Pattern::new(value)?;
         Ok(pattern.matches(file_name))
     }
 }

 struct ContainsEvaluator;
 impl PredicateEvaluator for ContainsEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let content = context.get_content()?;
         Ok(content.contains(value))
     }
 }

 struct MatchesEvaluator;
 impl PredicateEvaluator for MatchesEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let content = context.get_content()?;
         let re = regex::Regex::new(value)?;
         Ok(re.is_match(content))
     }
 }

 struct SizeEvaluator;
 impl PredicateEvaluator for SizeEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let metadata = context.path.metadata()?;
         let file_size = metadata.len();
         parse_and_compare_size(file_size, value)
     }
 }

 struct ModifiedEvaluator;
 impl PredicateEvaluator for ModifiedEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let metadata = context.path.metadata()?;
         let modified_time = metadata.modified()?;
         parse_and_compare_time(modified_time, value)
     }
 }

 fn parse_and_compare_size(file_size: u64, query: &str) -> Result<bool> {
     let (op, size_str) = query.split_at(1);
     let target_size = size_str
         .trim()
         .to_lowercase()
         .replace("kb", " * 1024")
         .replace("mb", " * 1024 * 1024")
         .replace("gb", " * 1024 * 1024 * 1024");

     // A simple expression evaluator for "N * N * N..."
     let target_size_bytes = target_size
         .split('*')
         .map(|s| s.trim().parse::<f64>())
         .collect::<Result<Vec<f64>, _>>()?
         .into_iter()
         .product::<f64>() as u64;

     match op {
         ">" => Ok(file_size > target_size_bytes),
         "<" => Ok(file_size < target_size_bytes),
         "=" => Ok(file_size == target_size_bytes),
         _ => Err(anyhow!("Invalid size operator: {}", op)),
     }
 }

 fn parse_and_compare_time(modified_time: SystemTime, query: &str) -> Result<bool> {
     let now = SystemTime::now();
     let (op, duration_str) = query.split_at(1);
     let duration_str = duration_str.trim();

     let duration_secs = if let Some(num_str) = duration_str.strip_suffix('s') {
         num_str.parse::<u64>()?
     } else if let Some(num_str) = duration_str.strip_suffix('m') {
         num_str.parse::<u64>()? * 60
     } else if let Some(num_str) = duration_str.strip_suffix('h') {
         num_str.parse::<u64>()? * 3600
     } else if let Some(num_str) = duration_str.strip_suffix('d') {
         num_str.parse::<u64>()? * 86400
     } else {
         return Err(anyhow!("Invalid time unit in '{}'", query));
     };

     let duration = Duration::from_secs(duration_secs);
     let threshold_time = now.checked_sub(duration).ok_or(anyhow!("Time calculation underflow"))?;

     match op {
         ">" => Ok(modified_time > threshold_time), // Modified more recently than
         "<" => Ok(modified_time < threshold_time), // Modified longer ago than
         _ => Err(anyhow!("Invalid time operator: {}", op)),
     }
 }

 /// Creates and populates the predicate registry.
 pub fn create_predicate_registry() -> HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> {
     let mut registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> =
         HashMap::new();

     registry.insert(PredicateKey::Ext, Box::new(ExtEvaluator));
     registry.insert(PredicateKey::Name, Box::new(NameEvaluator));
     registry.insert(PredicateKey::Path, Box::new(PathEvaluator));
     registry.insert(PredicateKey::Contains, Box::new(ContainsEvaluator));
     registry.insert(PredicateKey::Matches, Box::new(MatchesEvaluator));
     registry.insert(PredicateKey::Size, Box::new(SizeEvaluator));
     registry.insert(PredicateKey::Modified, Box::new(ModifiedEvaluator));

     // Register the single CodeAwareEvaluator for all semantic predicate keys.
     // It's a stateless struct, so creating multiple boxes is cheap.
     registry.insert(PredicateKey::Def, Box::new(CodeAwareEvaluator));
     registry.insert(PredicateKey::Func, Box::new(CodeAwareEvaluator));
     registry.insert(PredicateKey::Import, Box::new(CodeAwareEvaluator));

     registry
 }

 #[cfg(test)]
 mod tests {
     use super::*;
-    use std::fs::File;
     use std::io::Write;
     use std::path::PathBuf;
     use tempfile::NamedTempFile;

     fn create_temp_file(content: &str) -> NamedTempFile {
         let mut file = NamedTempFile::new().unwrap();
         write!(file, "{}", content).unwrap();
         file
     }

     #[test]
     fn test_size_evaluator() {
         let file = create_temp_file("a".repeat(2000).as_str());
         let mut context = FileContext::new(file.path().to_path_buf());

         let evaluator = SizeEvaluator;
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Size, ">1000").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Size, "<1kb").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Size, ">0.9kb").unwrap());
     }

     #[test]
     fn test_modified_evaluator() {
         let file = create_temp_file("content");
         let mut context = FileContext::new(file.path().to_path_buf());

         let evaluator = ModifiedEvaluator;
         // File was just created
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Modified, ">1m").unwrap()); // Modified more recently than 1 min ago
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Modified, "<1m").unwrap()); // Not modified longer than 1 min ago
     }

     #[test]
     fn test_ext_evaluator() {
         let mut context_rs = FileContext::new(PathBuf::from("main.rs"));
         let mut context_toml = FileContext::new(PathBuf::from("Cargo.TOML"));
         let mut context_no_ext = FileContext::new(PathBuf::from("README"));
         let mut context_dotfile = FileContext::new(PathBuf::from(".bashrc"));

         let evaluator = ExtEvaluator;
         assert!(evaluator.evaluate(&mut context_rs, &PredicateKey::Ext, "rs").unwrap());
         assert!(!evaluator.evaluate(&mut context_rs, &PredicateKey::Ext, "toml").unwrap());
         assert!(evaluator.evaluate(&mut context_toml, &PredicateKey::Ext, "toml").unwrap(), "Should be case-insensitive");
         assert!(!evaluator.evaluate(&mut context_no_ext, &PredicateKey::Ext, "rs").unwrap());
         assert!(!evaluator.evaluate(&mut context_dotfile, &PredicateKey::Ext, "bashrc").unwrap(), "Dotfiles should have no extension");
     }

     #[test]
     fn test_path_evaluator() {
         let mut context = FileContext::new(PathBuf::from("/home/user/project/src/main.rs"));
         let evaluator = PathEvaluator;
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Path, "project/src").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Path, "/home/user").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Path, "project/lib").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Path, "main.rs").unwrap());
     }

     #[test]
     fn test_name_evaluator() {
         let mut context1 = FileContext::new(PathBuf::from("/home/user/Cargo.toml"));
         let mut context2 = FileContext::new(PathBuf::from("/home/user/main.rs"));

         let evaluator = NameEvaluator;
         assert!(evaluator.evaluate(&mut context1, &PredicateKey::Name, "Cargo.toml").unwrap());
         assert!(evaluator.evaluate(&mut context1, &PredicateKey::Name, "C*.toml").unwrap(), "Glob pattern should match");
         assert!(evaluator.evaluate(&mut context2, &PredicateKey::Name, "*.rs").unwrap(), "Glob pattern should match");
         assert!(!evaluator.evaluate(&mut context1, &PredicateKey::Name, "*.rs").unwrap());
     }

     #[test]
     fn test_contains_evaluator() {
         let file = create_temp_file("Hello world\nThis is a test.");
         let mut context = FileContext::new(file.path().to_path_buf());
         let evaluator = ContainsEvaluator;
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Contains, "world").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Contains, "is a test").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Contains, "goodbye").unwrap());
     }

     #[test]
     fn test_matches_evaluator() {
         let file = create_temp_file("version = \"0.1.0\"\nauthor = \"test\"");
         let mut context = FileContext::new(file.path().to_path_buf());
         let evaluator = MatchesEvaluator;
         // Simple regex
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Matches, "version = \"[0-9]+\\.[0-9]+\\.[0-9]+\"").unwrap());
         // Test regex that spans lines
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Matches, "(?s)version.*author").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Matches, "^version = \"1.0.0\"$").unwrap());
     }

     #[test]
     fn test_code_aware_evaluator_rust_def() {
         let rust_code = "struct User; enum Role {}";

         // Create a temp file with a .rs extension
         let temp_dir = tempfile::tempdir().unwrap();
         let file_path = temp_dir.path().join("code.rs");
         let mut file = std::fs::File::create(&file_path).unwrap();
         file.write_all(rust_code.as_bytes()).unwrap();

         let mut context = FileContext::new(file_path.clone());
         let evaluator = CodeAwareEvaluator;

         // Test successful matches
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Def, "User").unwrap(), "Should find struct User");

         // Reset context for the next evaluation on the same file
         let mut context = FileContext::new(file_path);
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Def, "Role").unwrap(), "Should find enum Role");
     }

     #[test]
     fn test_code_aware_evaluator_full_rust_suite() {
         let rust_code = r#"
             use std::collections::HashMap;
             use serde::{Serialize, Deserialize};

             struct AppConfig {}
             trait Runnable {
                 fn run(&self);
             }
             fn launch_app() {}
         "#;

         let temp_dir = tempfile::tempdir().unwrap();
         let file_path = temp_dir.path().join("complex.rs");
         let mut file = std::fs::File::create(&file_path).unwrap();
         file.write_all(rust_code.as_bytes()).unwrap();

         let evaluator = CodeAwareEvaluator;

         // --- Test Definitions ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "AppConfig").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "Runnable").unwrap());

         // --- Test Functions ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "run").unwrap(), "Should find trait method");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "launch_app").unwrap(), "Should find standalone function");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Func, "AppConfig").unwrap());

         // --- Test Imports ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "std::collections").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "serde").unwrap(), "Should match part of a use statement");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "Serialize").unwrap(), "Should match item in a use list");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Import, "anyhow").unwrap());
     }
+
+    #[test]
+    fn test_code_aware_evaluator_python_suite() {
+        let python_code = r#"
+import os
+from sys import argv
+
+class DataProcessor:
+    def __init__(self):
+        pass
+
+def process_data():
+    print("Processing")
+        "#;
+
+        let temp_dir = tempfile::tempdir().unwrap();
+        let file_path = temp_dir.path().join("script.py");
+        let mut file = std::fs::File::create(&file_path).unwrap();
+        file.write_all(python_code.as_bytes()).unwrap();
+
+        let evaluator = CodeAwareEvaluator;
+
+        // --- Test Definitions (Classes) ---
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "DataProcessor").unwrap());
+        let mut ctx = File-Context::new(file_path.clone());
+        assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Def, "process_data").unwrap());
+
+        // --- Test Functions ---
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "process_data").unwrap());
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Func, "DataProcessor").unwrap());
+
+        // --- Test Imports ---
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "os").unwrap());
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "sys").unwrap());
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "argv").unwrap());
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Import, "numpy").unwrap());
+    }
 }

 // END rdump/src/predicates/mod.rs
```

### **`tests/code_aware_search.rs` (Modified)**

I've enhanced the integration test suite to create Python files and added new tests to verify Python-specific queries end-to-end.

```diff
 // START tests/code_aware_search.rs

 use assert_cmd::prelude::*;
 use predicates::prelude::*;
 use std::fs;
 use std::io::Write;
 use std::process::Command;
 use tempfile::tempdir;

 /// A helper to set up a temporary directory with a sample Rust and Python project.
 fn setup_test_project() -> tempfile::TempDir {
     let dir = tempdir().unwrap();
     let src_dir = dir.path().join("src");
     fs::create_dir(&src_dir).unwrap();

     let main_rs_content = r#"
 // This is the main application file.
 use crate::lib::User;

 struct Cli {
     pattern: String,
 }

 pub fn main() {
     println!("Hello, world!");
 }
 "#;
     let mut main_rs = fs::File::create(src_dir.join("main.rs")).unwrap();
     main_rs.write_all(main_rs_content.as_bytes()).unwrap();

     let lib_rs_content = r#"
 // This is a library file.
 use serde::Serialize;

 pub struct User {
     id: u64,
     name: String,
 }

 impl User {
     pub fn new() -> Self {
         Self { id: 0, name: "".into() }
     }
 }

 pub enum Role {
     Admin,
     User,
 }
 "#;
     let mut lib_rs = fs::File::create(src_dir.join("lib.rs")).unwrap();
     lib_rs.write_all(lib_rs_content.as_bytes()).unwrap();

     let readme_md_content = "# Test Project\nThis is a README for Role and User structs.";
     let mut readme_md = fs::File::create(dir.path().join("README.md")).unwrap();
     readme_md.write_all(readme_md_content.as_bytes()).unwrap();

+    // --- NEW: Add a Python file ---
+    let py_content = r#"
+import os
+
+class Helper:
+    def __init__(self):
+        self.path = os.getcwd()
+
+def run_helper():
+    h = Helper()
+    return h.path
+"#;
+    let mut py_file = fs::File::create(dir.path().join("helper.py")).unwrap();
+    py_file.write_all(py_content.as_bytes()).unwrap();
+
     dir
 }

 #[test]
 fn test_def_finds_struct_in_correct_file() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("def:Cli"); // Query for the Cli struct

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/main.rs"))
         .stdout(predicate::str::contains("struct Cli"))
         .stdout(predicate::str::contains("pub fn main()"))
         .stdout(predicate::str::contains("src/lib.rs").not());
 }

 #[test]
 fn test_def_finds_enum_in_correct_file() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("def:Role"); // Query for the Role enum

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("pub enum Role"))
         .stdout(predicate::str::contains("pub struct User"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_def_with_ext_predicate_and_paths_format() {
     let dir = setup_test_project();
     let root = dir.path();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(root);
     cmd.arg("def:User & ext:rs");
     cmd.arg("--format=paths");

     // Normalize path for cross-platform compatibility
     let expected_path_str = format!("src{}lib.rs", std::path::MAIN_SEPARATOR);

     cmd.assert()
         .success()
         .stdout(predicate::str::contains(expected_path_str));
 }

 #[test]
 fn test_def_returns_no_matches_for_non_existent_item() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("def:NonExistent");

     // Should succeed with no output
     cmd.assert().success().stdout(predicate::str::is_empty());
 }

 #[test]
 fn test_def_does_not_match_in_non_rust_files() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     // The README.md contains the words "Role" and "User"
     cmd.arg("def:Role | def:User");

     // It should ONLY find src/lib.rs, not README.md
     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("README.md").not());
 }

 #[test]
 fn test_func_finds_standalone_function() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("func:main");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/main.rs"))
         .stdout(predicate::str::contains("src/lib.rs").not());
 }

 #[test]
 fn test_func_finds_impl_method() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("func:new");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_import_finds_use_statement() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("import:serde");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("use serde::Serialize;"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_logical_or_across_files() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("func:main | import:serde");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/main.rs"))
         .stdout(predicate::str::contains("src/lib.rs"));
 }
+
+#[test]
+fn test_def_finds_python_class() {
+    let dir = setup_test_project();
+
+    let mut cmd = Command::cargo_bin("rdump").unwrap();
+    cmd.current_dir(dir.path());
+    cmd.arg("def:Helper & ext:py");
+
+    cmd.assert()
+        .success()
+        .stdout(predicate::str::contains("helper.py"))
+        .stdout(predicate::str::contains("class Helper:"))
+        .stdout(predicate::str::contains("src/main.rs").not());
+}
+
+#[test]
+fn test_func_finds_python_function() {
+    let dir = setup_test_project();
+
+    let mut cmd = Command::cargo_bin("rdump").unwrap();
+    cmd.current_dir(dir.path());
+    cmd.arg("func:run_helper");
+
+    cmd.assert()
+        .success()
+        .stdout(predicate::str::contains("helper.py"))
+        .stdout(predicate::str::contains("def run_helper():"))
+        .stdout(predicate::str::contains("src/main.rs").not());
+}
+
+#[test]
+fn test_import_finds_python_import() {
+    let dir = setup_test_project();
+
+    let mut cmd = Command::cargo_bin("rdump").unwrap();
+    cmd.current_dir(dir.path());
+    cmd.arg("import:os & ext:py");
+
+    cmd.assert()
+        .success()
+        .stdout(predicate::str::contains("helper.py"))
+        .stdout(predicate::str::contains("import os"))
+        .stdout(predicate::str::contains("src/lib.rs").not());
+}
+
 // END tests/code_aware_search.rs
```