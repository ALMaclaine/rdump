Excellent. With the documentation updated, let's proceed with the final phase of our current roadmap: **Phase 2.2 - adding support for JavaScript and TypeScript.**

This will be a substantial change that touches the same files as the Python implementation, demonstrating the power and scalability of our design.

Here is the complete set of changes to implement JavaScript and TypeScript support.

---

### **`rdump/Cargo.toml` (Modified)**

I've added the `tree-sitter-javascript` and `tree-sitter-typescript` grammar crates.

```diff
 // START rdump/Cargo.toml

 [package]
 name = "rdump"
 version = "0.1.0"
 edition = "2021"

 [dependencies]
 clap = { version = "4.5.4", features = ["derive"] }
 anyhow = "1.0.86"
 ignore = "0.4.22"
 rayon = "1.10.0"
 regex = "1.10.4"
 serde = { version = "1.0.203", features = ["derive"] }
 serde_json = "1.0.117"
 pest = "2.7.10"
 pest_derive = "2.7.10"
 tempfile = "3.20.0"
 glob = "0.3.1"
 dirs = "5.0.1"
 toml = "0.8.12"
 chrono = { version = "0.4", features = ["serde"] }
 lazy_static = "1.4.0"
 tree-sitter = "0.22.6"
 tree-sitter-rust = "0.21.0"
 tree-sitter-python = "0.21.0"
+tree-sitter-javascript = "0.21.0"
+tree-sitter-typescript = "0.21.0"

 [dev-dependencies]
 assert_cmd = "2.0.14"
 predicates = "3.1.0"
 tempfile = "3.10.1"

 // END rdump/Cargo.toml
```

### **`rdump/src/predicates/code_aware.rs` (Modified)**

I've added `create_javascript_profile` and `create_typescript_profile`, populating them with the correct `tree-sitter` queries. Then, I registered them in the `LANGUAGE_PROFILES` map for the relevant file extensions (`js`, `jsx`, `ts`, `tsx`). The core evaluation logic remains unchanged.

```diff
 // START rdump/src/predicates/code_aware.rs

 use crate::evaluator::FileContext;
 use crate::parser::PredicateKey;
 use super::PredicateEvaluator;

 use anyhow::{anyhow, Context, Result};
 use lazy_static::lazy_static;
 use std::collections::HashMap;
 use tree_sitter::{Query, QueryCursor};

 /// Defines the tree-sitter queries for a specific language.
 struct LanguageProfile {
     language: tree_sitter::Language,
     queries: HashMap<PredicateKey, String>,
 }

 // A static registry of language profiles, loaded at compile time.
 lazy_static! {
     static ref LANGUAGE_PROFILES: HashMap<&'static str, LanguageProfile> = {
         let mut m = HashMap::new();
         // Phase 2.0: Only Rust is implemented.
         m.insert("rs", create_rust_profile());
         // Phase 2.1: Add Python support.
         m.insert("py", create_python_profile());
+        // Phase 2.2: Add JS/TS support
+        let ts_profile = create_typescript_profile();
+        m.insert("ts", ts_profile);
+        m.insert("tsx", create_typescript_profile()); // Reuse TS profile for TSX
+
+        let js_profile = create_javascript_profile();
+        m.insert("js", js_profile);
+        m.insert("jsx", create_javascript_profile()); // Reuse JS profile for JSX
         m
     };
 }

 /// Creates the profile for the Rust language.
 fn create_rust_profile() -> LanguageProfile {
     let language = tree_sitter_rust::language();
     let mut queries = HashMap::new();

     // Query for struct, enum, and trait definitions.
     // We capture the node associated with the name using `@match`.
     queries.insert(
         PredicateKey::Def,
         "
         [
           (struct_item name: (identifier) @match)
           (enum_item name: (identifier) @match)
           (trait_item name: (identifier) @match)
         ]"
         .to_string(),
     );

     // Query for standalone functions and methods in traits or impls.
     queries.insert(
         PredicateKey::Func,
         "
         [
             (function_item name: (identifier) @match)
             (function_signature_item name: (identifier) @match)
         ]"
         .to_string(),
     );
     // Query for the entire `use` declaration. We will match against its text content.
     queries.insert(
         PredicateKey::Import,
         "
         (use_declaration) @match
         "
         .to_string(),
     );

     LanguageProfile { language, queries }
 }

 /// Creates the profile for the Python language.
 fn create_python_profile() -> LanguageProfile {
     let language = tree_sitter_python::language();
     let mut queries = HashMap::new();

     // Query for class definitions.
     queries.insert(
         PredicateKey::Def,
         "
         (class_definition name: (identifier) @match)
         "
         .to_string(),
     );

     // Query for function definitions.
     queries.insert(
         PredicateKey::Func,
         "
         (function_definition name: (identifier) @match)
         "
         .to_string(),
     );

     // Query for `import` and `from ... import` statements.
     queries.insert(
         PredicateKey::Import,
         "
         [
             (import_statement) @match
             (import_from_statement) @match
         ]
         "
         .to_string(),
     );

     LanguageProfile { language, queries }
 }

+/// Creates the profile for the JavaScript language.
+fn create_javascript_profile() -> LanguageProfile {
+    let language = tree_sitter_javascript::language();
+    let mut queries = HashMap::new();
+
+    queries.insert(PredicateKey::Def, "(class_declaration name: (identifier) @match)".to_string());
+    queries.insert(PredicateKey::Func, "[ (function_declaration name: (identifier) @match) (method_definition property: (property_identifier) @match) ]".to_string());
+    queries.insert(PredicateKey::Import, "(import_statement) @match".to_string());
+
+    LanguageProfile { language, queries }
+}
+
+/// Creates the profile for the TypeScript language.
+fn create_typescript_profile() -> LanguageProfile {
+    let language = tree_sitter_typescript::language_typescript();
+    let mut queries = HashMap::new();
+
+    queries.insert(PredicateKey::Def, "[ (class_declaration name: (type_identifier) @match) (interface_declaration name: (type_identifier) @match) (type_alias_declaration name: (type_identifier) @match) ]".to_string());
+    queries.insert(PredicateKey::Func, "[ (function_declaration name: (identifier) @match) (method_definition name: (property_identifier) @match) ]".to_string());
+    queries.insert(PredicateKey::Import, "(import_statement) @match".to_string());
+
+    LanguageProfile { language, queries }
+}
+
 /// The evaluator that uses tree-sitter to perform code-aware queries.
 #[derive(Debug)]
 pub struct CodeAwareEvaluator;

 impl PredicateEvaluator for CodeAwareEvaluator {
     fn evaluate(&self, context: &mut FileContext, key: &PredicateKey, value: &str) -> Result<bool> {
         // 1. Determine the language from the file extension.
         let extension = context.path.extension().and_then(|s| s.to_str()).unwrap_or("");
         let profile = match LANGUAGE_PROFILES.get(extension) {
             Some(p) => p,
             None => return Ok(false), // Not a supported language for this predicate.
         };

         // 2. Get the tree-sitter query string for the specific predicate.
         let ts_query_str = match profile.queries.get(key) {
             Some(q) if !q.is_empty() => q,
             _ => return Ok(false), // This predicate is not implemented for this language yet.
         };

         // 3. Get content and lazily get the parsed tree from the file context.
         // We get content first to avoid mutable/immutable borrow issues with context.
         let content = context.get_content()?.to_string(); // Clone to avoid borrow issues
         let tree = context.get_tree(profile.language)?;

         // 4. Compile the tree-sitter query.
         let query = Query::new(profile.language, ts_query_str)
             .with_context(|| format!("Failed to compile tree-sitter query for key {:?}", key))?;
         let mut cursor = QueryCursor::new();

         // 5. Execute the query and check for a match.
         let captures = cursor.matches(&query, tree.root_node(), content.as_bytes());

         for m in captures {
             for capture in m.captures {
                 // We only care about nodes captured with the name `@match`.
                 let capture_name = &query.capture_names()[capture.index as usize];
                 if capture_name == "match" {
                     let captured_node = capture.node;
                     let captured_text = captured_node.utf8_text(content.as_bytes())?;

                     // `import:` uses substring matching, `def:` and `func:` use exact matching.
                     let is_match = if key == &PredicateKey::Import {
                         captured_text.contains(value)
                     } else {
                         captured_text == value
                     };

                     if is_match {
                         return Ok(true);
                     }
                 }
             }
         }

         Ok(false)
     }
 }
 // END rdump/src/predicates/code_aware.rs
```

### **`rdump/src/predicates/mod.rs` (Modified)**

I've added two new unit tests, one for JavaScript and one for TypeScript, to validate the new profiles at the component level.

```diff
 // START rdump/src/predicates/mod.rs

 pub mod code_aware;

 use crate::evaluator::FileContext;
 use crate::parser::PredicateKey;
 use anyhow::{anyhow, Result};
 use std::collections::HashMap;
 use std::time::{Duration, SystemTime};
 use self::code_aware::CodeAwareEvaluator;

 // The core trait that all predicate evaluators must implement.
 pub trait PredicateEvaluator {
     // The key is now passed to allow one evaluator to handle multiple predicate types.
     fn evaluate(&self, context: &mut FileContext, key: &PredicateKey, value: &str) -> Result<bool>;
 }

 // --- Concrete Implementations ---

 struct ExtEvaluator;
 impl PredicateEvaluator for ExtEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let file_ext = context.path.extension().and_then(|s| s.to_str()).unwrap_or("");
         Ok(file_ext.eq_ignore_ascii_case(value))
     }
 }

 struct PathEvaluator;
 impl PredicateEvaluator for PathEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let path_str = context.path.to_string_lossy();
         Ok(path_str.contains(value))
     }
 }

 struct NameEvaluator;
 impl PredicateEvaluator for NameEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let file_name = context.path.file_name().and_then(|s| s.to_str()).unwrap_or("");
         let pattern = glob::Pattern::new(value)?;
         Ok(pattern.matches(file_name))
     }
 }

 struct ContainsEvaluator;
 impl PredicateEvaluator for ContainsEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let content = context.get_content()?;
         Ok(content.contains(value))
     }
 }

 struct MatchesEvaluator;
 impl PredicateEvaluator for MatchesEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let content = context.get_content()?;
         let re = regex::Regex::new(value)?;
         Ok(re.is_match(content))
     }
 }

 struct SizeEvaluator;
 impl PredicateEvaluator for SizeEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let metadata = context.path.metadata()?;
         let file_size = metadata.len();
         parse_and_compare_size(file_size, value)
     }
 }

 struct ModifiedEvaluator;
 impl PredicateEvaluator for ModifiedEvaluator {
     fn evaluate(&self, context: &mut FileContext, _key: &PredicateKey, value: &str) -> Result<bool> {
         let metadata = context.path.metadata()?;
         let modified_time = metadata.modified()?;
         parse_and_compare_time(modified_time, value)
     }
 }

 fn parse_and_compare_size(file_size: u64, query: &str) -> Result<bool> {
     let (op, size_str) = query.split_at(1);
     let target_size = size_str
         .trim()
         .to_lowercase()
         .replace("kb", " * 1024")
         .replace("mb", " * 1024 * 1024")
         .replace("gb", " * 1024 * 1024 * 1024");

     // A simple expression evaluator for "N * N * N..."
     let target_size_bytes = target_size
         .split('*')
         .map(|s| s.trim().parse::<f64>())
         .collect::<Result<Vec<f64>, _>>()?
         .into_iter()
         .product::<f64>() as u64;

     match op {
         ">" => Ok(file_size > target_size_bytes),
         "<" => Ok(file_size < target_size_bytes),
         "=" => Ok(file_size == target_size_bytes),
         _ => Err(anyhow!("Invalid size operator: {}", op)),
     }
 }

 fn parse_and_compare_time(modified_time: SystemTime, query: &str) -> Result<bool> {
     let now = SystemTime::now();
     let (op, duration_str) = query.split_at(1);
     let duration_str = duration_str.trim();

     let duration_secs = if let Some(num_str) = duration_str.strip_suffix('s') {
         num_str.parse::<u64>()?
     } else if let Some(num_str) = duration_str.strip_suffix('m') {
         num_str.parse::<u64>()? * 60
     } else if let Some(num_str) = duration_str.strip_suffix('h') {
         num_str.parse::<u64>()? * 3600
     } else if let Some(num_str) = duration_str.strip_suffix('d') {
         num_str.parse::<u64>()? * 86400
     } else {
         return Err(anyhow!("Invalid time unit in '{}'", query));
     };

     let duration = Duration::from_secs(duration_secs);
     let threshold_time = now.checked_sub(duration).ok_or(anyhow!("Time calculation underflow"))?;

     match op {
         ">" => Ok(modified_time > threshold_time), // Modified more recently than
         "<" => Ok(modified_time < threshold_time), // Modified longer ago than
         _ => Err(anyhow!("Invalid time operator: {}", op)),
     }
 }

 /// Creates and populates the predicate registry.
 pub fn create_predicate_registry() -> HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> {
     let mut registry: HashMap<PredicateKey, Box<dyn PredicateEvaluator + Send + Sync>> =
         HashMap::new();

     registry.insert(PredicateKey::Ext, Box::new(ExtEvaluator));
     registry.insert(PredicateKey::Name, Box::new(NameEvaluator));
     registry.insert(PredicateKey::Path, Box::new(PathEvaluator));
     registry.insert(PredicateKey::Contains, Box::new(ContainsEvaluator));
     registry.insert(PredicateKey::Matches, Box::new(MatchesEvaluator));
     registry.insert(PredicateKey::Size, Box::new(SizeEvaluator));
     registry.insert(PredicateKey::Modified, Box::new(ModifiedEvaluator));

     // Register the single CodeAwareEvaluator for all semantic predicate keys.
     // It's a stateless struct, so creating multiple boxes is cheap.
     registry.insert(PredicateKey::Def, Box::new(CodeAwareEvaluator));
     registry.insert(PredicateKey::Func, Box::new(CodeAwareEvaluator));
     registry.insert(PredicateKey::Import, Box::new(CodeAwareEvaluator));

     registry
 }

 #[cfg(test)]
 mod tests {
     use super::*;
-    use std::fs::File;
     use std::io::Write;
     use std::path::PathBuf;
     use tempfile::NamedTempFile;

     fn create_temp_file(content: &str) -> NamedTempFile {
         let mut file = NamedTempFile::new().unwrap();
         write!(file, "{}", content).unwrap();
         file
     }

     #[test]
     fn test_size_evaluator() {
         let file = create_temp_file("a".repeat(2000).as_str());
         let mut context = FileContext::new(file.path().to_path_buf());

         let evaluator = SizeEvaluator;
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Size, ">1000").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Size, "<1kb").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Size, ">0.9kb").unwrap());
     }

     #[test]
     fn test_modified_evaluator() {
         let file = create_temp_file("content");
         let mut context = FileContext::new(file.path().to_path_buf());

         let evaluator = ModifiedEvaluator;
         // File was just created
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Modified, ">1m").unwrap()); // Modified more recently than 1 min ago
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Modified, "<1m").unwrap()); // Not modified longer than 1 min ago
     }

     #[test]
     fn test_ext_evaluator() {
         let mut context_rs = FileContext::new(PathBuf::from("main.rs"));
         let mut context_toml = FileContext::new(PathBuf::from("Cargo.TOML"));
         let mut context_no_ext = FileContext::new(PathBuf::from("README"));
         let mut context_dotfile = FileContext::new(PathBuf::from(".bashrc"));

         let evaluator = ExtEvaluator;
         assert!(evaluator.evaluate(&mut context_rs, &PredicateKey::Ext, "rs").unwrap());
         assert!(!evaluator.evaluate(&mut context_rs, &PredicateKey::Ext, "toml").unwrap());
         assert!(evaluator.evaluate(&mut context_toml, &PredicateKey::Ext, "toml").unwrap(), "Should be case-insensitive");
         assert!(!evaluator.evaluate(&mut context_no_ext, &PredicateKey::Ext, "rs").unwrap());
         assert!(!evaluator.evaluate(&mut context_dotfile, &PredicateKey::Ext, "bashrc").unwrap(), "Dotfiles should have no extension");
     }

     #[test]
     fn test_path_evaluator() {
         let mut context = FileContext::new(PathBuf::from("/home/user/project/src/main.rs"));
         let evaluator = PathEvaluator;
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Path, "project/src").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Path, "/home/user").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Path, "project/lib").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Path, "main.rs").unwrap());
     }

     #[test]
     fn test_name_evaluator() {
         let mut context1 = FileContext::new(PathBuf::from("/home/user/Cargo.toml"));
         let mut context2 = FileContext::new(PathBuf::from("/home/user/main.rs"));

         let evaluator = NameEvaluator;
         assert!(evaluator.evaluate(&mut context1, &PredicateKey::Name, "Cargo.toml").unwrap());
         assert!(evaluator.evaluate(&mut context1, &PredicateKey::Name, "C*.toml").unwrap(), "Glob pattern should match");
         assert!(evaluator.evaluate(&mut context2, &PredicateKey::Name, "*.rs").unwrap(), "Glob pattern should match");
         assert!(!evaluator.evaluate(&mut context1, &PredicateKey::Name, "*.rs").unwrap());
     }

     #[test]
     fn test_contains_evaluator() {
         let file = create_temp_file("Hello world\nThis is a test.");
         let mut context = FileContext::new(file.path().to_path_buf());
         let evaluator = ContainsEvaluator;
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Contains, "world").unwrap());
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Contains, "is a test").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Contains, "goodbye").unwrap());
     }

     #[test]
     fn test_matches_evaluator() {
         let file = create_temp_file("version = \"0.1.0\"\nauthor = \"test\"");
         let mut context = FileContext::new(file.path().to_path_buf());
         let evaluator = MatchesEvaluator;
         // Simple regex
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Matches, "version = \"[0-9]+\\.[0-9]+\\.[0-9]+\"").unwrap());
         // Test regex that spans lines
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Matches, "(?s)version.*author").unwrap());
         assert!(!evaluator.evaluate(&mut context, &PredicateKey::Matches, "^version = \"1.0.0\"$").unwrap());
     }

     #[test]
     fn test_code_aware_evaluator_rust_def() {
         let rust_code = "struct User; enum Role {}";

         // Create a temp file with a .rs extension
         let temp_dir = tempfile::tempdir().unwrap();
         let file_path = temp_dir.path().join("code.rs");
         let mut file = std::fs::File::create(&file_path).unwrap();
         file.write_all(rust_code.as_bytes()).unwrap();

         let mut context = FileContext::new(file_path.clone());
         let evaluator = CodeAwareEvaluator;

         // Test successful matches
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Def, "User").unwrap(), "Should find struct User");

         // Reset context for the next evaluation on the same file
         let mut context = FileContext::new(file_path);
         assert!(evaluator.evaluate(&mut context, &PredicateKey::Def, "Role").unwrap(), "Should find enum Role");
     }

     #[test]
     fn test_code_aware_evaluator_full_rust_suite() {
         let rust_code = r#"
             use std::collections::HashMap;
             use serde::{Serialize, Deserialize};

             struct AppConfig {}
             trait Runnable {
                 fn run(&self);
             }
             fn launch_app() {}
         "#;

         let temp_dir = tempfile::tempdir().unwrap();
         let file_path = temp_dir.path().join("complex.rs");
         let mut file = std::fs::File::create(&file_path).unwrap();
         file.write_all(rust_code.as_bytes()).unwrap();

         let evaluator = CodeAwareEvaluator;

         // --- Test Definitions ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "AppConfig").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "Runnable").unwrap());

         // --- Test Functions ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "run").unwrap(), "Should find trait method");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "launch_app").unwrap(), "Should find standalone function");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Func, "AppConfig").unwrap());

         // --- Test Imports ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "std::collections").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "serde").unwrap(), "Should match part of a use statement");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "Serialize").unwrap(), "Should match item in a use list");
         let mut ctx = FileContext::new(file_path.clone());
         assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Import, "anyhow").unwrap());
     }

     #[test]
     fn test_code_aware_evaluator_python_suite() {
         let python_code = r#"
 import os
 from sys import argv

 class DataProcessor:
     def __init__(self):
         pass

 def process_data():
     print("Processing")
         "#;

         let temp_dir = tempfile::tempdir().unwrap();
         let file_path = temp_dir.path().join("script.py");
         let mut file = std::fs::File::create(&file_path).unwrap();
         file.write_all(python_code.as_bytes()).unwrap();

         let evaluator = CodeAwareEvaluator;

         // --- Test Definitions (Classes) ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "DataProcessor").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Def, "process_data").unwrap());

         // --- Test Functions ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "process_data").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Func, "DataProcessor").unwrap());

         // --- Test Imports ---
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "os").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "sys").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "argv").unwrap());
         let mut ctx = FileContext::new(file_path.clone());
         assert!(!evaluator.evaluate(&mut ctx, &PredicateKey::Import, "numpy").unwrap());
     }
+
+    #[test]
+    fn test_code_aware_evaluator_javascript_suite() {
+        let js_code = r#"
+            import { open } from 'fs/promises';
+
+            class Logger {
+                log(message) { console.log(message); }
+            }
+
+            function a() { }
+        "#;
+
+        let temp_dir = tempfile::tempdir().unwrap();
+        let file_path = temp_dir.path().join("script.js");
+        file_path.parent().unwrap().to_path_buf().push("script.js");
+        let mut file = std::fs::File::create(&file_path).unwrap();
+        file.write_all(js_code.as_bytes()).unwrap();
+
+        let evaluator = CodeAwareEvaluator;
+
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "Logger").unwrap());
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "log").unwrap());
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "fs/promises").unwrap());
+    }
+
+    #[test]
+    fn test_code_aware_evaluator_typescript_suite() {
+        let ts_code = r#"
+            import React from 'react';
+
+            interface User { id: number; }
+            type ID = string | number;
+
+            class ApiClient {
+                fetchUser(): User | null { return null; }
+            }
+        "#;
+
+        let temp_dir = tempfile::tempdir().unwrap();
+        let file_path = temp_dir.path().join("api.ts");
+        let mut file = std::fs::File::create(&file_path).unwrap();
+        file.write_all(ts_code.as_bytes()).unwrap();
+
+        let evaluator = CodeAwareEvaluator;
+
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "User").unwrap(), "Should find interface");
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "ID").unwrap(), "Should find type alias");
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Def, "ApiClient").unwrap(), "Should find class");
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Func, "fetchUser").unwrap());
+        let mut ctx = FileContext::new(file_path.clone());
+        assert!(evaluator.evaluate(&mut ctx, &PredicateKey::Import, "React").unwrap());
+    }
 }

 // END rdump/src/predicates/mod.rs
```

### **`tests/code_aware_search.rs` (Modified)**

Finally, I've updated the integration tests to include `.js` and `.ts` files and added new tests to verify the end-to-end functionality for these languages.

```diff
 // START tests/code_aware_search.rs

 use assert_cmd::prelude::*;
 use predicates::prelude::*;
 use std::fs;
 use std::io::Write;
 use std::process::Command;
 use tempfile::tempdir;

-/// A helper to set up a temporary directory with a sample Rust and Python project.
+/// A helper to set up a temporary directory with a multi-language sample project.
 fn setup_test_project() -> tempfile::TempDir {
     let dir = tempdir().unwrap();
     let src_dir = dir.path().join("src");
     fs::create_dir(&src_dir).unwrap();

     let main_rs_content = r#"
 // This is the main application file.
 use crate::lib::User;

 struct Cli {
     pattern: String,
 }

 pub fn main() {
     println!("Hello, world!");
 }
 "#;
     let mut main_rs = fs::File::create(src_dir.join("main.rs")).unwrap();
     main_rs.write_all(main_rs_content.as_bytes()).unwrap();

     let lib_rs_content = r#"
 // This is a library file.
 use serde::Serialize;

 pub struct User {
     id: u64,
     name: String,
 }

 impl User {
     pub fn new() -> Self {
         Self { id: 0, name: "".into() }
     }
 }

 pub enum Role {
     Admin,
     User,
 }
 "#;
     let mut lib_rs = fs::File::create(src_dir.join("lib.rs")).unwrap();
     lib_rs.write_all(lib_rs_content.as_bytes()).unwrap();

     let readme_md_content = "# Test Project\nThis is a README for Role and User structs.";
     let mut readme_md = fs::File::create(dir.path().join("README.md")).unwrap();
     readme_md.write_all(readme_md_content.as_bytes()).unwrap();

-    // --- NEW: Add a Python file ---
+    // --- Add a Python file ---
     let py_content = r#"
 import os

 class Helper:
     def __init__(self):
         self.path = os.getcwd()

 def run_helper():
     h = Helper()
     return h.path
 "#;
     let mut py_file = fs::File::create(dir.path().join("helper.py")).unwrap();
     py_file.write_all(py_content.as_bytes()).unwrap();

+    // --- NEW: Add JS and TS files ---
+    let js_content = r#"
+import { a } from './lib';
+
+export class OldLogger {
+    log(msg) { console.log(msg); }
+}
+"#;
+    fs::File::create(src_dir.join("logger.js"))
+        .unwrap()
+        .write_all(js_content.as_bytes())
+        .unwrap();
+
+    let ts_content = r#"
+import * as path from 'path';
+
+export interface ILog {
+    message: string;
+}
+
+export type LogLevel = "info" | "warn" | "error";
+
+export function createLog(message: string): ILog {
+    return { message };
+}
+"#;
+    fs::File::create(src_dir.join("log_utils.ts"))
+        .unwrap()
+        .write_all(ts_content.as_bytes())
+        .unwrap();
+
     dir
 }

 #[test]
 fn test_def_finds_struct_in_correct_file() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("def:Cli"); // Query for the Cli struct

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/main.rs"))
         .stdout(predicate::str::contains("struct Cli"))
         .stdout(predicate::str::contains("pub fn main()"))
         .stdout(predicate::str::contains("src/lib.rs").not());
 }

 #[test]
 fn test_def_finds_enum_in_correct_file() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("def:Role"); // Query for the Role enum

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("pub enum Role"))
         .stdout(predicate::str::contains("pub struct User"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_def_with_ext_predicate_and_paths_format() {
     let dir = setup_test_project();
     let root = dir.path();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(root);
     cmd.arg("def:User & ext:rs");
     cmd.arg("--format=paths");

     // Normalize path for cross-platform compatibility
     let expected_path_str = format!("src{}lib.rs", std::path::MAIN_SEPARATOR);

     cmd.assert()
         .success()
         .stdout(predicate::str::contains(expected_path_str));
 }

 #[test]
 fn test_def_returns_no_matches_for_non_existent_item() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("def:NonExistent");

     // Should succeed with no output
     cmd.assert().success().stdout(predicate::str::is_empty());
 }

 #[test]
 fn test_def_does_not_match_in_non_rust_files() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     // The README.md contains the words "Role" and "User"
     cmd.arg("def:Role | def:User");

     // It should ONLY find src/lib.rs, not README.md
     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("README.md").not());
 }

 #[test]
 fn test_func_finds_standalone_function() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("func:main");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/main.rs"))
         .stdout(predicate::str::contains("src/lib.rs").not());
 }

 #[test]
 fn test_func_finds_impl_method() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("func:new");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_import_finds_use_statement() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("import:serde");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/lib.rs"))
         .stdout(predicate::str::contains("use serde::Serialize;"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_logical_or_across_files() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("func:main | import:serde");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("src/main.rs"))
         .stdout(predicate::str::contains("src/lib.rs"));
 }

 #[test]
 fn test_def_finds_python_class() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("def:Helper & ext:py");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("helper.py"))
         .stdout(predicate::str::contains("class Helper:"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_func_finds_python_function() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("func:run_helper");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("helper.py"))
         .stdout(predicate::str::contains("def run_helper():"))
         .stdout(predicate::str::contains("src/main.rs").not());
 }

 #[test]
 fn test_import_finds_python_import() {
     let dir = setup_test_project();

     let mut cmd = Command::cargo_bin("rdump").unwrap();
     cmd.current_dir(dir.path());
     cmd.arg("import:os & ext:py");

     cmd.assert()
         .success()
         .stdout(predicate::str::contains("helper.py"))
         .stdout(predicate::str::contains("import os"))
         .stdout(predicate::str::contains("src/lib.rs").not());
 }

+#[test]
+fn test_def_finds_javascript_class() {
+    let dir = setup_test_project();
+
+    let mut cmd = Command::cargo_bin("rdump").unwrap();
+    cmd.current_dir(dir.path());
+    cmd.arg("def:OldLogger");
+
+    cmd.assert()
+        .success()
+        .stdout(predicate::str::contains("logger.js"))
+        .stdout(predicate::str::contains("class OldLogger"))
+        .stdout(predicate::str::contains("log_utils.ts").not());
+}
+
+#[test]
+fn test_def_finds_typescript_interface_and_type() {
+    let dir = setup_test_project();
+    let mut cmd = Command::cargo_bin("rdump").unwrap();
+    cmd.current_dir(dir.path()).arg("def:ILog | def:LogLevel");
+
+    cmd.assert()
+        .success()
+        .stdout(predicate::str::contains("log_utils.ts"))
+        .stdout(predicate::str::contains("interface ILog"))
+        .stdout(predicate::str::contains(r#"type LogLevel = "info" | "warn" | "error";"#));
+}
+
+#[test]
+fn test_func_finds_typescript_function() {
+    let dir = setup_test_project();
+    let mut cmd = Command::cargo_bin("rdump").unwrap();
+    cmd.current_dir(dir.path()).arg("func:createLog");
+
+    cmd.assert()
+        .success()
+        .stdout(predicate::str::contains("log_utils.ts"))
+        .stdout(predicate::str::contains("export function createLog"));
+}
+
+#[test]
+fn test_import_finds_typescript_import() {
+    let dir = setup_test_project();
+    let mut cmd = Command::cargo_bin("rdump").unwrap();
+    cmd.current_dir(dir.path()).arg("import:path & ext:ts");
+
+    cmd.assert()
+        .success()
+        .stdout(predicate::str::contains("log_utils.ts"))
+        .stdout(predicate::str::contains("import * as path from 'path';"));
+}
 // END tests/code_aware_search.rs
```